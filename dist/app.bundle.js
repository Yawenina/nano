/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./public";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/zoid/dist/zoid.frame.js":
/*!**********************************************!*\
  !*** ./node_modules/zoid/dist/zoid.frame.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(root, factory) {
     true ? module.exports = factory() : undefined;
}("undefined" != typeof self ? self : this, function() {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: !1,
                exports: {}
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = !0;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports, name, getter) {
            __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                configurable: !1,
                enumerable: !0,
                get: getter
            });
        };
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ? function() {
                return module.default;
            } : function() {
                return module;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
        };
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = "./src/index.js");
    }({
        "./node_modules/beaver-logger/client/builders.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.addPayloadBuilder = function(builder) {
                payloadBuilders.push(builder);
            };
            exports.addMetaBuilder = function(builder) {
                metaBuilders.push(builder);
            };
            exports.addTrackingBuilder = function(builder) {
                trackingBuilders.push(builder);
            };
            exports.addHeaderBuilder = function(builder) {
                headerBuilders.push(builder);
            };
            var payloadBuilders = exports.payloadBuilders = [], metaBuilders = exports.metaBuilders = [], trackingBuilders = exports.trackingBuilders = [], headerBuilders = exports.headerBuilders = [];
        },
        "./node_modules/beaver-logger/client/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.config = {
                uri: "",
                prefix: "",
                initial_state_name: "init",
                flushInterval: 6e5,
                debounceInterval: 10,
                sizeLimit: 300,
                silent: !1,
                heartbeat: !0,
                heartbeatConsoleLog: !0,
                heartbeatInterval: 5e3,
                heartbeatTooBusy: !1,
                heartbeatTooBusyThreshold: 1e4,
                logLevel: "warn",
                autoLog: [ "warn", "error" ],
                logUnload: !0,
                logPerformance: !0
            }, exports.logLevels = [ "error", "warn", "info", "debug" ];
        },
        "./node_modules/beaver-logger/client/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/beaver-logger/client/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/beaver-logger/client/init.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.init = function(conf) {
                (0, _util.extend)(_config.config, conf || {});
                if (initiated) return;
                initiated = !0;
                _config.config.logPerformance && (0, _performance.initPerformance)();
                _config.config.heartbeat && (0, _performance.initHeartBeat)();
                if (_config.config.logUnload) {
                    window.addEventListener("beforeunload", function() {
                        (0, _logger.info)("window_beforeunload");
                        (0, _logger.immediateFlush)({
                            fireAndForget: !0
                        });
                    });
                    window.addEventListener("unload", function() {
                        (0, _logger.info)("window_unload");
                        (0, _logger.immediateFlush)({
                            fireAndForget: !0
                        });
                    });
                }
                _config.config.flushInterval && setInterval(_logger.flush, _config.config.flushInterval);
                if (window.beaverLogQueue) {
                    window.beaverLogQueue.forEach(function(payload) {
                        (0, _logger.log)(payload.level, payload.event, payload);
                    });
                    delete window.beaverLogQueue;
                }
            };
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _performance = __webpack_require__("./node_modules/beaver-logger/client/performance.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), initiated = !1;
        },
        "./node_modules/beaver-logger/client/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js");
            Object.keys(_logger).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _logger[key];
                    }
                });
            });
            var _init = __webpack_require__("./node_modules/beaver-logger/client/init.js");
            Object.keys(_init).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _init[key];
                    }
                });
            });
            var _transitions = __webpack_require__("./node_modules/beaver-logger/client/transitions.js");
            Object.keys(_transitions).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _transitions[key];
                    }
                });
            });
            var _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js");
            Object.keys(_builders).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _builders[key];
                    }
                });
            });
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
        },
        "./node_modules/beaver-logger/client/logger.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.track = exports.flush = exports.tracking = exports.buffer = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.getTransport = function() {
                return transport;
            };
            exports.setTransport = function(newTransport) {
                transport = newTransport;
            };
            exports.print = print;
            exports.immediateFlush = immediateFlush;
            exports.log = log;
            exports.prefix = function(name) {
                return {
                    debug: function(event, payload) {
                        return log("debug", name + "_" + event, payload);
                    },
                    info: function(event, payload) {
                        return log("info", name + "_" + event, payload);
                    },
                    warn: function(event, payload) {
                        return log("warn", name + "_" + event, payload);
                    },
                    error: function(event, payload) {
                        return log("error", name + "_" + event, payload);
                    },
                    track: function(payload) {
                        return _track(payload);
                    },
                    flush: function() {
                        return _flush();
                    }
                };
            };
            exports.debug = function(event, payload) {
                return log("debug", event, payload);
            };
            exports.info = function(event, payload) {
                return log("info", event, payload);
            };
            exports.warn = function(event, payload) {
                return log("warn", event, payload);
            };
            exports.error = function(event, payload) {
                return log("error", event, payload);
            };
            var _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), buffer = exports.buffer = [], tracking = exports.tracking = [];
            Function.prototype.bind && window.console && "object" === _typeof(console.log) && [ "log", "info", "warn", "error" ].forEach(function(method) {
                console[method] = this.bind(console[method], console);
            }, Function.prototype.call);
            var transport = function(headers, data, options) {
                return (0, _util.ajax)("post", _config.config.uri, headers, data, options);
            };
            var loaded = !1;
            setTimeout(function() {
                loaded = !0;
            }, 1);
            function print(level, event, payload) {
                if (!loaded) return setTimeout(function() {
                    return print(level, event, payload);
                }, 1);
                if (window.console && window.console.log) {
                    var logLevel = window.LOG_LEVEL || _config.config.logLevel;
                    if (!(_config.logLevels.indexOf(level) > _config.logLevels.indexOf(logLevel))) {
                        payload = payload || {};
                        var args = [ event ];
                        (0, _util.isIE)() && (payload = JSON.stringify(payload));
                        args.push(payload);
                        (payload.error || payload.warning) && args.push("\n\n", payload.error || payload.warning);
                        try {
                            window.console[level] && window.console[level].apply ? window.console[level].apply(window.console, args) : window.console.log && window.console.log.apply && window.console.log.apply(window.console, args);
                        } catch (err) {}
                    }
                }
            }
            function immediateFlush() {
                var _ref$fireAndForget = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).fireAndForget, fireAndForget = void 0 !== _ref$fireAndForget && _ref$fireAndForget;
                if (_config.config.uri) {
                    var hasBuffer = buffer.length, hasTracking = tracking.length;
                    if (hasBuffer || hasTracking) {
                        var meta = {}, _iterator = _builders.metaBuilders, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref2 = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref2 = _i.value;
                            }
                            var builder = _ref2;
                            try {
                                (0, _util.extend)(meta, builder(meta), !1);
                            } catch (err) {
                                console.error("Error in custom meta builder:", err.stack || err.toString());
                            }
                        }
                        var headers = {}, _iterator2 = _builders.headerBuilders, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref3 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref3 = _i2.value;
                            }
                            var _builder = _ref3;
                            try {
                                (0, _util.extend)(headers, _builder(headers), !1);
                            } catch (err) {
                                console.error("Error in custom header builder:", err.stack || err.toString());
                            }
                        }
                        var req = transport(headers, {
                            events: buffer,
                            meta: meta,
                            tracking: tracking
                        }, {
                            fireAndForget: fireAndForget
                        });
                        exports.buffer = buffer = [];
                        exports.tracking = tracking = [];
                        return req;
                    }
                }
            }
            var _flush = (0, _util.promiseDebounce)(immediateFlush, _config.config.debounceInterval);
            exports.flush = _flush;
            function enqueue(level, event, payload) {
                buffer.push({
                    level: level,
                    event: event,
                    payload: payload
                });
                _config.config.autoLog.indexOf(level) > -1 && _flush();
            }
            function log(level, event, payload) {
                _config.config.prefix && (event = _config.config.prefix + "_" + event);
                "string" == typeof (payload = payload || {}) ? payload = {
                    message: payload
                } : payload instanceof Error && (payload = {
                    error: payload.stack || payload.toString()
                });
                try {
                    JSON.stringify(payload);
                } catch (err) {
                    return;
                }
                payload.timestamp = Date.now();
                var _iterator3 = _builders.payloadBuilders, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref4 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref4 = _i3.value;
                    }
                    var builder = _ref4;
                    try {
                        (0, _util.extend)(payload, builder(payload), !1);
                    } catch (err) {
                        console.error("Error in custom payload builder:", err.stack || err.toString());
                    }
                }
                _config.config.silent || print(level, event, payload);
                buffer.length === _config.config.sizeLimit ? enqueue("info", "logger_max_buffer_length") : buffer.length < _config.config.sizeLimit && enqueue(level, event, payload);
            }
            function _track(payload) {
                if (payload) {
                    try {
                        JSON.stringify(payload);
                    } catch (err) {
                        return;
                    }
                    var _iterator4 = _builders.trackingBuilders, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref5 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref5 = _i4.value;
                        }
                        var builder = _ref5;
                        try {
                            (0, _util.extend)(payload, builder(payload), !1);
                        } catch (err) {
                            console.error("Error in custom tracking builder:", err.stack || err.toString());
                        }
                    }
                    print("debug", "tracking", payload);
                    tracking.push(payload);
                }
            }
            exports.track = _track;
        },
        "./node_modules/beaver-logger/client/performance.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.reqTimer = exports.clientTimer = void 0;
            exports.now = now;
            exports.reqStartElapsed = reqStartElapsed;
            exports.initHeartBeat = function() {
                var heartBeatTimer = timer(), heartbeatCount = 0;
                (0, _util.safeInterval)(function() {
                    if (!(_config.config.heartbeatMaxThreshold && heartbeatCount > _config.config.heartbeatMaxThreshold)) {
                        heartbeatCount += 1;
                        var elapsed = heartBeatTimer.elapsed(), lag = elapsed - _config.config.heartbeatInterval, heartbeatPayload = {
                            count: heartbeatCount,
                            elapsed: elapsed
                        };
                        if (_config.config.heartbeatTooBusy) {
                            heartbeatPayload.lag = lag;
                            lag >= _config.config.heartbeatTooBusyThreshold && (0, _logger.info)("toobusy", heartbeatPayload, {
                                noConsole: !_config.config.heartbeatConsoleLog
                            });
                        }
                        (0, _logger.info)("heartbeat", heartbeatPayload, {
                            noConsole: !_config.config.heartbeatConsoleLog
                        });
                    }
                }, _config.config.heartbeatInterval);
            };
            exports.initPerformance = function() {
                if (!enablePerformance) return (0, _logger.info)("no_performance_data");
                (0, _builders.addPayloadBuilder)(function() {
                    var payload = {};
                    payload.client_elapsed = clientTimer.elapsed();
                    enablePerformance && (payload.req_elapsed = reqTimer.elapsed());
                    return payload;
                });
                _util.windowReady.then(function() {
                    var timing = {};
                    [ "connectEnd", "connectStart", "domComplete", "domContentLoadedEventEnd", "domContentLoadedEventStart", "domInteractive", "domLoading", "domainLookupEnd", "domainLookupStart", "fetchStart", "loadEventEnd", "loadEventStart", "navigationStart", "redirectEnd", "redirectStart", "requestStart", "responseEnd", "responseStart", "secureConnectionStart", "unloadEventEnd", "unloadEventStart" ].forEach(function(key) {
                        timing[key] = parseInt(window.performance.timing[key], 10) || 0;
                    });
                    var offset = timing.connectEnd - timing.navigationStart;
                    timing.connectEnd && Object.keys(timing).forEach(function(name) {
                        var time = timing[name];
                        time && (0, _logger.info)("timing_" + name, {
                            client_elapsed: parseInt(time - timing.connectEnd - (clientTimer.startTime - offset), 10),
                            req_elapsed: parseInt(time - timing.connectEnd, 10)
                        });
                    });
                    (0, _logger.info)("timing", timing);
                    (0, _logger.info)("memory", window.performance.memory);
                    (0, _logger.info)("navigation", window.performance.navigation);
                    window.performance.getEntries && window.performance.getEntries().forEach(function(resource) {
                        [ "link", "script", "img", "css" ].indexOf(resource.initiatorType) > -1 && (0, _logger.info)(resource.initiatorType, resource);
                    });
                });
            };
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), enablePerformance = window && window.performance && performance.now && performance.timing && performance.timing.connectEnd && performance.timing.navigationStart && Math.abs(performance.now() - Date.now()) > 1e3 && performance.now() - (performance.timing.connectEnd - performance.timing.navigationStart) > 0;
            function now() {
                return enablePerformance ? performance.now() : Date.now();
            }
            function timer(startTime) {
                return {
                    startTime: startTime = void 0 !== startTime ? startTime : now(),
                    elapsed: function() {
                        return parseInt(now() - startTime, 10);
                    },
                    reset: function() {
                        startTime = now();
                    }
                };
            }
            function reqStartElapsed() {
                if (enablePerformance) {
                    var timing = window.performance.timing;
                    return parseInt(timing.connectEnd - timing.navigationStart, 10);
                }
            }
            var clientTimer = exports.clientTimer = timer(), reqTimer = exports.reqTimer = timer(reqStartElapsed());
        },
        "./node_modules/beaver-logger/client/transitions.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.startTransition = startTransition;
            exports.endTransition = endTransition;
            exports.transition = function(toState) {
                startTransition();
                endTransition(toState);
            };
            var _performance = __webpack_require__("./node_modules/beaver-logger/client/performance.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), windowID = (0, 
            _util.uniqueID)(), pageID = (0, _util.uniqueID)(), currentState = _config.config.initial_state_name, startTime = void 0;
            function startTransition() {
                startTime = (0, _performance.now)();
            }
            function endTransition(toState) {
                startTime = startTime || (0, _performance.reqStartElapsed)();
                var currentTime = (0, _performance.now)(), elapsedTime = void 0;
                void 0 !== startTime && (elapsedTime = parseInt(currentTime - startTime, 0));
                var transitionName = "transition_" + currentState + "_to_" + toState;
                (0, _logger.info)(transitionName, {
                    duration: elapsedTime
                });
                (0, _logger.track)({
                    transition: transitionName,
                    transition_time: elapsedTime
                });
                (0, _logger.immediateFlush)();
                startTime = currentTime;
                currentState = toState;
                pageID = (0, _util.uniqueID)();
            }
            (0, _builders.addPayloadBuilder)(function() {
                return {
                    windowID: windowID,
                    pageID: pageID
                };
            });
            (0, _builders.addMetaBuilder)(function() {
                return {
                    state: "ui_" + currentState
                };
            });
        },
        "./node_modules/beaver-logger/client/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.windowReady = void 0;
            exports.extend = function(dest, src) {
                var over = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                dest = dest || {};
                src = src || {};
                for (var i in src) src.hasOwnProperty(i) && (!over && dest.hasOwnProperty(i) || (dest[i] = src[i]));
                return dest;
            };
            exports.isSameProtocol = isSameProtocol;
            exports.isSameDomain = isSameDomain;
            exports.ajax = function(method, url) {
                var headers = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, data = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, _ref$fireAndForget = (arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}).fireAndForget, fireAndForget = void 0 !== _ref$fireAndForget && _ref$fireAndForget;
                return new _src.ZalgoPromise(function(resolve) {
                    var XRequest = window.XMLHttpRequest || window.ActiveXObject;
                    if (window.XDomainRequest && !isSameDomain(url)) {
                        if (!isSameProtocol(url)) return resolve();
                        XRequest = window.XDomainRequest;
                    }
                    var req = new XRequest("MSXML2.XMLHTTP.3.0");
                    req.open(method.toUpperCase(), url, !0);
                    if ("function" == typeof req.setRequestHeader) {
                        req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                        req.setRequestHeader("Content-type", "application/json");
                        for (var headerName in headers) headers.hasOwnProperty(headerName) && req.setRequestHeader(headerName, headers[headerName]);
                    }
                    fireAndForget ? resolve() : req.onreadystatechange = function() {
                        req.readyState > 3 && resolve();
                    };
                    req.send(JSON.stringify(data).replace(/&/g, "%26"));
                });
            };
            exports.promiseDebounce = function(method, interval) {
                var debounce = {};
                return function() {
                    var args = arguments;
                    if (debounce.timeout) {
                        clearTimeout(debounce.timeout);
                        delete debounce.timeout;
                    }
                    debounce.timeout = setTimeout(function() {
                        var resolver = debounce.resolver, rejector = debounce.rejector;
                        delete debounce.promise;
                        delete debounce.resolver;
                        delete debounce.rejector;
                        delete debounce.timeout;
                        return _src.ZalgoPromise.resolve().then(function() {
                            return method.apply(null, args);
                        }).then(resolver, rejector);
                    }, interval);
                    debounce.promise = debounce.promise || new _src.ZalgoPromise(function(resolver, rejector) {
                        debounce.resolver = resolver;
                        debounce.rejector = rejector;
                    });
                    return debounce.promise;
                };
            };
            exports.safeInterval = function(method, time) {
                var timeout = void 0;
                !function loop() {
                    timeout = setTimeout(function() {
                        method();
                        loop();
                    }, time);
                }();
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            };
            exports.uniqueID = function() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            };
            exports.isIE = function() {
                return Boolean(window.document.documentMode);
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            function isSameProtocol(url) {
                return window.location.protocol === url.split("/")[0];
            }
            function isSameDomain(url) {
                var match = url.match(/https?:\/\/[^/]+/);
                return !match || match[0] === window.location.protocol + "//" + window.location.host;
            }
            exports.windowReady = new _src.ZalgoPromise(function(resolve) {
                "undefined" != typeof document && "complete" === document.readyState && resolve();
                window.addEventListener && window.addEventListener("load", resolve);
            });
        },
        "./node_modules/cross-domain-safe-weakmap/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/cross-domain-safe-weakmap/src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _weakmap = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/weakmap.js");
            Object.defineProperty(exports, "WeakMap", {
                enumerable: !0,
                get: function() {
                    return _weakmap.CrossDomainSafeWeakMap;
                }
            });
        },
        "./node_modules/cross-domain-safe-weakmap/src/native.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.hasNativeWeakMap = function() {
                if (!window.WeakMap) return !1;
                if (!window.Object.freeze) return !1;
                try {
                    var testWeakMap = new window.WeakMap(), testKey = {};
                    window.Object.freeze(testKey);
                    testWeakMap.set(testKey, "__testvalue__");
                    return "__testvalue__" === testWeakMap.get(testKey);
                } catch (err) {
                    return !1;
                }
            };
        },
        "./node_modules/cross-domain-safe-weakmap/src/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.safeIndexOf = function(collection, item) {
                for (var i = 0; i < collection.length; i++) try {
                    if (collection[i] === item) return i;
                } catch (err) {}
                return -1;
            };
            exports.noop = function() {};
        },
        "./node_modules/cross-domain-safe-weakmap/src/weakmap.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CrossDomainSafeWeakMap = void 0;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _native = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/native.js"), _util = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/util.js");
            var defineProperty = Object.defineProperty, counter = Date.now() % 1e9;
            exports.CrossDomainSafeWeakMap = function() {
                function CrossDomainSafeWeakMap() {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, CrossDomainSafeWeakMap);
                    counter += 1;
                    this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__" + counter;
                    if ((0, _native.hasNativeWeakMap)()) try {
                        this.weakmap = new window.WeakMap();
                    } catch (err) {}
                    this.keys = [];
                    this.values = [];
                }
                CrossDomainSafeWeakMap.prototype._cleanupClosedWindows = function() {
                    for (var weakmap = this.weakmap, keys = this.keys, i = 0; i < keys.length; i++) {
                        var value = keys[i];
                        if ((0, _src.isWindow)(value) && (0, _src.isWindowClosed)(value)) {
                            if (weakmap) try {
                                weakmap.delete(value);
                            } catch (err) {}
                            keys.splice(i, 1);
                            this.values.splice(i, 1);
                            i -= 1;
                        }
                    }
                };
                CrossDomainSafeWeakMap.prototype.isSafeToReadWrite = function(key) {
                    if ((0, _src.isWindow)(key)) return !1;
                    try {
                        (0, _util.noop)(key && key.self);
                        (0, _util.noop)(key && key[this.name]);
                    } catch (err) {
                        return !1;
                    }
                    return !0;
                };
                CrossDomainSafeWeakMap.prototype.set = function(key, value) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.set(key, value);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var name = this.name, entry = key[name];
                        entry && entry[0] === key ? entry[1] = value : defineProperty(key, name, {
                            value: [ key, value ],
                            writable: !0
                        });
                    } else {
                        this._cleanupClosedWindows();
                        var keys = this.keys, values = this.values, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 === index) {
                            keys.push(key);
                            values.push(value);
                        } else values[index] = value;
                    }
                };
                CrossDomainSafeWeakMap.prototype.get = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        if (weakmap.has(key)) return weakmap.get(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (!this.isSafeToReadWrite(key)) {
                        this._cleanupClosedWindows();
                        var keys = this.keys, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 === index) return;
                        return this.values[index];
                    }
                    var entry = key[this.name];
                    if (entry && entry[0] === key) return entry[1];
                };
                CrossDomainSafeWeakMap.prototype.delete = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.delete(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var entry = key[this.name];
                        entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                    } else {
                        this._cleanupClosedWindows();
                        var keys = this.keys, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 !== index) {
                            keys.splice(index, 1);
                            this.values.splice(index, 1);
                        }
                    }
                };
                CrossDomainSafeWeakMap.prototype.has = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        return weakmap.has(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var entry = key[this.name];
                        return !(!entry || entry[0] !== key);
                    }
                    this._cleanupClosedWindows();
                    return -1 !== (0, _util.safeIndexOf)(this.keys, key);
                };
                return CrossDomainSafeWeakMap;
            }();
        },
        "./node_modules/cross-domain-utils/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _utils = __webpack_require__("./node_modules/cross-domain-utils/src/utils.js");
            Object.keys(_utils).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _utils[key];
                    }
                });
            });
            var _types = __webpack_require__("./node_modules/cross-domain-utils/src/types.js");
            Object.keys(_types).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _types[key];
                    }
                });
            });
        },
        "./node_modules/cross-domain-utils/src/types.js": function(module, exports, __webpack_require__) {
            "use strict";
        },
        "./node_modules/cross-domain-utils/src/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isRegex = function(item) {
                return "[object RegExp]" === Object.prototype.toString.call(item);
            };
            exports.noop = function() {};
        },
        "./node_modules/cross-domain-utils/src/utils.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isFileProtocol = function() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window).location.protocol === CONSTANTS.FILE_PROTOCOL;
            };
            exports.isAboutProtocol = isAboutProtocol;
            exports.getParent = getParent;
            exports.getOpener = getOpener;
            exports.canReadFromWindow = canReadFromWindow;
            exports.getActualDomain = getActualDomain;
            exports.getDomain = getDomain;
            exports.isBlankDomain = function(win) {
                try {
                    if (!win.location.href) return !0;
                    if ("about:blank" === win.location.href) return !0;
                } catch (err) {}
                return !1;
            };
            exports.isActuallySameDomain = isActuallySameDomain;
            exports.isSameDomain = isSameDomain;
            exports.getParents = getParents;
            exports.isAncestorParent = isAncestorParent;
            exports.getFrames = getFrames;
            exports.getAllChildFrames = getAllChildFrames;
            exports.getTop = getTop;
            exports.getAllFramesInWindow = getAllFramesInWindow;
            exports.isTop = function(win) {
                return win === getTop(win);
            };
            exports.isFrameWindowClosed = isFrameWindowClosed;
            exports.isWindowClosed = isWindowClosed;
            exports.linkFrameWindow = function(frame) {
                !function() {
                    for (var i = 0; i < iframeFrames.length; i++) if (isFrameWindowClosed(iframeFrames[i])) {
                        iframeFrames.splice(i, 1);
                        iframeWindows.splice(i, 1);
                    }
                    for (var _i5 = 0; _i5 < iframeWindows.length; _i5++) if (isWindowClosed(iframeWindows[_i5])) {
                        iframeFrames.splice(_i5, 1);
                        iframeWindows.splice(_i5, 1);
                    }
                }();
                if (frame && frame.contentWindow) try {
                    iframeWindows.push(frame.contentWindow);
                    iframeFrames.push(frame);
                } catch (err) {}
            };
            exports.getUserAgent = function(win) {
                return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;
            };
            exports.getFrameByName = getFrameByName;
            exports.findChildFrameByName = findChildFrameByName;
            exports.findFrameByName = function(win, name) {
                var frame = void 0;
                if (frame = getFrameByName(win, name)) return frame;
                return findChildFrameByName(getTop(win) || win, name);
            };
            exports.isParent = function(win, frame) {
                var frameParent = getParent(frame);
                if (frameParent) return frameParent === win;
                for (var _iterator6 = getFrames(win), _isArray6 = Array.isArray(_iterator6), _i8 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i8 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i8++];
                    } else {
                        if ((_i8 = _iterator6.next()).done) break;
                        _ref6 = _i8.value;
                    }
                    var childFrame = _ref6;
                    if (childFrame === frame) return !0;
                }
                return !1;
            };
            exports.isOpener = function(parent, child) {
                return parent === getOpener(child);
            };
            exports.getAncestor = getAncestor;
            exports.getAncestors = function(win) {
                var results = [], ancestor = win;
                for (;ancestor; ) (ancestor = getAncestor(ancestor)) && results.push(ancestor);
                return results;
            };
            exports.isAncestor = function(parent, child) {
                var actualParent = getAncestor(child);
                if (actualParent) return actualParent === parent;
                if (child === parent) return !1;
                if (getTop(child) === child) return !1;
                for (var _iterator7 = getFrames(parent), _isArray7 = Array.isArray(_iterator7), _i9 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i9 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i9++];
                    } else {
                        if ((_i9 = _iterator7.next()).done) break;
                        _ref7 = _i9.value;
                    }
                    var frame = _ref7;
                    if (frame === child) return !0;
                }
                return !1;
            };
            exports.isPopup = isPopup;
            exports.isIframe = isIframe;
            exports.isFullpage = function() {
                return Boolean(!isIframe() && !isPopup());
            };
            exports.getDistanceFromTop = getDistanceFromTop;
            exports.getNthParent = getNthParent;
            exports.getNthParentFromTop = function(win) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return getNthParent(win, getDistanceFromTop(win) - n);
            };
            exports.isSameTopWindow = function(win1, win2) {
                var top1 = getTop(win1) || win1, top2 = getTop(win2) || win2;
                try {
                    if (top1 && top2) return top1 === top2;
                } catch (err) {}
                var allFrames1 = getAllFramesInWindow(win1), allFrames2 = getAllFramesInWindow(win2);
                if (anyMatch(allFrames1, allFrames2)) return !0;
                var opener1 = getOpener(top1), opener2 = getOpener(top2);
                if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) return !1;
                if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) return !1;
                return !1;
            };
            exports.matchDomain = function matchDomain(pattern, origin) {
                if ("string" == typeof pattern) {
                    if ("string" == typeof origin) return pattern === CONSTANTS.WILDCARD || origin === pattern;
                    if ((0, _util.isRegex)(origin)) return !1;
                    if (Array.isArray(origin)) return !1;
                }
                if ((0, _util.isRegex)(pattern)) return (0, _util.isRegex)(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern));
                if (Array.isArray(pattern)) return Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !(0, 
                _util.isRegex)(origin) && pattern.some(function(subpattern) {
                    return matchDomain(subpattern, origin);
                });
                return !1;
            };
            exports.stringifyDomainPattern = function(pattern) {
                return Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : (0, _util.isRegex)(pattern) ? "RegExp(" + pattern.toString() : pattern.toString();
            };
            exports.getDomainFromUrl = function(url) {
                var domain = void 0;
                if (!url.match(/^(https?|mock|file):\/\//)) return getDomain();
                domain = url;
                return domain = domain.split("/").slice(0, 3).join("/");
            };
            exports.onCloseWindow = function(win, callback) {
                var delay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3, maxtime = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0, timeout = void 0;
                !function check() {
                    if (isWindowClosed(win)) {
                        timeout && clearTimeout(timeout);
                        return callback();
                    }
                    if (maxtime <= 0) clearTimeout(timeout); else {
                        maxtime -= delay;
                        timeout = setTimeout(check, delay);
                    }
                }();
                return {
                    cancel: function() {
                        timeout && clearTimeout(timeout);
                    }
                };
            };
            exports.isWindow = function(obj) {
                try {
                    if (obj === window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if ("[object Window]" === Object.prototype.toString.call(obj)) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (window.Window && obj instanceof window.Window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.self === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.parent === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.top === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    (0, _util.noop)(obj == obj);
                } catch (err) {
                    return !0;
                }
                try {
                    (0, _util.noop)(obj && obj.__cross_domain_utils_window_check__);
                } catch (err) {
                    return !0;
                }
                return !1;
            };
            var _util = __webpack_require__("./node_modules/cross-domain-utils/src/util.js"), CONSTANTS = {
                MOCK_PROTOCOL: "mock:",
                FILE_PROTOCOL: "file:",
                ABOUT_PROTOCOL: "about:",
                WILDCARD: "*"
            }, IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
            function isAboutProtocol() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window).location.protocol === CONSTANTS.ABOUT_PROTOCOL;
            }
            function getParent(win) {
                if (win) try {
                    if (win.parent && win.parent !== win) return win.parent;
                } catch (err) {}
            }
            function getOpener(win) {
                if (win && !getParent(win)) try {
                    return win.opener;
                } catch (err) {}
            }
            function canReadFromWindow(win) {
                try {
                    (0, _util.noop)(win && win.location && win.location.href);
                    return !0;
                } catch (err) {}
                return !1;
            }
            function getActualDomain(win) {
                var location = win.location;
                if (!location) throw new Error("Can not read window location");
                var protocol = location.protocol;
                if (!protocol) throw new Error("Can not read window protocol");
                if (protocol === CONSTANTS.FILE_PROTOCOL) return CONSTANTS.FILE_PROTOCOL + "//";
                if (protocol === CONSTANTS.ABOUT_PROTOCOL) {
                    var parent = getParent(win);
                    return parent && canReadFromWindow(win) ? getActualDomain(parent) : CONSTANTS.ABOUT_PROTOCOL + "//";
                }
                var host = location.host;
                if (!host) throw new Error("Can not read window host");
                return protocol + "//" + host;
            }
            function getDomain(win) {
                var domain = getActualDomain(win = win || window);
                return domain && win.mockDomain && 0 === win.mockDomain.indexOf(CONSTANTS.MOCK_PROTOCOL) ? win.mockDomain : domain;
            }
            function isActuallySameDomain(win) {
                try {
                    if (win === window) return !0;
                } catch (err) {}
                try {
                    var desc = Object.getOwnPropertyDescriptor(win, "location");
                    if (desc && !1 === desc.enumerable) return !1;
                } catch (err) {}
                try {
                    if (isAboutProtocol(win) && canReadFromWindow(win)) return !0;
                } catch (err) {}
                try {
                    if (getActualDomain(win) === getActualDomain(window)) return !0;
                } catch (err) {}
                return !1;
            }
            function isSameDomain(win) {
                if (!isActuallySameDomain(win)) return !1;
                try {
                    if (win === window) return !0;
                    if (isAboutProtocol(win) && canReadFromWindow(win)) return !0;
                    if (getDomain(window) === getDomain(win)) return !0;
                } catch (err) {}
                return !1;
            }
            function getParents(win) {
                var result = [];
                try {
                    for (;win.parent !== win; ) {
                        result.push(win.parent);
                        win = win.parent;
                    }
                } catch (err) {}
                return result;
            }
            function isAncestorParent(parent, child) {
                if (!parent || !child) return !1;
                var childParent = getParent(child);
                return childParent ? childParent === parent : -1 !== getParents(child).indexOf(parent);
            }
            function getFrames(win) {
                var result = [], frames = void 0;
                try {
                    frames = win.frames;
                } catch (err) {
                    frames = win;
                }
                var len = void 0;
                try {
                    len = frames.length;
                } catch (err) {}
                if (0 === len) return result;
                if (len) {
                    for (var i = 0; i < len; i++) {
                        var frame = void 0;
                        try {
                            frame = frames[i];
                        } catch (err) {
                            continue;
                        }
                        result.push(frame);
                    }
                    return result;
                }
                for (var _i = 0; _i < 100; _i++) {
                    var _frame = void 0;
                    try {
                        _frame = frames[_i];
                    } catch (err) {
                        return result;
                    }
                    if (!_frame) return result;
                    result.push(_frame);
                }
                return result;
            }
            function getAllChildFrames(win) {
                var result = [], _iterator = getFrames(win), _isArray = Array.isArray(_iterator), _i2 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i2 >= _iterator.length) break;
                        _ref = _iterator[_i2++];
                    } else {
                        if ((_i2 = _iterator.next()).done) break;
                        _ref = _i2.value;
                    }
                    var frame = _ref;
                    result.push(frame);
                    var _iterator2 = getAllChildFrames(frame), _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i3 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i3++];
                        } else {
                            if ((_i3 = _iterator2.next()).done) break;
                            _ref2 = _i3.value;
                        }
                        var childFrame = _ref2;
                        result.push(childFrame);
                    }
                }
                return result;
            }
            function getTop(win) {
                if (win) {
                    try {
                        if (win.top) return win.top;
                    } catch (err) {}
                    if (getParent(win) === win) return win;
                    try {
                        if (isAncestorParent(window, win) && window.top) return window.top;
                    } catch (err) {}
                    try {
                        if (isAncestorParent(win, window) && window.top) return window.top;
                    } catch (err) {}
                    var _iterator3 = getAllChildFrames(win), _isArray3 = Array.isArray(_iterator3), _i4 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i4 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i4++];
                        } else {
                            if ((_i4 = _iterator3.next()).done) break;
                            _ref3 = _i4.value;
                        }
                        var frame = _ref3;
                        try {
                            if (frame.top) return frame.top;
                        } catch (err) {}
                        if (getParent(frame) === frame) return frame;
                    }
                }
            }
            function getAllFramesInWindow(win) {
                var top = getTop(win);
                return getAllChildFrames(top).concat(top);
            }
            function isFrameWindowClosed(frame) {
                if (!frame.contentWindow) return !0;
                if (!frame.parentNode) return !0;
                var doc = frame.ownerDocument;
                return !(!doc || !doc.body || doc.body.contains(frame));
            }
            var iframeWindows = [], iframeFrames = [];
            function isWindowClosed(win) {
                var allowMock = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                try {
                    if (win === window) return !1;
                } catch (err) {
                    return !0;
                }
                try {
                    if (!win) return !0;
                } catch (err) {
                    return !0;
                }
                try {
                    if (win.closed) return !0;
                } catch (err) {
                    return !err || err.message !== IE_WIN_ACCESS_ERROR;
                }
                if (allowMock && isSameDomain(win)) try {
                    if (win.mockclosed) return !0;
                } catch (err) {}
                try {
                    if (!win.parent || !win.top) return !0;
                } catch (err) {}
                try {
                    (0, _util.noop)(win == win);
                } catch (err) {
                    return !0;
                }
                var iframeIndex = function(collection, item) {
                    for (var i = 0; i < collection.length; i++) try {
                        if (collection[i] === item) return i;
                    } catch (err) {}
                    return -1;
                }(iframeWindows, win);
                if (-1 !== iframeIndex) {
                    var frame = iframeFrames[iframeIndex];
                    if (frame && isFrameWindowClosed(frame)) return !0;
                }
                return !1;
            }
            function getFrameByName(win, name) {
                var winFrames = getFrames(win), _iterator4 = winFrames, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i6 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i6++];
                    } else {
                        if ((_i6 = _iterator4.next()).done) break;
                        _ref4 = _i6.value;
                    }
                    var childFrame = _ref4;
                    try {
                        if (isSameDomain(childFrame) && childFrame.name === name && -1 !== winFrames.indexOf(childFrame)) return childFrame;
                    } catch (err) {}
                }
                try {
                    if (-1 !== winFrames.indexOf(win.frames[name])) return win.frames[name];
                } catch (err) {}
                try {
                    if (-1 !== winFrames.indexOf(win[name])) return win[name];
                } catch (err) {}
            }
            function findChildFrameByName(win, name) {
                var frame = getFrameByName(win, name);
                if (frame) return frame;
                var _iterator5 = getFrames(win), _isArray5 = Array.isArray(_iterator5), _i7 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i7 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i7++];
                    } else {
                        if ((_i7 = _iterator5.next()).done) break;
                        _ref5 = _i7.value;
                    }
                    var namedFrame = findChildFrameByName(_ref5, name);
                    if (namedFrame) return namedFrame;
                }
            }
            function getAncestor(win) {
                var opener = getOpener(win = win || window);
                if (opener) return opener;
                var parent = getParent(win);
                return parent || void 0;
            }
            function isPopup() {
                return Boolean(getOpener(window));
            }
            function isIframe() {
                return Boolean(getParent(window));
            }
            function anyMatch(collection1, collection2) {
                var _iterator8 = collection1, _isArray8 = Array.isArray(_iterator8), _i10 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i10 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i10++];
                    } else {
                        if ((_i10 = _iterator8.next()).done) break;
                        _ref8 = _i10.value;
                    }
                    var item1 = _ref8, _iterator9 = collection2, _isArray9 = Array.isArray(_iterator9), _i11 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i11 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i11++];
                        } else {
                            if ((_i11 = _iterator9.next()).done) break;
                            _ref9 = _i11.value;
                        }
                        if (item1 === _ref9) return !0;
                    }
                }
                return !1;
            }
            function getDistanceFromTop() {
                for (var distance = 0, parent = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window; parent; ) (parent = getParent(parent)) && (distance += 1);
                return distance;
            }
            function getNthParent(win) {
                for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, parent = win, i = 0; i < n; i++) {
                    if (!parent) return;
                    parent = getParent(parent);
                }
                return parent;
            }
        },
        "./node_modules/hi-base32/src/base32.js": function(module, exports, __webpack_require__) {
            "use strict";
            (function(process, global, module) {
                var __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                !function() {
                    var root = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) ? window : {};
                    !root.HI_BASE32_NO_NODE_JS && "object" === (void 0 === process ? "undefined" : _typeof(process)) && process.versions && process.versions.node && (root = global);
                    var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && "object" === _typeof(module) && module.exports, AMD = __webpack_require__("./node_modules/webpack/buildin/amd-options.js"), BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), BASE32_DECODE_CHAR = {
                        A: 0,
                        B: 1,
                        C: 2,
                        D: 3,
                        E: 4,
                        F: 5,
                        G: 6,
                        H: 7,
                        I: 8,
                        J: 9,
                        K: 10,
                        L: 11,
                        M: 12,
                        N: 13,
                        O: 14,
                        P: 15,
                        Q: 16,
                        R: 17,
                        S: 18,
                        T: 19,
                        U: 20,
                        V: 21,
                        W: 22,
                        X: 23,
                        Y: 24,
                        Z: 25,
                        2: 26,
                        3: 27,
                        4: 28,
                        5: 29,
                        6: 30,
                        7: 31
                    }, blocks = [ 0, 0, 0, 0, 0, 0, 0, 0 ], throwInvalidUtf8 = function(position, partial) {
                        partial.length > 10 && (partial = "..." + partial.substr(-10));
                        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
                        err.position = position;
                        throw err;
                    }, decodeAsBytes = function(base32Str) {
                        if (!/^[A-Z2-7=]+$/.test(base32Str)) throw new Error("Invalid base32 characters");
                        for (var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = (base32Str = base32Str.replace(/=/g, "")).length, i = 0, count = length >> 3 << 3; i < count; ) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                            bytes[index++] = 255 & (v5 << 7 | v6 << 2 | v7 >>> 3);
                            bytes[index++] = 255 & (v7 << 5 | v8);
                        }
                        var remain = length - count;
                        if (2 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                        } else if (4 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                        } else if (5 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                        } else if (7 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                            bytes[index++] = 255 & (v5 << 7 | v6 << 2 | v7 >>> 3);
                        }
                        return bytes;
                    }, decode = function(base32Str, asciiOnly) {
                        if (!asciiOnly) return function(bytes) {
                            for (var b, c, str = "", length = bytes.length, i = 0, followingChars = 0; i < length; ) if ((b = bytes[i++]) <= 127) str += String.fromCharCode(b); else {
                                if (b > 191 && b <= 223) {
                                    c = 31 & b;
                                    followingChars = 1;
                                } else if (b <= 239) {
                                    c = 15 & b;
                                    followingChars = 2;
                                } else if (b <= 247) {
                                    c = 7 & b;
                                    followingChars = 3;
                                } else throwInvalidUtf8(i, str);
                                for (var j = 0; j < followingChars; ++j) {
                                    ((b = bytes[i++]) < 128 || b > 191) && throwInvalidUtf8(i, str);
                                    c <<= 6;
                                    c += 63 & b;
                                }
                                c >= 55296 && c <= 57343 && throwInvalidUtf8(i, str);
                                c > 1114111 && throwInvalidUtf8(i, str);
                                if (c <= 65535) str += String.fromCharCode(c); else {
                                    c -= 65536;
                                    str += String.fromCharCode(55296 + (c >> 10));
                                    str += String.fromCharCode(56320 + (1023 & c));
                                }
                            }
                            return str;
                        }(decodeAsBytes(base32Str));
                        if (!/^[A-Z2-7=]+$/.test(base32Str)) throw new Error("Invalid base32 characters");
                        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
                        -1 === length && (length = base32Str.length);
                        for (var i = 0, count = length >> 3 << 3; i < count; ) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1)) + String.fromCharCode(255 & (v5 << 7 | v6 << 2 | v7 >>> 3)) + String.fromCharCode(255 & (v7 << 5 | v8));
                        }
                        var remain = length - count;
                        if (2 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2));
                        } else if (4 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4));
                        } else if (5 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1));
                        } else if (7 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1)) + String.fromCharCode(255 & (v5 << 7 | v6 << 2 | v7 >>> 3));
                        }
                        return str;
                    }, exports = {
                        encode: function(input, asciiOnly) {
                            var notString = "string" != typeof input;
                            notString && input.constructor === ArrayBuffer && (input = new Uint8Array(input));
                            return notString ? function(bytes) {
                                for (var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length, i = 0, count = 5 * parseInt(length / 5); i < count; ) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i++];
                                    v4 = bytes[i++];
                                    v5 = bytes[i++];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                }
                                var remain = length - count;
                                if (1 === remain) {
                                    v1 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
                                } else if (2 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                } else if (3 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                } else if (4 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i++];
                                    v4 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                }
                                return base32Str;
                            }(input) : asciiOnly ? function(str) {
                                for (var v1, v2, v3, v4, v5, base32Str = "", length = str.length, i = 0, count = 5 * parseInt(length / 5); i < count; ) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i++);
                                    v4 = str.charCodeAt(i++);
                                    v5 = str.charCodeAt(i++);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                }
                                var remain = length - count;
                                if (1 === remain) {
                                    v1 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
                                } else if (2 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                } else if (3 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                } else if (4 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i++);
                                    v4 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                }
                                return base32Str;
                            }(input) : function(str) {
                                var v1, v2, v3, v4, v5, code, i, end = !1, base32Str = "", index = 0, start = 0, length = str.length;
                                do {
                                    blocks[0] = blocks[5];
                                    blocks[1] = blocks[6];
                                    blocks[2] = blocks[7];
                                    for (i = start; index < length && i < 5; ++index) if ((code = str.charCodeAt(index)) < 128) blocks[i++] = code; else if (code < 2048) {
                                        blocks[i++] = 192 | code >> 6;
                                        blocks[i++] = 128 | 63 & code;
                                    } else if (code < 55296 || code >= 57344) {
                                        blocks[i++] = 224 | code >> 12;
                                        blocks[i++] = 128 | code >> 6 & 63;
                                        blocks[i++] = 128 | 63 & code;
                                    } else {
                                        code = 65536 + ((1023 & code) << 10 | 1023 & str.charCodeAt(++index));
                                        blocks[i++] = 240 | code >> 18;
                                        blocks[i++] = 128 | code >> 12 & 63;
                                        blocks[i++] = 128 | code >> 6 & 63;
                                        blocks[i++] = 128 | 63 & code;
                                    }
                                    start = i - 5;
                                    index === length && ++index;
                                    index > length && i < 6 && (end = !0);
                                    v1 = blocks[0];
                                    if (i > 4) {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        v4 = blocks[3];
                                        v5 = blocks[4];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                    } else if (1 === i) base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======"; else if (2 === i) {
                                        v2 = blocks[1];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                    } else if (3 === i) {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                    } else {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        v4 = blocks[3];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                    }
                                } while (!end);
                                return base32Str;
                            }(input);
                        },
                        decode: decode
                    };
                    decode.asBytes = decodeAsBytes;
                    if (COMMON_JS) module.exports = exports; else {
                        root.base32 = exports;
                        AMD && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return exports;
                        }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
                    }
                }();
            }).call(exports, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/webpack/buildin/module.js")(module));
        },
        "./node_modules/post-robot/src/bridge/bridge.js": function(module, exports, __webpack_require__) {
            "use strict";
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            _global.global.tunnelWindows = _global.global.tunnelWindows || {};
            _global.global.tunnelWindowId = 0;
            function deleteTunnelWindow(id) {
                try {
                    _global.global.tunnelWindows[id] && delete _global.global.tunnelWindows[id].source;
                } catch (err) {}
                delete _global.global.tunnelWindows[id];
            }
            function addTunnelWindow(_ref2) {
                var name = _ref2.name, source = _ref2.source, canary = _ref2.canary, sendMessage = _ref2.sendMessage;
                !function() {
                    var tunnelWindows = _global.global.tunnelWindows, _iterator = Object.keys(tunnelWindows), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref, tunnelWindow = tunnelWindows[key];
                        try {
                            (0, _lib.noop)(tunnelWindow.source);
                        } catch (err) {
                            deleteTunnelWindow(key);
                            continue;
                        }
                        (0, _src.isWindowClosed)(tunnelWindow.source) && deleteTunnelWindow(key);
                    }
                }();
                _global.global.tunnelWindowId += 1;
                _global.global.tunnelWindows[_global.global.tunnelWindowId] = {
                    name: name,
                    source: source,
                    canary: canary,
                    sendMessage: sendMessage
                };
                return _global.global.tunnelWindowId;
            }
            _global.global.openTunnelToParent = function(_ref3) {
                var name = _ref3.name, source = _ref3.source, canary = _ref3.canary, sendMessage = _ref3.sendMessage, parentWindow = (0, 
                _src.getParent)(window);
                if (!parentWindow) throw new Error("No parent window found to open tunnel to");
                var id = addTunnelWindow({
                    name: name,
                    source: source,
                    canary: canary,
                    sendMessage: sendMessage
                });
                return _global.global.send(parentWindow, _conf.CONSTANTS.POST_MESSAGE_NAMES.OPEN_TUNNEL, {
                    name: name,
                    sendMessage: function() {
                        var tunnelWindow = function(id) {
                            return _global.global.tunnelWindows[id];
                        }(id);
                        try {
                            (0, _lib.noop)(tunnelWindow && tunnelWindow.source);
                        } catch (err) {
                            deleteTunnelWindow(id);
                            return;
                        }
                        if (tunnelWindow && tunnelWindow.source && !(0, _src.isWindowClosed)(tunnelWindow.source)) {
                            try {
                                tunnelWindow.canary();
                            } catch (err) {
                                return;
                            }
                            tunnelWindow.sendMessage.apply(this, arguments);
                        }
                    }
                }, {
                    domain: _conf.CONSTANTS.WILDCARD
                });
            };
        },
        "./node_modules/post-robot/src/bridge/child.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.openTunnelToOpener = function() {
                return _src.ZalgoPromise.try(function() {
                    var opener = (0, _src2.getOpener)(window);
                    if (opener && (0, _common.needsBridge)({
                        win: opener
                    })) {
                        (0, _common.registerRemoteWindow)(opener);
                        return awaitRemoteBridgeForWindow(opener).then(function(bridge) {
                            return bridge ? window.name ? bridge[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT].openTunnelToParent({
                                name: window.name,
                                source: window,
                                canary: function() {},
                                sendMessage: function(message) {
                                    try {
                                        (0, _lib.noop)(window);
                                    } catch (err) {
                                        return;
                                    }
                                    if (window && !window.closed) try {
                                        _global.global.receiveMessage({
                                            data: message,
                                            origin: this.origin,
                                            source: this.source
                                        });
                                    } catch (err) {
                                        _src.ZalgoPromise.reject(err);
                                    }
                                }
                            }).then(function(_ref2) {
                                var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                                if (source !== opener) throw new Error("Source does not match opener");
                                (0, _common.registerRemoteSendMessage)(source, origin, data.sendMessage);
                            }).catch(function(err) {
                                (0, _common.rejectRemoteSendMessage)(opener, err);
                                throw err;
                            }) : (0, _common.rejectRemoteSendMessage)(opener, new Error("Can not register with opener: window does not have a name")) : (0, 
                            _common.rejectRemoteSendMessage)(opener, new Error("Can not register with opener: no bridge found in opener"));
                        });
                    }
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js"), awaitRemoteBridgeForWindow = (0, 
            _lib.weakMapMemoize)(function(win) {
                return _src.ZalgoPromise.try(function() {
                    var _iterator = (0, _src2.getFrames)(win), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var _frame = _ref;
                        try {
                            if (_frame && _frame !== window && (0, _src2.isSameDomain)(_frame) && _frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) return _frame;
                        } catch (err) {
                            continue;
                        }
                    }
                    try {
                        var frame = (0, _src2.getFrameByName)(win, (0, _common.getBridgeName)((0, _src2.getDomain)()));
                        if (!frame) return;
                        return (0, _src2.isSameDomain)(frame) && frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] ? frame : new _src.ZalgoPromise(function(resolve) {
                            var interval = void 0, timeout = void 0;
                            interval = setInterval(function() {
                                if (frame && (0, _src2.isSameDomain)(frame) && frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) {
                                    clearInterval(interval);
                                    clearTimeout(timeout);
                                    return resolve(frame);
                                }
                            }, 100);
                            timeout = setTimeout(function() {
                                clearInterval(interval);
                                return resolve();
                            }, 2e3);
                        });
                    } catch (err) {}
                });
            });
        },
        "./node_modules/post-robot/src/bridge/common.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.documentBodyReady = void 0;
            exports.needsBridgeForBrowser = needsBridgeForBrowser;
            exports.needsBridgeForWin = needsBridgeForWin;
            exports.needsBridgeForDomain = needsBridgeForDomain;
            exports.needsBridge = function(_ref) {
                var win = _ref.win, domain = _ref.domain;
                if (!needsBridgeForBrowser()) return !1;
                if (domain && !needsBridgeForDomain(domain, win)) return !1;
                if (win && !needsBridgeForWin(win)) return !1;
                return !0;
            };
            exports.getBridgeName = getBridgeName;
            exports.isBridge = function() {
                return Boolean(window.name && window.name === getBridgeName((0, _src3.getDomain)()));
            };
            exports.registerRemoteWindow = function(win) {
                _global.global.remoteWindows.set(win, {
                    sendMessagePromise: new _src2.ZalgoPromise()
                });
            };
            exports.findRemoteWindow = findRemoteWindow;
            exports.registerRemoteSendMessage = function(win, domain, sendMessage) {
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found to register sendMessage to");
                var sendMessageWrapper = function(remoteWin, message, remoteDomain) {
                    if (remoteWin !== win) throw new Error("Remote window does not match window");
                    if (!(0, _src3.matchDomain)(remoteDomain, domain)) throw new Error("Remote domain " + remoteDomain + " does not match domain " + domain);
                    sendMessage(message);
                };
                remoteWindow.sendMessagePromise.resolve(sendMessageWrapper);
                remoteWindow.sendMessagePromise = _src2.ZalgoPromise.resolve(sendMessageWrapper);
            };
            exports.rejectRemoteSendMessage = function(win, err) {
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found on which to reject sendMessage");
                remoteWindow.sendMessagePromise.asyncReject(err);
            };
            exports.sendBridgeMessage = function(win, message, domain) {
                var messagingChild = (0, _src3.isOpener)(window, win), messagingParent = (0, _src3.isOpener)(win, window);
                if (!messagingChild && !messagingParent) throw new Error("Can only send messages to and from parent and popup windows");
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found to send message to");
                return remoteWindow.sendMessagePromise.then(function(sendMessage) {
                    return sendMessage(win, message, domain);
                });
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            function needsBridgeForBrowser() {
                return !!(0, _src3.getUserAgent)(window).match(/MSIE|trident|edge\/12|edge\/13/i) || !_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP;
            }
            function needsBridgeForWin(win) {
                return !(0, _src3.isSameTopWindow)(window, win);
            }
            function needsBridgeForDomain(domain, win) {
                if (domain) {
                    if ((0, _src3.getDomain)() !== (0, _src3.getDomainFromUrl)(domain)) return !0;
                } else if (win && !(0, _src3.isSameDomain)(win)) return !0;
                return !1;
            }
            function getBridgeName(domain) {
                var sanitizedDomain = (domain = domain || (0, _src3.getDomainFromUrl)(domain)).replace(/[^a-zA-Z0-9]+/g, "_");
                return _conf.CONSTANTS.BRIDGE_NAME_PREFIX + "_" + sanitizedDomain;
            }
            exports.documentBodyReady = new _src2.ZalgoPromise(function(resolve) {
                if (window.document && window.document.body) return resolve(window.document.body);
                var interval = setInterval(function() {
                    if (window.document && window.document.body) {
                        clearInterval(interval);
                        return resolve(window.document.body);
                    }
                }, 10);
            });
            _global.global.remoteWindows = _global.global.remoteWindows || new _src.WeakMap();
            function findRemoteWindow(win) {
                return _global.global.remoteWindows.get(win);
            }
        },
        "./node_modules/post-robot/src/bridge/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _child = __webpack_require__("./node_modules/post-robot/src/bridge/child.js");
            Object.keys(_child).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _child[key];
                    }
                });
            });
            var _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js");
            Object.keys(_common).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _common[key];
                    }
                });
            });
            var _parent = __webpack_require__("./node_modules/post-robot/src/bridge/parent.js");
            Object.keys(_parent).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _parent[key];
                    }
                });
            });
            __webpack_require__("./node_modules/post-robot/src/bridge/bridge.js");
        },
        "./node_modules/post-robot/src/bridge/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _index = __webpack_require__("./node_modules/post-robot/src/bridge/index.js");
            Object.defineProperty(exports, "openBridge", {
                enumerable: !0,
                get: function() {
                    return _index.openBridge;
                }
            });
            Object.defineProperty(exports, "linkUrl", {
                enumerable: !0,
                get: function() {
                    return _index.linkUrl;
                }
            });
            Object.defineProperty(exports, "isBridge", {
                enumerable: !0,
                get: function() {
                    return _index.isBridge;
                }
            });
            Object.defineProperty(exports, "needsBridge", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridge;
                }
            });
            Object.defineProperty(exports, "needsBridgeForBrowser", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForBrowser;
                }
            });
            Object.defineProperty(exports, "hasBridge", {
                enumerable: !0,
                get: function() {
                    return _index.hasBridge;
                }
            });
            Object.defineProperty(exports, "needsBridgeForWin", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForWin;
                }
            });
            Object.defineProperty(exports, "needsBridgeForDomain", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForDomain;
                }
            });
            Object.defineProperty(exports, "openTunnelToOpener", {
                enumerable: !0,
                get: function() {
                    return _index.openTunnelToOpener;
                }
            });
            Object.defineProperty(exports, "destroyBridges", {
                enumerable: !0,
                get: function() {
                    return _index.destroyBridges;
                }
            });
        },
        "./node_modules/post-robot/src/bridge/parent.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.hasBridge = function(url, domain) {
                domain = domain || (0, _src3.getDomainFromUrl)(url);
                return Boolean(_global.global.bridges[domain]);
            };
            exports.openBridge = function(url, domain) {
                domain = domain || (0, _src3.getDomainFromUrl)(url);
                if (_global.global.bridges[domain]) return _global.global.bridges[domain];
                _global.global.bridges[domain] = _src2.ZalgoPromise.try(function() {
                    if ((0, _src3.getDomain)() === domain) throw new Error("Can not open bridge on the same domain as current domain: " + domain);
                    var name = (0, _common.getBridgeName)(domain), frame = (0, _src3.getFrameByName)(window, name);
                    if (frame) throw new Error("Frame with name " + name + " already exists on page");
                    var iframe = function(name, url) {
                        _lib.log.debug("Opening bridge:", name, url);
                        var iframe = document.createElement("iframe");
                        iframe.setAttribute("name", name);
                        iframe.setAttribute("id", name);
                        iframe.setAttribute("style", "display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;");
                        iframe.setAttribute("frameborder", "0");
                        iframe.setAttribute("border", "0");
                        iframe.setAttribute("scrolling", "no");
                        iframe.setAttribute("allowTransparency", "true");
                        iframe.setAttribute("tabindex", "-1");
                        iframe.setAttribute("hidden", "true");
                        iframe.setAttribute("title", "");
                        iframe.setAttribute("role", "presentation");
                        iframe.src = url;
                        return iframe;
                    }(name, url);
                    _global.global.bridgeFrames[domain] = iframe;
                    return _common.documentBodyReady.then(function(body) {
                        body.appendChild(iframe);
                        var bridge = iframe.contentWindow;
                        !function(source, domain) {
                            _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.OPEN_TUNNEL, {
                                window: source,
                                domain: domain
                            }, function(_ref) {
                                var origin = _ref.origin, data = _ref.data;
                                if (origin !== domain) throw new Error("Domain " + domain + " does not match origin " + origin);
                                if (!data.name) throw new Error("Register window expected to be passed window name");
                                if (!data.sendMessage) throw new Error("Register window expected to be passed sendMessage method");
                                if (!_global.global.popupWindowsByName[data.name]) throw new Error("Window with name " + data.name + " does not exist, or was not opened by this window");
                                if (!_global.global.popupWindowsByName[data.name].domain) throw new Error("We do not have a registered domain for window " + data.name);
                                if (_global.global.popupWindowsByName[data.name].domain !== origin) throw new Error("Message origin " + origin + " does not matched registered window origin " + _global.global.popupWindowsByName[data.name].domain);
                                (0, _common.registerRemoteSendMessage)(_global.global.popupWindowsByName[data.name].win, domain, data.sendMessage);
                                return {
                                    sendMessage: function(message) {
                                        if (window && !window.closed) {
                                            var winDetails = _global.global.popupWindowsByName[data.name];
                                            if (winDetails) try {
                                                _global.global.receiveMessage({
                                                    data: message,
                                                    origin: winDetails.domain,
                                                    source: winDetails.win
                                                });
                                            } catch (err) {
                                                _src2.ZalgoPromise.reject(err);
                                            }
                                        }
                                    }
                                };
                            });
                        }(bridge, domain);
                        return new _src2.ZalgoPromise(function(resolve, reject) {
                            iframe.onload = resolve;
                            iframe.onerror = reject;
                        }).then(function() {
                            return (0, _lib.onChildWindowReady)(bridge, _conf.CONFIG.BRIDGE_TIMEOUT, "Bridge " + url);
                        }).then(function() {
                            return bridge;
                        });
                    });
                });
                return _global.global.bridges[domain];
            };
            exports.linkUrl = function(win, url) {
                var winOptions = _global.global.popupWindowsByWin.get(win);
                if (winOptions) {
                    winOptions.domain = (0, _src3.getDomainFromUrl)(url);
                    (0, _common.registerRemoteWindow)(win);
                }
            };
            exports.destroyBridges = function() {
                for (var _iterator2 = Object.keys(_global.global.bridgeFrames), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref3 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref3 = _i2.value;
                    }
                    var domain = _ref3, frame = _global.global.bridgeFrames[domain];
                    frame.parentNode && frame.parentNode.removeChild(frame);
                }
                _global.global.bridgeFrames = {};
                _global.global.bridges = {};
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js");
            _global.global.bridges = _global.global.bridges || {};
            _global.global.bridgeFrames = _global.global.bridgeFrames || {};
            _global.global.popupWindowsByWin = _global.global.popupWindowsByWin || new _src.WeakMap();
            _global.global.popupWindowsByName = _global.global.popupWindowsByName || {};
            var windowOpen = window.open;
            window.open = function(url, name, options, last) {
                var domain = url;
                if (url && 0 === url.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL)) {
                    var _url$split = url.split("|");
                    domain = _url$split[0];
                    url = _url$split[1];
                }
                domain && (domain = (0, _src3.getDomainFromUrl)(domain));
                var win = windowOpen.call(this, url, name, options, last);
                if (!win) return win;
                url && (0, _common.registerRemoteWindow)(win);
                var _iterator = Object.keys(_global.global.popupWindowsByName), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref2 = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref2 = _i.value;
                    }
                    var winName = _ref2;
                    (0, _src3.isWindowClosed)(_global.global.popupWindowsByName[winName].win) && delete _global.global.popupWindowsByName[winName];
                }
                if (name && win) {
                    var winOptions = _global.global.popupWindowsByWin.get(win) || _global.global.popupWindowsByName[name] || {};
                    winOptions.name = winOptions.name || name;
                    winOptions.win = winOptions.win || win;
                    winOptions.domain = winOptions.domain || domain;
                    _global.global.popupWindowsByWin.set(win, winOptions);
                    _global.global.popupWindowsByName[name] = winOptions;
                }
                return win;
            };
        },
        "./node_modules/post-robot/src/clean.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.cleanUpWindow = function(win) {
                var requestPromises = _global.global.requestPromises.get(win);
                if (requestPromises) for (var _iterator = requestPromises, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var promise = _ref;
                    promise.reject(new Error("No response from window - cleaned up"));
                }
                _global.global.popupWindowsByWin && _global.global.popupWindowsByWin.delete(win);
                _global.global.remoteWindows && _global.global.remoteWindows.delete(win);
                _global.global.requestPromises.delete(win);
                _global.global.methods.delete(win);
                _global.global.readyPromises.delete(win);
            };
            __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            var _global = __webpack_require__("./node_modules/post-robot/src/global.js");
        },
        "./node_modules/post-robot/src/compat/ie.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.emulateIERestrictions = function(sourceWindow, targetWindow) {
                if (!_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP && !1 === (0, _src.isSameTopWindow)(sourceWindow, targetWindow)) throw new Error("Can not send and receive post messages between two different windows (disabled to emulate IE)");
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
        },
        "./node_modules/post-robot/src/compat/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _ie = __webpack_require__("./node_modules/post-robot/src/compat/ie.js");
            Object.keys(_ie).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ie[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/conf/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONFIG = void 0;
            var _ALLOWED_POST_MESSAGE, _constants = __webpack_require__("./node_modules/post-robot/src/conf/constants.js"), CONFIG = exports.CONFIG = {
                ALLOW_POSTMESSAGE_POPUP: !("__ALLOW_POSTMESSAGE_POPUP__" in window) || window.__ALLOW_POSTMESSAGE_POPUP__,
                LOG_LEVEL: "info",
                BRIDGE_TIMEOUT: 5e3,
                CHILD_WINDOW_TIMEOUT: 5e3,
                ACK_TIMEOUT: -1 !== window.navigator.userAgent.match(/MSIE/i) ? 2e3 : 1e3,
                RES_TIMEOUT: -1,
                LOG_TO_PAGE: !1,
                ALLOWED_POST_MESSAGE_METHODS: (_ALLOWED_POST_MESSAGE = {}, _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = !0, 
                _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.BRIDGE] = !0, _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.GLOBAL] = !0, 
                _ALLOWED_POST_MESSAGE),
                ALLOW_SAME_ORIGIN: !1
            };
            0 === window.location.href.indexOf(_constants.CONSTANTS.FILE_PROTOCOL) && (CONFIG.ALLOW_POSTMESSAGE_POPUP = !0);
        },
        "./node_modules/post-robot/src/conf/constants.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = {
                POST_MESSAGE_TYPE: {
                    REQUEST: "postrobot_message_request",
                    RESPONSE: "postrobot_message_response",
                    ACK: "postrobot_message_ack"
                },
                POST_MESSAGE_ACK: {
                    SUCCESS: "success",
                    ERROR: "error"
                },
                POST_MESSAGE_NAMES: {
                    METHOD: "postrobot_method",
                    HELLO: "postrobot_ready",
                    OPEN_TUNNEL: "postrobot_open_tunnel"
                },
                WINDOW_TYPES: {
                    FULLPAGE: "fullpage",
                    POPUP: "popup",
                    IFRAME: "iframe"
                },
                WINDOW_PROPS: {
                    POSTROBOT: "__postRobot__"
                },
                SERIALIZATION_TYPES: {
                    METHOD: "postrobot_method",
                    ERROR: "postrobot_error",
                    PROMISE: "postrobot_promise",
                    ZALGO_PROMISE: "postrobot_zalgo_promise",
                    REGEX: "regex"
                },
                SEND_STRATEGIES: {
                    POST_MESSAGE: "postrobot_post_message",
                    BRIDGE: "postrobot_bridge",
                    GLOBAL: "postrobot_global"
                },
                MOCK_PROTOCOL: "mock:",
                FILE_PROTOCOL: "file:",
                BRIDGE_NAME_PREFIX: "__postrobot_bridge__",
                POSTROBOT_PROXY: "__postrobot_proxy__",
                WILDCARD: "*"
            };
            var POST_MESSAGE_NAMES = exports.POST_MESSAGE_NAMES = {
                METHOD: "postrobot_method",
                HELLO: "postrobot_hello",
                OPEN_TUNNEL: "postrobot_open_tunnel"
            };
            exports.POST_MESSAGE_NAMES_LIST = Object.keys(POST_MESSAGE_NAMES).map(function(key) {
                return POST_MESSAGE_NAMES[key];
            });
        },
        "./node_modules/post-robot/src/conf/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _config = __webpack_require__("./node_modules/post-robot/src/conf/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
            var _constants = __webpack_require__("./node_modules/post-robot/src/conf/constants.js");
            Object.keys(_constants).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _constants[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/drivers/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _receive = __webpack_require__("./node_modules/post-robot/src/drivers/receive/index.js");
            Object.keys(_receive).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _receive[key];
                    }
                });
            });
            var _send = __webpack_require__("./node_modules/post-robot/src/drivers/send/index.js");
            Object.keys(_send).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _send[key];
                    }
                });
            });
            var _listeners = __webpack_require__("./node_modules/post-robot/src/drivers/listeners.js");
            Object.keys(_listeners).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _listeners[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/drivers/listeners.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.resetListeners = function() {
                _global.global.responseListeners = {};
                _global.global.requestListeners = {};
            };
            exports.addResponseListener = function(hash, listener) {
                _global.global.responseListeners[hash] = listener;
            };
            exports.getResponseListener = function(hash) {
                return _global.global.responseListeners[hash];
            };
            exports.deleteResponseListener = function(hash) {
                delete _global.global.responseListeners[hash];
            };
            exports.markResponseListenerErrored = function(hash) {
                _global.global.erroredResponseListeners[hash] = !0;
            };
            exports.isResponseListenerErrored = function(hash) {
                return Boolean(_global.global.erroredResponseListeners[hash]);
            };
            exports.getRequestListener = getRequestListener;
            exports.addRequestListener = function addRequestListener(_ref5, listener) {
                var name = _ref5.name, win = _ref5.win, domain = _ref5.domain;
                if (!name || "string" != typeof name) throw new Error("Name required to add request listener");
                if (Array.isArray(win)) {
                    for (var listenersCollection = [], _iterator2 = win, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray2) {
                            if (_i3 >= _iterator2.length) break;
                            _ref6 = _iterator2[_i3++];
                        } else {
                            if ((_i3 = _iterator2.next()).done) break;
                            _ref6 = _i3.value;
                        }
                        var item = _ref6;
                        listenersCollection.push(addRequestListener({
                            name: name,
                            domain: domain,
                            win: item
                        }, listener));
                    }
                    return {
                        cancel: function() {
                            for (var _iterator3 = listenersCollection, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref7;
                                if (_isArray3) {
                                    if (_i4 >= _iterator3.length) break;
                                    _ref7 = _iterator3[_i4++];
                                } else {
                                    if ((_i4 = _iterator3.next()).done) break;
                                    _ref7 = _i4.value;
                                }
                                var cancelListener = _ref7;
                                cancelListener.cancel();
                            }
                        }
                    };
                }
                if (Array.isArray(domain)) {
                    for (var _listenersCollection = [], _iterator4 = domain, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray4) {
                            if (_i5 >= _iterator4.length) break;
                            _ref8 = _iterator4[_i5++];
                        } else {
                            if ((_i5 = _iterator4.next()).done) break;
                            _ref8 = _i5.value;
                        }
                        var _item = _ref8;
                        _listenersCollection.push(addRequestListener({
                            name: name,
                            win: win,
                            domain: _item
                        }, listener));
                    }
                    return {
                        cancel: function() {
                            for (var _iterator5 = _listenersCollection, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray5) {
                                    if (_i6 >= _iterator5.length) break;
                                    _ref9 = _iterator5[_i6++];
                                } else {
                                    if ((_i6 = _iterator5.next()).done) break;
                                    _ref9 = _i6.value;
                                }
                                var cancelListener = _ref9;
                                cancelListener.cancel();
                            }
                        }
                    };
                }
                var existingListener = getRequestListener({
                    name: name,
                    win: win,
                    domain: domain
                });
                win && win !== _conf.CONSTANTS.WILDCARD || (win = _global.global.WINDOW_WILDCARD);
                domain = domain || _conf.CONSTANTS.WILDCARD;
                if (existingListener) throw win && domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString() + " for " + (win === _global.global.WINDOW_WILDCARD ? "wildcard" : "specified") + " window") : win ? new Error("Request listener already exists for " + name + " for " + (win === _global.global.WINDOW_WILDCARD ? "wildcard" : "specified") + " window") : domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString()) : new Error("Request listener already exists for " + name);
                var requestListeners = _global.global.requestListeners;
                var nameListeners = requestListeners[name];
                if (!nameListeners) {
                    nameListeners = new _src.WeakMap();
                    requestListeners[name] = nameListeners;
                }
                var winListeners = nameListeners.get(win);
                if (!winListeners) {
                    winListeners = {};
                    nameListeners.set(win, winListeners);
                }
                var strDomain = domain.toString();
                var regexListeners = winListeners[__DOMAIN_REGEX__];
                var regexListener = void 0;
                if ((0, _lib.isRegex)(domain)) {
                    if (!regexListeners) {
                        regexListeners = [];
                        winListeners[__DOMAIN_REGEX__] = regexListeners;
                    }
                    regexListener = {
                        regex: domain,
                        listener: listener
                    };
                    regexListeners.push(regexListener);
                } else winListeners[strDomain] = listener;
                return {
                    cancel: function() {
                        if (winListeners) {
                            delete winListeners[strDomain];
                            win && 0 === Object.keys(winListeners).length && nameListeners.delete(win);
                            regexListener && regexListeners.splice(regexListeners.indexOf(regexListener, 1));
                        }
                    }
                };
            };
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            _global.global.responseListeners = _global.global.responseListeners || {};
            _global.global.requestListeners = _global.global.requestListeners || {};
            _global.global.WINDOW_WILDCARD = _global.global.WINDOW_WILDCARD || new function() {}();
            _global.global.erroredResponseListeners = _global.global.erroredResponseListeners || {};
            var __DOMAIN_REGEX__ = "__domain_regex__";
            function getRequestListener(_ref) {
                var name = _ref.name, win = _ref.win, domain = _ref.domain;
                win === _conf.CONSTANTS.WILDCARD && (win = null);
                domain === _conf.CONSTANTS.WILDCARD && (domain = null);
                if (!name) throw new Error("Name required to get request listener");
                var nameListeners = _global.global.requestListeners[name];
                if (nameListeners) for (var _arr = [ win, _global.global.WINDOW_WILDCARD ], _i = 0; _i < _arr.length; _i++) {
                    var winQualifier = _arr[_i], winListeners = winQualifier && nameListeners.get(winQualifier);
                    if (winListeners) {
                        if (domain && "string" == typeof domain) {
                            if (winListeners[domain]) return winListeners[domain];
                            if (winListeners[__DOMAIN_REGEX__]) {
                                var _iterator = winListeners[__DOMAIN_REGEX__], _isArray = Array.isArray(_iterator), _i2 = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref3;
                                    if (_isArray) {
                                        if (_i2 >= _iterator.length) break;
                                        _ref3 = _iterator[_i2++];
                                    } else {
                                        if ((_i2 = _iterator.next()).done) break;
                                        _ref3 = _i2.value;
                                    }
                                    var _ref4 = _ref3, regex = _ref4.regex, listener = _ref4.listener;
                                    if ((0, _src2.matchDomain)(regex, domain)) return listener;
                                }
                            }
                        }
                        if (winListeners[_conf.CONSTANTS.WILDCARD]) return winListeners[_conf.CONSTANTS.WILDCARD];
                    }
                }
            }
        },
        "./node_modules/post-robot/src/drivers/receive/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.receiveMessage = receiveMessage;
            exports.messageListener = messageListener;
            exports.listenForMessages = function() {
                (0, _lib.addEventListener)(window, "message", messageListener);
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _types = __webpack_require__("./node_modules/post-robot/src/drivers/receive/types.js");
            _global.global.receivedMessages = _global.global.receivedMessages || [];
            function receiveMessage(event) {
                if (!window || window.closed) throw new Error("Message recieved in closed window");
                try {
                    if (!event.source) return;
                } catch (err) {
                    return;
                }
                var source = event.source, origin = event.origin, message = function(message) {
                    var parsedMessage = void 0;
                    try {
                        parsedMessage = (0, _lib.jsonParse)(message);
                    } catch (err) {
                        return;
                    }
                    if (parsedMessage && "object" === (void 0 === parsedMessage ? "undefined" : _typeof(parsedMessage)) && null !== parsedMessage && (parsedMessage = parsedMessage[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) && "object" === (void 0 === parsedMessage ? "undefined" : _typeof(parsedMessage)) && null !== parsedMessage && parsedMessage.type && "string" == typeof parsedMessage.type && _types.RECEIVE_MESSAGE_TYPES[parsedMessage.type]) return parsedMessage;
                }(event.data);
                if (message) {
                    if (!message.sourceDomain || "string" != typeof message.sourceDomain) throw new Error("Expected message to have sourceDomain");
                    0 !== message.sourceDomain.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL) && 0 !== message.sourceDomain.indexOf(_conf.CONSTANTS.FILE_PROTOCOL) || (origin = message.sourceDomain);
                    if (-1 === _global.global.receivedMessages.indexOf(message.id)) {
                        _global.global.receivedMessages.push(message.id);
                        var level = void 0;
                        level = -1 !== _conf.POST_MESSAGE_NAMES_LIST.indexOf(message.name) || message.type === _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK ? "debug" : "error" === message.ack ? "error" : "info";
                        _lib.log.logLevel(level, [ "\n\n\t", "#receive", message.type.replace(/^postrobot_message_/, ""), "::", message.name, "::", origin, "\n\n", message ]);
                        if (!(0, _src.isWindowClosed)(source) || message.fireAndForget) {
                            message.data && (message.data = (0, _lib.deserializeMethods)(source, origin, message.data));
                            _types.RECEIVE_MESSAGE_TYPES[message.type](source, origin, message);
                        } else _lib.log.debug("Source window is closed - can not send " + message.type + " " + message.name);
                    }
                }
            }
            function messageListener(event) {
                try {
                    (0, _lib.noop)(event.source);
                } catch (err) {
                    return;
                }
                var messageEvent = {
                    source: event.source || event.sourceElement,
                    origin: event.origin || event.originalEvent && event.originalEvent.origin,
                    data: event.data
                };
                try {
                    __webpack_require__("./node_modules/post-robot/src/compat/index.js").emulateIERestrictions(messageEvent.source, window);
                } catch (err) {
                    return;
                }
                receiveMessage(messageEvent);
            }
            _global.global.receiveMessage = receiveMessage;
        },
        "./node_modules/post-robot/src/drivers/receive/types.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.RECEIVE_MESSAGE_TYPES = void 0;
            var _RECEIVE_MESSAGE_TYPE, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _send = __webpack_require__("./node_modules/post-robot/src/drivers/send/index.js"), _listeners = __webpack_require__("./node_modules/post-robot/src/drivers/listeners.js");
            exports.RECEIVE_MESSAGE_TYPES = ((_RECEIVE_MESSAGE_TYPE = {})[_conf.CONSTANTS.POST_MESSAGE_TYPE.ACK] = function(source, origin, message) {
                if (!(0, _listeners.isResponseListenerErrored)(message.hash)) {
                    var options = (0, _listeners.getResponseListener)(message.hash);
                    if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
                    options.ack = !0;
                }
            }, _RECEIVE_MESSAGE_TYPE[_conf.CONSTANTS.POST_MESSAGE_TYPE.REQUEST] = function(source, origin, message) {
                var options = (0, _listeners.getRequestListener)({
                    name: message.name,
                    win: source,
                    domain: origin
                });
                function respond(data) {
                    return message.fireAndForget || (0, _src2.isWindowClosed)(source) ? _src.ZalgoPromise.resolve() : (0, 
                    _send.sendMessage)(source, _extends({
                        target: message.originalSource,
                        hash: message.hash,
                        name: message.name
                    }, data), origin);
                }
                return _src.ZalgoPromise.all([ respond({
                    type: _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK
                }), _src.ZalgoPromise.try(function() {
                    if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Request origin " + origin + " does not match domain " + options.domain.toString());
                    var data = message.data;
                    return options.handler({
                        source: source,
                        origin: origin,
                        data: data
                    });
                }).then(function(data) {
                    return respond({
                        type: _conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,
                        ack: _conf.CONSTANTS.POST_MESSAGE_ACK.SUCCESS,
                        data: data
                    });
                }, function(err) {
                    var error = (0, _lib.stringifyError)(err).replace(/^Error: /, ""), code = err.code;
                    return respond({
                        type: _conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,
                        ack: _conf.CONSTANTS.POST_MESSAGE_ACK.ERROR,
                        error: error,
                        code: code
                    });
                }) ]).then(_lib.noop).catch(function(err) {
                    if (options && options.handleError) return options.handleError(err);
                    _lib.log.error((0, _lib.stringifyError)(err));
                });
            }, _RECEIVE_MESSAGE_TYPE[_conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE] = function(source, origin, message) {
                if (!(0, _listeners.isResponseListenerErrored)(message.hash)) {
                    var options = (0, _listeners.getResponseListener)(message.hash);
                    if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + (0, 
                    _src2.stringifyDomainPattern)(options.domain));
                    (0, _listeners.deleteResponseListener)(message.hash);
                    if (message.ack === _conf.CONSTANTS.POST_MESSAGE_ACK.ERROR) {
                        var err = new Error(message.error);
                        message.code && (err.code = message.code);
                        return options.respond(err, null);
                    }
                    if (message.ack === _conf.CONSTANTS.POST_MESSAGE_ACK.SUCCESS) {
                        var data = message.data || message.response;
                        return options.respond(null, {
                            source: source,
                            origin: origin,
                            data: data
                        });
                    }
                }
            }, _RECEIVE_MESSAGE_TYPE);
        },
        "./node_modules/post-robot/src/drivers/send/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            };
            exports.sendMessage = function(win, message, domain) {
                return _src2.ZalgoPromise.try(function() {
                    var _jsonStringify;
                    message = function(win, message) {
                        var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, id = (0, 
                        _lib.uniqueID)(), type = (0, _lib.getWindowType)(), sourceDomain = (0, _src.getDomain)(window);
                        return _extends({}, message, options, {
                            sourceDomain: sourceDomain,
                            id: message.id || id,
                            windowType: type
                        });
                    }(win, message, {
                        data: (0, _lib.serializeMethods)(win, domain, message.data),
                        domain: domain
                    });
                    var level = void 0;
                    level = -1 !== _conf.POST_MESSAGE_NAMES_LIST.indexOf(message.name) || message.type === _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK ? "debug" : "error" === message.ack ? "error" : "info";
                    _lib.log.logLevel(level, [ "\n\n\t", "#send", message.type.replace(/^postrobot_message_/, ""), "::", message.name, "::", domain || _conf.CONSTANTS.WILDCARD, "\n\n", message ]);
                    if (win === window && !_conf.CONFIG.ALLOW_SAME_ORIGIN) throw new Error("Attemping to send message to self");
                    if ((0, _src.isWindowClosed)(win)) throw new Error("Window is closed");
                    _lib.log.debug("Running send message strategies", message);
                    var messages = [], serializedMessage = (0, _lib.jsonStringify)(((_jsonStringify = {})[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] = message, 
                    _jsonStringify), null, 2);
                    return _src2.ZalgoPromise.map(Object.keys(_strategies.SEND_MESSAGE_STRATEGIES), function(strategyName) {
                        return _src2.ZalgoPromise.try(function() {
                            if (!_conf.CONFIG.ALLOWED_POST_MESSAGE_METHODS[strategyName]) throw new Error("Strategy disallowed: " + strategyName);
                            return _strategies.SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
                        }).then(function() {
                            messages.push(strategyName + ": success");
                            return !0;
                        }, function(err) {
                            messages.push(strategyName + ": " + (0, _lib.stringifyError)(err) + "\n");
                            return !1;
                        });
                    }).then(function(results) {
                        var success = results.some(Boolean), status = message.type + " " + message.name + " " + (success ? "success" : "error") + ":\n  - " + messages.join("\n  - ") + "\n";
                        _lib.log.debug(status);
                        if (!success) throw new Error(status);
                    });
                });
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _strategies = __webpack_require__("./node_modules/post-robot/src/drivers/send/strategies.js");
        },
        "./node_modules/post-robot/src/drivers/send/strategies.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.SEND_MESSAGE_STRATEGIES = void 0;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), SEND_MESSAGE_STRATEGIES = exports.SEND_MESSAGE_STRATEGIES = {};
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = function(win, serializedMessage, domain) {
                try {
                    __webpack_require__("./node_modules/post-robot/src/compat/index.js").emulateIERestrictions(window, win);
                } catch (err) {
                    return;
                }
                (Array.isArray(domain) ? domain : "string" == typeof domain ? [ domain ] : [ _conf.CONSTANTS.WILDCARD ]).map(function(dom) {
                    if (0 === dom.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL)) {
                        if (window.location.protocol === _conf.CONSTANTS.FILE_PROTOCOL) return _conf.CONSTANTS.WILDCARD;
                        if (!(0, _src.isActuallySameDomain)(win)) throw new Error("Attempting to send messsage to mock domain " + dom + ", but window is actually cross-domain");
                        return (0, _src.getActualDomain)(win);
                    }
                    return 0 === dom.indexOf(_conf.CONSTANTS.FILE_PROTOCOL) ? _conf.CONSTANTS.WILDCARD : dom;
                }).forEach(function(dom) {
                    return win.postMessage(serializedMessage, dom);
                });
            };
            var _require = __webpack_require__("./node_modules/post-robot/src/bridge/index.js"), sendBridgeMessage = _require.sendBridgeMessage, needsBridgeForBrowser = _require.needsBridgeForBrowser, isBridge = _require.isBridge;
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.BRIDGE] = function(win, serializedMessage, domain) {
                if (needsBridgeForBrowser() || isBridge()) {
                    if ((0, _src.isSameDomain)(win)) throw new Error("Post message through bridge disabled between same domain windows");
                    if (!1 !== (0, _src.isSameTopWindow)(window, win)) throw new Error("Can only use bridge to communicate between two different windows, not between frames");
                    return sendBridgeMessage(win, serializedMessage, domain);
                }
            };
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.GLOBAL] = function(win, serializedMessage) {
                if ((0, _lib.needsGlobalMessagingForBrowser)()) {
                    if (!(0, _src.isSameDomain)(win)) throw new Error("Post message through global disabled between different domain windows");
                    if (!1 !== (0, _src.isSameTopWindow)(window, win)) throw new Error("Can only use global to communicate between two different windows, not between frames");
                    var foreignGlobal = win[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT];
                    if (!foreignGlobal) throw new Error("Can not find postRobot global on foreign window");
                    return foreignGlobal.receiveMessage({
                        source: window,
                        origin: (0, _src.getDomain)(),
                        data: serializedMessage
                    });
                }
            };
        },
        "./node_modules/post-robot/src/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.global = void 0;
            var _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            (exports.global = window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] = window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] || {}).registerSelf = function() {};
        },
        "./node_modules/post-robot/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/post-robot/src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/post-robot/src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.bridge = exports.Promise = exports.cleanUpWindow = void 0;
            var _public = __webpack_require__("./node_modules/post-robot/src/public/index.js");
            Object.keys(_public).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _public[key];
                    }
                });
            });
            var _clean = __webpack_require__("./node_modules/post-robot/src/clean.js");
            Object.defineProperty(exports, "cleanUpWindow", {
                enumerable: !0,
                get: function() {
                    return _clean.cleanUpWindow;
                }
            });
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            Object.defineProperty(exports, "Promise", {
                enumerable: !0,
                get: function() {
                    return _src.ZalgoPromise;
                }
            });
            exports.init = init;
            var _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            exports.bridge = __webpack_require__("./node_modules/post-robot/src/bridge/interface.js");
            function init() {
                if (!_global.global.initialized) {
                    (0, _drivers.listenForMessages)();
                    __webpack_require__("./node_modules/post-robot/src/bridge/index.js").openTunnelToOpener();
                    (0, _lib.initOnReady)();
                    (0, _lib.listenForMethods)({
                        on: _public.on,
                        send: _public.send
                    });
                }
                _global.global.initialized = !0;
            }
            init();
        },
        "./node_modules/post-robot/src/lib/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js");
            Object.keys(_util).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _util[key];
                    }
                });
            });
            var _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js");
            Object.keys(_log).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _log[key];
                    }
                });
            });
            var _serialize = __webpack_require__("./node_modules/post-robot/src/lib/serialize.js");
            Object.keys(_serialize).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _serialize[key];
                    }
                });
            });
            var _ready = __webpack_require__("./node_modules/post-robot/src/lib/ready.js");
            Object.keys(_ready).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ready[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/lib/log.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.log = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js"), LOG_LEVELS = [ "debug", "info", "warn", "error" ];
            Function.prototype.bind && window.console && "object" === _typeof(console.log) && [ "log", "info", "warn", "error" ].forEach(function(method) {
                console[method] = this.bind(console[method], console);
            }, Function.prototype.call);
            var log = exports.log = {
                clearLogs: function() {
                    window.console && window.console.clear && window.console.clear();
                    if (_conf.CONFIG.LOG_TO_PAGE) {
                        var container = document.getElementById("postRobotLogs");
                        container && container.parentNode && container.parentNode.removeChild(container);
                    }
                },
                writeToPage: function(level, args) {
                    setTimeout(function() {
                        var container = document.getElementById("postRobotLogs");
                        if (!container) {
                            (container = document.createElement("div")).id = "postRobotLogs";
                            container.style.cssText = "width: 800px; font-family: monospace; white-space: pre-wrap;";
                            document.body && document.body.appendChild(container);
                        }
                        var el = document.createElement("div"), date = new Date().toString().split(" ")[4], payload = Array.prototype.slice.call(args).map(function(item) {
                            if ("string" == typeof item) return item;
                            if (!item) return Object.prototype.toString.call(item);
                            var json = void 0;
                            try {
                                json = (0, _util.jsonStringify)(item, null, 2);
                            } catch (err) {
                                json = "[object]";
                            }
                            return "\n\n" + json + "\n\n";
                        }).join(" "), msg = date + " " + level + " " + payload;
                        el.innerHTML = msg;
                        var color = {
                            log: "#ddd",
                            warn: "orange",
                            error: "red",
                            info: "blue",
                            debug: "#aaa"
                        }[level];
                        el.style.cssText = "margin-top: 10px; color: " + color + ";";
                        container.childNodes.length ? container.insertBefore(el, container.childNodes[0]) : container.appendChild(el);
                    });
                },
                logLevel: function(level, args) {
                    setTimeout(function() {
                        try {
                            var logLevel = window.LOG_LEVEL || _conf.CONFIG.LOG_LEVEL;
                            if ("disabled" === logLevel || LOG_LEVELS.indexOf(level) < LOG_LEVELS.indexOf(logLevel)) return;
                            (args = Array.prototype.slice.call(args)).unshift("" + window.location.host + window.location.pathname);
                            args.unshift("::");
                            args.unshift("" + (0, _util.getWindowType)().toLowerCase());
                            args.unshift("[post-robot]");
                            _conf.CONFIG.LOG_TO_PAGE && log.writeToPage(level, args);
                            if (!window.console) return;
                            window.console[level] || (level = "log");
                            if (!window.console[level]) return;
                            window.console[level].apply(window.console, args);
                        } catch (err) {}
                    }, 1);
                },
                debug: function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    log.logLevel("debug", args);
                },
                info: function() {
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    log.logLevel("info", args);
                },
                warn: function() {
                    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    log.logLevel("warn", args);
                },
                error: function() {
                    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                    log.logLevel("error", args);
                }
            };
        },
        "./node_modules/post-robot/src/lib/ready.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.onHello = onHello;
            exports.sayHello = sayHello;
            exports.initOnReady = function() {
                onHello(function(_ref3) {
                    var source = _ref3.source, origin = _ref3.origin, promise = _global.global.readyPromises.get(source) || new _src3.ZalgoPromise();
                    promise.resolve({
                        origin: origin
                    });
                    _global.global.readyPromises.set(source, promise);
                });
                var parent = (0, _src2.getAncestor)();
                parent && sayHello(parent).catch(function(err) {
                    _log.log.debug((0, _util.stringifyError)(err));
                });
            };
            exports.onChildWindowReady = function(win) {
                var timeout = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3, name = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Window", promise = _global.global.readyPromises.get(win);
                if (promise) return promise;
                promise = new _src3.ZalgoPromise();
                _global.global.readyPromises.set(win, promise);
                -1 !== timeout && setTimeout(function() {
                    return promise.reject(new Error(name + " did not load after " + timeout + "ms"));
                }, timeout);
                return promise;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js");
            _global.global.readyPromises = _global.global.readyPromises || new _src.WeakMap();
            function onHello(handler) {
                _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.HELLO, {
                    domain: _conf.CONSTANTS.WILDCARD
                }, function(_ref) {
                    var source = _ref.source, origin = _ref.origin;
                    return handler({
                        source: source,
                        origin: origin
                    });
                });
            }
            function sayHello(win) {
                return _global.global.send(win, _conf.CONSTANTS.POST_MESSAGE_NAMES.HELLO, {}, {
                    domain: _conf.CONSTANTS.WILDCARD,
                    timeout: -1
                }).then(function(_ref2) {
                    return {
                        origin: _ref2.origin
                    };
                });
            }
        },
        "./node_modules/post-robot/src/lib/serialize.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.listenForMethods = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.serializeMethod = serializeMethod;
            exports.serializeMethods = function(destination, domain, obj) {
                return (0, _util.replaceObject)({
                    obj: obj
                }, function(item, key) {
                    return "function" == typeof item ? serializeMethod(destination, domain, item, key.toString()) : item instanceof Error ? (err = item, 
                    {
                        __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.ERROR,
                        __message__: (0, _util.stringifyError)(err),
                        __code__: err.code
                    }) : window.Promise && item instanceof window.Promise ? function(destination, domain, promise, name) {
                        return {
                            __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.PROMISE,
                            __then__: serializeMethod(destination, domain, function(resolve, reject) {
                                return promise.then(resolve, reject);
                            }, name + ".then")
                        };
                    }(destination, domain, item, key.toString()) : _src3.ZalgoPromise.isPromise(item) ? function(destination, domain, promise, name) {
                        return {
                            __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE,
                            __then__: serializeMethod(destination, domain, function(resolve, reject) {
                                return promise.then(resolve, reject);
                            }, name + ".then")
                        };
                    }(destination, domain, item, key.toString()) : (0, _util.isRegex)(item) ? (regex = item, 
                    {
                        __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.REGEX,
                        __source__: regex.source
                    }) : void 0;
                    var err, regex;
                }).obj;
            };
            exports.deserializeMethod = deserializeMethod;
            exports.deserializeError = deserializeError;
            exports.deserializeZalgoPromise = deserializeZalgoPromise;
            exports.deserializePromise = deserializePromise;
            exports.deserializeRegex = deserializeRegex;
            exports.deserializeMethods = function(source, origin, obj) {
                return (0, _util.replaceObject)({
                    obj: obj
                }, function(item) {
                    if ("object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item) return isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.METHOD) ? deserializeMethod(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.ERROR) ? deserializeError(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.PROMISE) ? deserializePromise(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE) ? deserializeZalgoPromise(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.REGEX) ? deserializeRegex(source, origin, item) : void 0;
                }).obj;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js"), _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js");
            _global.global.methods = _global.global.methods || new _src.WeakMap();
            exports.listenForMethods = (0, _util.once)(function() {
                _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.METHOD, {
                    origin: _conf.CONSTANTS.WILDCARD
                }, function(_ref) {
                    var source = _ref.source, origin = _ref.origin, data = _ref.data, methods = _global.global.methods.get(source);
                    if (!methods) throw new Error("Could not find any methods this window has privileges to call");
                    var meth = methods[data.id];
                    if (!meth) throw new Error("Could not find method with id: " + data.id);
                    if (!(0, _src2.matchDomain)(meth.domain, origin)) throw new Error("Method domain " + meth.domain + " does not match origin " + origin);
                    _log.log.debug("Call local method", data.name, data.args);
                    return _src3.ZalgoPromise.try(function() {
                        return meth.method.apply({
                            source: source,
                            origin: origin,
                            data: data
                        }, data.args);
                    }).then(function(result) {
                        return {
                            result: result,
                            id: data.id,
                            name: data.name
                        };
                    });
                });
            });
            function isSerialized(item, type) {
                return "object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item && item.__type__ === type;
            }
            function serializeMethod(destination, domain, method, name) {
                var id = (0, _util.uniqueID)(), methods = _global.global.methods.get(destination);
                if (!methods) {
                    methods = {};
                    _global.global.methods.set(destination, methods);
                }
                methods[id] = {
                    domain: domain,
                    method: method
                };
                return {
                    __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.METHOD,
                    __id__: id,
                    __name__: name
                };
            }
            function deserializeMethod(source, origin, obj) {
                function wrapper() {
                    var args = Array.prototype.slice.call(arguments);
                    _log.log.debug("Call foreign method", obj.__name__, args);
                    return _global.global.send(source, _conf.CONSTANTS.POST_MESSAGE_NAMES.METHOD, {
                        id: obj.__id__,
                        name: obj.__name__,
                        args: args
                    }, {
                        domain: origin,
                        timeout: -1
                    }).then(function(_ref2) {
                        var data = _ref2.data;
                        _log.log.debug("Got foreign method result", obj.__name__, data.result);
                        return data.result;
                    }, function(err) {
                        _log.log.debug("Got foreign method error", (0, _util.stringifyError)(err));
                        throw err;
                    });
                }
                wrapper.__name__ = obj.__name__;
                wrapper.__xdomain__ = !0;
                wrapper.source = source;
                wrapper.origin = origin;
                return wrapper;
            }
            function deserializeError(source, origin, obj) {
                var err = new Error(obj.__message__);
                obj.__code__ && (err.code = obj.__code__);
                return err;
            }
            function deserializeZalgoPromise(source, origin, prom) {
                return new _src3.ZalgoPromise(function(resolve, reject) {
                    return deserializeMethod(source, origin, prom.__then__)(resolve, reject);
                });
            }
            function deserializePromise(source, origin, prom) {
                return window.Promise ? new window.Promise(function(resolve, reject) {
                    return deserializeMethod(source, origin, prom.__then__)(resolve, reject);
                }) : deserializeZalgoPromise(source, origin, prom);
            }
            function deserializeRegex(source, origin, item) {
                return new RegExp(item.__source__);
            }
        },
        "./node_modules/post-robot/src/lib/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.weakMapMemoize = exports.once = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.stringifyError = function stringifyError(err) {
                var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                if (level >= 3) return "stringifyError stack overflow";
                try {
                    if (!err) return "<unknown error: " + Object.prototype.toString.call(err) + ">";
                    if ("string" == typeof err) return err;
                    if (err instanceof Error) {
                        var stack = err && err.stack, message = err && err.message;
                        if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                        if (stack) return stack;
                        if (message) return message;
                    }
                    return "function" == typeof err.toString ? err.toString() : Object.prototype.toString.call(err);
                } catch (newErr) {
                    return "Error while stringifying error: " + stringifyError(newErr, level + 1);
                }
            };
            exports.noop = function() {};
            exports.addEventListener = function(obj, event, handler) {
                obj.addEventListener ? obj.addEventListener(event, handler) : obj.attachEvent("on" + event, handler);
                return {
                    cancel: function() {
                        obj.removeEventListener ? obj.removeEventListener(event, handler) : obj.detachEvent("on" + event, handler);
                    }
                };
            };
            exports.uniqueID = function() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            };
            exports.eachArray = eachArray;
            exports.eachObject = eachObject;
            exports.each = each;
            exports.replaceObject = function replaceObject(item, callback) {
                var depth = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                if (depth >= 100) throw new Error("Self-referential object passed, or object contained too many layers");
                var newobj = void 0;
                if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item || Array.isArray(item)) {
                    if (!Array.isArray(item)) throw new TypeError("Invalid type: " + (void 0 === item ? "undefined" : _typeof(item)));
                    newobj = [];
                } else newobj = {};
                each(item, function(childItem, key) {
                    var result = callback(childItem, key);
                    void 0 !== result ? newobj[key] = result : "object" === (void 0 === childItem ? "undefined" : _typeof(childItem)) && null !== childItem ? newobj[key] = replaceObject(childItem, callback, depth + 1) : newobj[key] = childItem;
                });
                return newobj;
            };
            exports.safeInterval = function(method, time) {
                var timeout = void 0;
                timeout = setTimeout(function runInterval() {
                    timeout = setTimeout(runInterval, time);
                    method.call();
                }, time);
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            };
            exports.isRegex = function(item) {
                return "[object RegExp]" === Object.prototype.toString.call(item);
            };
            exports.getWindowType = function() {
                if ((0, _src2.isPopup)()) return _conf.CONSTANTS.WINDOW_TYPES.POPUP;
                if ((0, _src2.isIframe)()) return _conf.CONSTANTS.WINDOW_TYPES.IFRAME;
                return _conf.CONSTANTS.WINDOW_TYPES.FULLPAGE;
            };
            exports.jsonStringify = function(obj, replacer, indent) {
                var objectToJSON = void 0, arrayToJSON = void 0;
                try {
                    if ("{}" !== JSON.stringify({})) {
                        objectToJSON = Object.prototype.toJSON;
                        delete Object.prototype.toJSON;
                    }
                    if ("{}" !== JSON.stringify({})) throw new Error("Can not correctly serialize JSON objects");
                    if ("[]" !== JSON.stringify([])) {
                        arrayToJSON = Array.prototype.toJSON;
                        delete Array.prototype.toJSON;
                    }
                    if ("[]" !== JSON.stringify([])) throw new Error("Can not correctly serialize JSON objects");
                } catch (err) {
                    throw new Error("Can not repair JSON.stringify: " + err.message);
                }
                var result = JSON.stringify.call(this, obj, replacer, indent);
                try {
                    objectToJSON && (Object.prototype.toJSON = objectToJSON);
                    arrayToJSON && (Array.prototype.toJSON = arrayToJSON);
                } catch (err) {
                    throw new Error("Can not repair JSON.stringify: " + err.message);
                }
                return result;
            };
            exports.jsonParse = function(item) {
                return JSON.parse(item);
            };
            exports.needsGlobalMessagingForBrowser = function() {
                if ((0, _src2.getUserAgent)(window).match(/MSIE|trident|edge\/12|edge\/13/i)) return !0;
                if (!_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP) return !0;
                return !1;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            exports.once = function(method) {
                if (!method) return method;
                var called = !1;
                return function() {
                    if (!called) {
                        called = !0;
                        return method.apply(this, arguments);
                    }
                };
            };
            function eachArray(item, callback) {
                for (var i = 0; i < item.length; i++) callback(item[i], i);
            }
            function eachObject(item, callback) {
                for (var _key in item) item.hasOwnProperty(_key) && callback(item[_key], _key);
            }
            function each(item, callback) {
                Array.isArray(item) ? eachArray(item, callback) : "object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item && eachObject(item, callback);
            }
            exports.weakMapMemoize = function(method) {
                var weakmap = new _src.WeakMap();
                return function(arg) {
                    var result = weakmap.get(arg);
                    if (void 0 !== result) return result;
                    void 0 !== (result = method.call(this, arg)) && weakmap.set(arg, result);
                    return result;
                };
            };
        },
        "./node_modules/post-robot/src/public/client.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.send = void 0;
            exports.request = request;
            exports.sendToParent = function(name, data, options) {
                var win = (0, _src3.getAncestor)();
                if (!win) return new _src2.ZalgoPromise(function(resolve, reject) {
                    return reject(new Error("Window does not have a parent"));
                });
                return _send(win, name, data, options);
            };
            exports.client = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (!options.window) throw new Error("Expected options.window");
                var win = options.window;
                return {
                    send: function(name, data) {
                        return _send(win, name, data, options);
                    }
                };
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            _global.global.requestPromises = _global.global.requestPromises || new _src.WeakMap();
            function request(options) {
                return _src2.ZalgoPromise.try(function() {
                    if (!options.name) throw new Error("Expected options.name");
                    var name = options.name, targetWindow = void 0, domain = void 0;
                    if ("string" == typeof options.window) {
                        var el = document.getElementById(options.window);
                        if (!el) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be a valid element id");
                        if ("iframe" !== el.tagName.toLowerCase()) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be an iframe");
                        if (!el.contentWindow) throw new Error("Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.");
                        targetWindow = el.contentWindow;
                    } else if (options.window instanceof HTMLIFrameElement) {
                        if ("iframe" !== options.window.tagName.toLowerCase()) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be an iframe");
                        if (options.window && !options.window.contentWindow) throw new Error("Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.");
                        options.window && options.window.contentWindow && (targetWindow = options.window.contentWindow);
                    } else targetWindow = options.window;
                    if (!targetWindow) throw new Error("Expected options.window to be a window object, iframe, or iframe element id.");
                    var win = targetWindow;
                    domain = options.domain || _conf.CONSTANTS.WILDCARD;
                    var hash = options.name + "_" + (0, _lib.uniqueID)();
                    if ((0, _src3.isWindowClosed)(win)) throw new Error("Target window is closed");
                    var hasResult = !1, requestPromises = _global.global.requestPromises.get(win);
                    if (!requestPromises) {
                        requestPromises = [];
                        _global.global.requestPromises.set(win, requestPromises);
                    }
                    var requestPromise = _src2.ZalgoPromise.try(function() {
                        if ((0, _src3.isAncestor)(window, win)) return (0, _lib.onChildWindowReady)(win, options.timeout || _conf.CONFIG.CHILD_WINDOW_TIMEOUT);
                    }).then(function() {
                        var origin = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).origin;
                        if ((0, _lib.isRegex)(domain) && !origin) return (0, _lib.sayHello)(win);
                    }).then(function() {
                        var origin = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).origin;
                        if ((0, _lib.isRegex)(domain)) {
                            if (!(0, _src3.matchDomain)(domain, origin)) throw new Error("Remote window domain " + origin + " does not match regex: " + domain.toString());
                            domain = origin;
                        }
                        if ("string" != typeof domain && !Array.isArray(domain)) throw new TypeError("Expected domain to be a string or array");
                        var actualDomain = domain;
                        return new _src2.ZalgoPromise(function(resolve, reject) {
                            var responseListener = void 0;
                            if (!options.fireAndForget) {
                                responseListener = {
                                    name: name,
                                    window: win,
                                    domain: actualDomain,
                                    respond: function(err, result) {
                                        if (!err) {
                                            hasResult = !0;
                                            requestPromises.splice(requestPromises.indexOf(requestPromise, 1));
                                        }
                                        err ? reject(err) : resolve(result);
                                    }
                                };
                                (0, _drivers.addResponseListener)(hash, responseListener);
                            }
                            (0, _drivers.sendMessage)(win, {
                                type: _conf.CONSTANTS.POST_MESSAGE_TYPE.REQUEST,
                                hash: hash,
                                name: name,
                                data: options.data,
                                fireAndForget: options.fireAndForget
                            }, actualDomain).catch(reject);
                            if (options.fireAndForget) return resolve();
                            var ackTimeout = _conf.CONFIG.ACK_TIMEOUT, resTimeout = options.timeout || _conf.CONFIG.RES_TIMEOUT, cycleTime = 100;
                            setTimeout(function cycle() {
                                if (!hasResult) {
                                    if ((0, _src3.isWindowClosed)(win)) return responseListener.ack ? reject(new Error("Window closed for " + name + " before response")) : reject(new Error("Window closed for " + name + " before ack"));
                                    ackTimeout = Math.max(ackTimeout - cycleTime, 0);
                                    -1 !== resTimeout && (resTimeout = Math.max(resTimeout - cycleTime, 0));
                                    if (responseListener.ack) {
                                        if (-1 === resTimeout) return;
                                        cycleTime = Math.min(resTimeout, 2e3);
                                    } else {
                                        if (0 === ackTimeout) return reject(new Error("No ack for postMessage " + name + " in " + (0, 
                                        _src3.getDomain)() + " in " + _conf.CONFIG.ACK_TIMEOUT + "ms"));
                                        if (0 === resTimeout) return reject(new Error("No response for postMessage " + name + " in " + (0, 
                                        _src3.getDomain)() + " in " + (options.timeout || _conf.CONFIG.RES_TIMEOUT) + "ms"));
                                    }
                                    setTimeout(cycle, cycleTime);
                                }
                            }, cycleTime);
                        });
                    });
                    requestPromise.catch(function() {
                        (0, _drivers.markResponseListenerErrored)(hash);
                        (0, _drivers.deleteResponseListener)(hash);
                    });
                    requestPromises.push(requestPromise);
                    return requestPromise;
                });
            }
            function _send(window, name, data, options) {
                (options = options || {}).window = window;
                options.name = name;
                options.data = data;
                return request(options);
            }
            exports.send = _send;
            _global.global.send = _send;
        },
        "./node_modules/post-robot/src/public/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = exports.CONFIG = void 0;
            var _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            Object.defineProperty(exports, "CONFIG", {
                enumerable: !0,
                get: function() {
                    return _conf.CONFIG;
                }
            });
            Object.defineProperty(exports, "CONSTANTS", {
                enumerable: !0,
                get: function() {
                    return _conf.CONSTANTS;
                }
            });
            exports.disable = function() {
                delete window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT];
                window.removeEventListener("message", _drivers.messageListener);
            };
            var _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js");
        },
        "./node_modules/post-robot/src/public/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.parent = void 0;
            var _client = __webpack_require__("./node_modules/post-robot/src/public/client.js");
            Object.keys(_client).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _client[key];
                    }
                });
            });
            var _server = __webpack_require__("./node_modules/post-robot/src/public/server.js");
            Object.keys(_server).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _server[key];
                    }
                });
            });
            var _config = __webpack_require__("./node_modules/post-robot/src/public/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            exports.parent = (0, _src.getAncestor)();
        },
        "./node_modules/post-robot/src/public/server.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.on = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.listen = listen;
            exports.once = function(name) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, handler = arguments[2];
                if ("function" == typeof options) {
                    handler = options;
                    options = {};
                }
                options = options || {};
                handler = handler || options.handler;
                var errorHandler = options.errorHandler, promise = new _src2.ZalgoPromise(function(resolve, reject) {
                    (options = options || {}).name = name;
                    options.once = !0;
                    options.handler = function(event) {
                        resolve(event);
                        if (handler) return handler(event);
                    };
                    options.errorHandler = function(err) {
                        reject(err);
                        if (errorHandler) return errorHandler(err);
                    };
                }), onceListener = listen(options);
                promise.cancel = onceListener.cancel;
                return promise;
            };
            exports.listener = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return {
                    on: function(name, handler) {
                        return _on(name, options, handler);
                    }
                };
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            function listen(options) {
                if (!options.name) throw new Error("Expected options.name");
                if (!options.handler) throw new Error("Expected options.handler");
                var name = options.name, win = options.window, domain = options.domain, listenerOptions = {
                    handler: options.handler,
                    handleError: options.errorHandler || function(err) {
                        throw err;
                    },
                    window: win,
                    domain: domain || _conf.CONSTANTS.WILDCARD,
                    name: name
                }, requestListener = (0, _drivers.addRequestListener)({
                    name: name,
                    win: win,
                    domain: domain
                }, listenerOptions);
                if (options.once) {
                    var _handler = listenerOptions.handler;
                    listenerOptions.handler = (0, _lib.once)(function() {
                        requestListener.cancel();
                        return _handler.apply(this, arguments);
                    });
                }
                if (listenerOptions.window && options.errorOnClose) var interval = (0, _lib.safeInterval)(function() {
                    if (win && "object" === (void 0 === win ? "undefined" : _typeof(win)) && (0, _src.isWindowClosed)(win)) {
                        interval.cancel();
                        listenerOptions.handleError(new Error("Post message target window is closed"));
                    }
                }, 50);
                return {
                    cancel: function() {
                        requestListener.cancel();
                    }
                };
            }
            function _on(name, options, handler) {
                if ("function" == typeof options) {
                    handler = options;
                    options = {};
                }
                (options = options || {}).name = name;
                options.handler = handler || options.handler;
                return listen(options);
            }
            exports.on = _on;
            _global.global.on = _on;
        },
        "./node_modules/process/browser.js": function(module, exports, __webpack_require__) {
            "use strict";
            var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            !function() {
                try {
                    cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }();
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            var currentQueue, queue = [], draining = !1, queueIndex = -1;
            function cleanUpNextTick() {
                if (draining && currentQueue) {
                    draining = !1;
                    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1;
                    queue.length && drainQueue();
                }
            }
            function drainQueue() {
                if (!draining) {
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = !0;
                    for (var len = queue.length; len; ) {
                        currentQueue = queue;
                        queue = [];
                        for (;++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = !1;
                    !function(marker) {
                        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                            cachedClearTimeout = clearTimeout;
                            return clearTimeout(marker);
                        }
                        try {
                            cachedClearTimeout(marker);
                        } catch (e) {
                            try {
                                return cachedClearTimeout.call(null, marker);
                            } catch (e) {
                                return cachedClearTimeout.call(this, marker);
                            }
                        }
                    }(timeout);
                }
            }
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
                queue.push(new Item(fun, args));
                1 !== queue.length || draining || runTimeout(drainQueue);
            };
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            process.title = "browser";
            process.browser = !0;
            process.env = {};
            process.argv = [];
            process.version = "";
            process.versions = {};
            function noop() {}
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function(name) {
                return [];
            };
            process.binding = function(name) {
                throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
                return "/";
            };
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            };
            process.umask = function() {
                return 0;
            };
        },
        "./node_modules/webpack/buildin/amd-options.js": function(module, exports) {
            (function(__webpack_amd_options__) {
                module.exports = __webpack_amd_options__;
            }).call(exports, {});
        },
        "./node_modules/webpack/buildin/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            var g, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            g = function() {
                return this;
            }();
            try {
                g = g || Function("return this")() || (0, eval)("this");
            } catch (e) {
                "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && (g = window);
            }
            module.exports = g;
        },
        "./node_modules/webpack/buildin/module.js": function(module, exports, __webpack_require__) {
            "use strict";
            module.exports = function(module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function() {};
                    module.paths = [];
                    module.children || (module.children = []);
                    Object.defineProperty(module, "loaded", {
                        enumerable: !0,
                        get: function() {
                            return module.l;
                        }
                    });
                    Object.defineProperty(module, "id", {
                        enumerable: !0,
                        get: function() {
                            return module.i;
                        }
                    });
                    module.webpackPolyfill = 1;
                }
                return module;
            };
        },
        "./node_modules/zalgo-promise/src/exceptions.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.dispatchPossiblyUnhandledError = function(err) {
                if (-1 !== (0, _global.getGlobal)().dispatchedErrors.indexOf(err)) return;
                (0, _global.getGlobal)().dispatchedErrors.push(err);
                setTimeout(function() {
                    throw err;
                }, 1);
                for (var j = 0; j < (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.length; j++) (0, 
                _global.getGlobal)().possiblyUnhandledPromiseHandlers[j](err);
            };
            exports.onPossiblyUnhandledException = function(handler) {
                (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.push(handler);
                return {
                    cancel: function() {
                        (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.splice((0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                    }
                };
            };
            var _global = __webpack_require__("./node_modules/zalgo-promise/src/global.js");
        },
        "./node_modules/zalgo-promise/src/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            (function(global) {
                exports.__esModule = !0;
                exports.getGlobal = function() {
                    var glob = void 0;
                    if ("undefined" != typeof window) glob = window; else {
                        if (void 0 === global) throw new TypeError("Can not find global");
                        glob = global;
                    }
                    var zalgoGlobal = glob.__zalgopromise__ = glob.__zalgopromise__ || {};
                    zalgoGlobal.flushPromises = zalgoGlobal.flushPromises || [];
                    zalgoGlobal.activeCount = zalgoGlobal.activeCount || 0;
                    zalgoGlobal.possiblyUnhandledPromiseHandlers = zalgoGlobal.possiblyUnhandledPromiseHandlers || [];
                    zalgoGlobal.dispatchedErrors = zalgoGlobal.dispatchedErrors || [];
                    return zalgoGlobal;
                };
            }).call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"));
        },
        "./node_modules/zalgo-promise/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _promise = __webpack_require__("./node_modules/zalgo-promise/src/promise.js");
            Object.defineProperty(exports, "ZalgoPromise", {
                enumerable: !0,
                get: function() {
                    return _promise.ZalgoPromise;
                }
            });
        },
        "./node_modules/zalgo-promise/src/promise.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ZalgoPromise = void 0;
            var _utils = __webpack_require__("./node_modules/zalgo-promise/src/utils.js"), _exceptions = __webpack_require__("./node_modules/zalgo-promise/src/exceptions.js"), _global = __webpack_require__("./node_modules/zalgo-promise/src/global.js");
            var ZalgoPromise = function() {
                function ZalgoPromise(handler) {
                    var _this = this;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ZalgoPromise);
                    this.resolved = !1;
                    this.rejected = !1;
                    this.errorHandled = !1;
                    this.handlers = [];
                    if (handler) {
                        var _result = void 0, _error = void 0, resolved = !1, rejected = !1, isAsync = !1;
                        try {
                            handler(function(res) {
                                if (isAsync) _this.resolve(res); else {
                                    resolved = !0;
                                    _result = res;
                                }
                            }, function(err) {
                                if (isAsync) _this.reject(err); else {
                                    rejected = !0;
                                    _error = err;
                                }
                            });
                        } catch (err) {
                            this.reject(err);
                            return;
                        }
                        isAsync = !0;
                        resolved ? this.resolve(_result) : rejected && this.reject(_error);
                    }
                }
                ZalgoPromise.prototype.resolve = function(result) {
                    if (this.resolved || this.rejected) return this;
                    if ((0, _utils.isPromise)(result)) throw new Error("Can not resolve promise with another promise");
                    this.resolved = !0;
                    this.value = result;
                    this.dispatch();
                    return this;
                };
                ZalgoPromise.prototype.reject = function(error) {
                    var _this2 = this;
                    if (this.resolved || this.rejected) return this;
                    if ((0, _utils.isPromise)(error)) throw new Error("Can not reject promise with another promise");
                    if (!error) {
                        var _err = error && "function" == typeof error.toString ? error.toString() : Object.prototype.toString.call(error);
                        error = new Error("Expected reject to be called with Error, got " + _err);
                    }
                    this.rejected = !0;
                    this.error = error;
                    this.errorHandled || setTimeout(function() {
                        _this2.errorHandled || (0, _exceptions.dispatchPossiblyUnhandledError)(error);
                    }, 1);
                    this.dispatch();
                    return this;
                };
                ZalgoPromise.prototype.asyncReject = function(error) {
                    this.errorHandled = !0;
                    this.reject(error);
                };
                ZalgoPromise.prototype.dispatch = function() {
                    var _this3 = this, dispatching = this.dispatching, resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                    if (!dispatching && (resolved || rejected)) {
                        this.dispatching = !0;
                        (0, _global.getGlobal)().activeCount += 1;
                        for (var _loop = function(i) {
                            var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise, result = void 0;
                            if (resolved) try {
                                result = onSuccess ? onSuccess(_this3.value) : _this3.value;
                            } catch (err) {
                                promise.reject(err);
                                return "continue";
                            } else if (rejected) {
                                if (!onError) {
                                    promise.reject(_this3.error);
                                    return "continue";
                                }
                                try {
                                    result = onError(_this3.error);
                                } catch (err) {
                                    promise.reject(err);
                                    return "continue";
                                }
                            }
                            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {
                                result.resolved ? promise.resolve(result.value) : promise.reject(result.error);
                                result.errorHandled = !0;
                            } else (0, _utils.isPromise)(result) ? result instanceof ZalgoPromise && (result.resolved || result.rejected) ? result.resolved ? promise.resolve(result.value) : promise.reject(result.error) : result.then(function(res) {
                                promise.resolve(res);
                            }, function(err) {
                                promise.reject(err);
                            }) : promise.resolve(result);
                        }, i = 0; i < handlers.length; i++) _loop(i);
                        handlers.length = 0;
                        this.dispatching = !1;
                        (0, _global.getGlobal)().activeCount -= 1;
                        0 === (0, _global.getGlobal)().activeCount && ZalgoPromise.flushQueue();
                    }
                };
                ZalgoPromise.prototype.then = function(onSuccess, onError) {
                    if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                    if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                    var promise = new ZalgoPromise();
                    this.handlers.push({
                        promise: promise,
                        onSuccess: onSuccess,
                        onError: onError
                    });
                    this.errorHandled = !0;
                    this.dispatch();
                    return promise;
                };
                ZalgoPromise.prototype.catch = function(onError) {
                    return this.then(void 0, onError);
                };
                ZalgoPromise.prototype.finally = function(handler) {
                    return this.then(function(result) {
                        return ZalgoPromise.try(handler).then(function() {
                            return result;
                        });
                    }, function(err) {
                        return ZalgoPromise.try(handler).then(function() {
                            throw err;
                        });
                    });
                };
                ZalgoPromise.prototype.timeout = function(time, err) {
                    var _this4 = this;
                    if (this.resolved || this.rejected) return this;
                    var timeout = setTimeout(function() {
                        _this4.resolved || _this4.rejected || _this4.reject(err || new Error("Promise timed out after " + time + "ms"));
                    }, time);
                    return this.then(function(result) {
                        clearTimeout(timeout);
                        return result;
                    });
                };
                ZalgoPromise.prototype.toPromise = function() {
                    if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                    return Promise.resolve(this);
                };
                ZalgoPromise.resolve = function(value) {
                    return value instanceof ZalgoPromise ? value : (0, _utils.isPromise)(value) ? new ZalgoPromise(function(resolve, reject) {
                        return value.then(resolve, reject);
                    }) : new ZalgoPromise().resolve(value);
                };
                ZalgoPromise.reject = function(error) {
                    return new ZalgoPromise().reject(error);
                };
                ZalgoPromise.all = function(promises) {
                    var promise = new ZalgoPromise(), count = promises.length, results = [];
                    if (!count) {
                        promise.resolve(results);
                        return promise;
                    }
                    for (var _loop2 = function(i) {
                        var prom = promises[i];
                        if (prom instanceof ZalgoPromise) {
                            if (prom.resolved) {
                                results[i] = prom.value;
                                count -= 1;
                                return "continue";
                            }
                        } else if (!(0, _utils.isPromise)(prom)) {
                            results[i] = prom;
                            count -= 1;
                            return "continue";
                        }
                        ZalgoPromise.resolve(prom).then(function(result) {
                            results[i] = result;
                            0 === (count -= 1) && promise.resolve(results);
                        }, function(err) {
                            promise.reject(err);
                        });
                    }, i = 0; i < promises.length; i++) _loop2(i);
                    0 === count && promise.resolve(results);
                    return promise;
                };
                ZalgoPromise.hash = function(promises) {
                    var result = {};
                    return ZalgoPromise.all(Object.keys(promises).map(function(key) {
                        return ZalgoPromise.resolve(promises[key]).then(function(value) {
                            result[key] = value;
                        });
                    })).then(function() {
                        return result;
                    });
                };
                ZalgoPromise.map = function(items, method) {
                    return ZalgoPromise.all(items.map(method));
                };
                ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                    return (0, _exceptions.onPossiblyUnhandledException)(handler);
                };
                ZalgoPromise.try = function(method, context, args) {
                    var result = void 0;
                    try {
                        result = method.apply(context, args || []);
                    } catch (err) {
                        return ZalgoPromise.reject(err);
                    }
                    return ZalgoPromise.resolve(result);
                };
                ZalgoPromise.delay = function(_delay) {
                    return new ZalgoPromise(function(resolve) {
                        setTimeout(resolve, _delay);
                    });
                };
                ZalgoPromise.isPromise = function(value) {
                    return !!(value && value instanceof ZalgoPromise) || (0, _utils.isPromise)(value);
                };
                ZalgoPromise.flush = function() {
                    var promise = new ZalgoPromise();
                    (0, _global.getGlobal)().flushPromises.push(promise);
                    0 === (0, _global.getGlobal)().activeCount && ZalgoPromise.flushQueue();
                    return promise;
                };
                ZalgoPromise.flushQueue = function() {
                    var promisesToFlush = (0, _global.getGlobal)().flushPromises;
                    (0, _global.getGlobal)().flushPromises = [];
                    var _iterator = promisesToFlush, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.resolve();
                    }
                };
                return ZalgoPromise;
            }();
            exports.ZalgoPromise = ZalgoPromise;
        },
        "./node_modules/zalgo-promise/src/utils.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isPromise = function(item) {
                try {
                    if (!item) return !1;
                    if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                    if ("undefined" != typeof window && window.Window && item instanceof window.Window) return !1;
                    if ("undefined" != typeof window && window.constructor && item instanceof window.constructor) return !1;
                    var _toString = {}.toString;
                    if (_toString) {
                        var name = _toString.call(item);
                        if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                    }
                    if ("function" == typeof item.then) return !0;
                } catch (err) {
                    return !1;
                }
                return !1;
            };
        },
        "./src/component/base.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.BaseComponent = void 0;
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js");
            __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.BaseComponent = function() {
                function BaseComponent() {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, BaseComponent);
                    this.clean = (obj = this, tasks = [], cleaned = !1, {
                        set: function(name, item) {
                            if (cleaned) return item;
                            obj[name] = item;
                            this.register(function() {
                                delete obj[name];
                            });
                            return item;
                        },
                        register: function(name, method) {
                            if ("function" == typeof name) {
                                method = name;
                                name = "<anonymous-cleanup-handler>";
                            }
                            if ("function" != typeof method) throw new TypeError("Expected to be passed function to clean.register");
                            cleaned ? method() : tasks.push({
                                complete: !1,
                                name: name,
                                run: function() {
                                    if (!this.complete) {
                                        this.complete = !0;
                                        method && method();
                                    }
                                }
                            });
                        },
                        hasTasks: function() {
                            return Boolean(tasks.filter(function(item) {
                                return !item.complete;
                            }).length);
                        },
                        all: function() {
                            var results = [];
                            cleaned = !0;
                            for (;tasks.length; ) results.push(tasks.pop().run());
                            return _src.ZalgoPromise.all(results).then(function() {});
                        },
                        run: function(name) {
                            var results = [], _iterator = tasks, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var item = _ref;
                                item.name === name && results.push(item.run());
                            }
                            return _src.ZalgoPromise.all(results).then(_lib.noop);
                        }
                    });
                    var obj, tasks, cleaned;
                    this.event = (0, _lib.eventEmitter)();
                }
                BaseComponent.prototype.addProp = function(options, name, def) {
                    (0, _lib.copyProp)(options, this, name, def);
                };
                BaseComponent.prototype.on = function(eventName, handler) {
                    return this.event.on(eventName, handler);
                };
                BaseComponent.prototype.listeners = function() {
                    throw new Error("Expected listeners to be implemented");
                };
                BaseComponent.prototype.error = function(err) {
                    throw new Error("Expected error to be implemented - got " + (0, _lib.stringifyError)(err));
                };
                BaseComponent.prototype.listen = function(win, domain) {
                    var _this = this;
                    if (!win) throw this.component.createError("window to listen to not set");
                    if (!domain) throw new Error("Must pass domain to listen to");
                    if (this.listeners) {
                        var listeners = this.listeners(), _loop = function() {
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) return "break";
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) return "break";
                                _ref2 = _i2.value;
                            }
                            var listenerName = _ref2, name = listenerName.replace(/^zoid_/, ""), errorHandler = function(err) {
                                _this.error(err);
                            }, listener = (0, _src2.on)(listenerName, {
                                window: win,
                                domain: domain,
                                errorHandler: errorHandler
                            }, function(_ref3) {
                                var source = _ref3.source, data = _ref3.data;
                                _this.component.log("listener_" + name);
                                return listeners[listenerName].call(_this, source, data);
                            }), errorListener = (0, _src2.on)(listenerName, {
                                window: win,
                                errorHandler: errorHandler
                            }, function(_ref4) {
                                var origin = _ref4.origin;
                                _this.component.logError("unexpected_listener_" + name, {
                                    origin: origin,
                                    domain: domain.toString()
                                });
                                _this.error(new Error("Unexpected " + name + " message from domain " + origin + " -- expected message from " + domain.toString()));
                            });
                            _this.clean.register(function() {
                                listener.cancel();
                                errorListener.cancel();
                            });
                        }, _iterator2 = Object.keys(listeners), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if ("break" === _loop()) break;
                        }
                    }
                };
                return BaseComponent;
            }();
        },
        "./src/component/child/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ChildComponent = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _client = __webpack_require__("./node_modules/beaver-logger/client/index.js"), _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _window = __webpack_require__("./src/component/window.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _error = __webpack_require__("./src/error.js"), _props = __webpack_require__("./src/component/child/props.js");
            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            exports.ChildComponent = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(ChildComponent, _BaseComponent);
                function ChildComponent(component) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ChildComponent);
                    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this));
                    _this.component = component;
                    if (!_this.hasValidParentDomain()) {
                        _this.error(new _error.RenderError("Can not be rendered by domain: " + _this.getParentDomain()));
                        return _possibleConstructorReturn(_this);
                    }
                    _this.component.log("construct_child");
                    _this.onPropHandlers = [];
                    for (var _arr = [ _this.component, window ], _loop = function() {
                        for (var item = _arr[_i], _arr2 = [ [ "xchild", function() {
                            return _this;
                        } ], [ "xprops", function() {
                            return _this.props;
                        } ] ], _loop2 = function() {
                            var _arr2$_i = _arr2[_i2], name = _arr2$_i[0], getter = _arr2$_i[1];
                            Object.defineProperty(item, name, {
                                configurable: !0,
                                get: function() {
                                    _this.props || _this.setProps(_this.getInitialProps(), (0, _window.getParentDomain)());
                                    delete item[name];
                                    item[name] = getter();
                                    return item[name];
                                }
                            });
                        }, _i2 = 0; _i2 < _arr2.length; _i2++) _loop2();
                    }, _i = 0; _i < _arr.length; _i++) _loop();
                    _this.component.log("init_child");
                    _this.setWindows();
                    _this.listenForResize();
                    _this.onInit = _this.sendToParent(_constants.POST_MESSAGE.INIT, {
                        exports: _this.exports()
                    }).then(function(_ref) {
                        var origin = _ref.origin, data = _ref.data;
                        _this.context = data.context;
                        _this.setProps(data.props, origin);
                        _this.watchForResize();
                        return _this;
                    }).catch(function(err) {
                        _this.error(err);
                        throw err;
                    });
                    return _this;
                }
                ChildComponent.prototype.listenForResize = function() {
                    var _this2 = this;
                    if (this.component.listenForResize) {
                        this.sendToParent(_constants.POST_MESSAGE.ONRESIZE, {}, {
                            fireAndForget: !0
                        });
                        window.addEventListener("resize", function() {
                            _this2.sendToParent(_constants.POST_MESSAGE.ONRESIZE, {}, {
                                fireAndForget: !0
                            });
                        });
                    }
                };
                ChildComponent.prototype.hasValidParentDomain = function() {
                    return (0, _src.matchDomain)(this.component.allowedParentDomains, this.getParentDomain());
                };
                ChildComponent.prototype.init = function() {
                    return this.onInit;
                };
                ChildComponent.prototype.getParentDomain = function() {
                    return (0, _window.getParentDomain)();
                };
                ChildComponent.prototype.onProps = function(handler) {
                    this.onPropHandlers.push(handler);
                };
                ChildComponent.prototype.getParentComponentWindow = function() {
                    return (0, _window.getParentComponentWindow)();
                };
                ChildComponent.prototype.getParentRenderWindow = function() {
                    return (0, _window.getParentRenderWindow)();
                };
                ChildComponent.prototype.getInitialProps = function() {
                    var _this3 = this, componentMeta = (0, _window.getComponentMeta)(), props = componentMeta.props;
                    if (props.type === _constants.INITIAL_PROPS.RAW) props = props.value; else {
                        if (props.type !== _constants.INITIAL_PROPS.UID) throw new Error("Unrecognized props type: " + props.type);
                        var parentComponentWindow = (0, _window.getParentComponentWindow)();
                        if (!(0, _src.isSameDomain)(parentComponentWindow)) {
                            if ("file:" === window.location.protocol) throw new Error("Can not get props from file:// domain");
                            throw new Error("Parent component window is on a different domain - expected " + (0, 
                            _src.getDomain)() + " - can not retrieve props");
                        }
                        var global = (0, _lib.globalFor)(parentComponentWindow);
                        if (!global) throw new Error("Can not find global for parent component - can not retrieve props");
                        props = JSON.parse(global.props[componentMeta.uid]);
                    }
                    if (!props) throw new Error("Initial props not found");
                    return (0, _lib.deserializeFunctions)(props, function(_ref2) {
                        var fullKey = _ref2.fullKey, self = _ref2.self, args = _ref2.args;
                        return _this3.onInit.then(function() {
                            var func = (0, _lib.get)(_this3.props, fullKey);
                            if ("function" != typeof func) throw new TypeError("Expected " + fullKey + " to be function, got " + (void 0 === func ? "undefined" : _typeof(func)));
                            return func.apply(self, args);
                        });
                    });
                };
                ChildComponent.prototype.setProps = function(props, origin) {
                    var required = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    this.props = this.props || {};
                    var normalizedProps = (0, _props.normalizeChildProps)(this.component, props, origin, required);
                    (0, _lib.extend)(this.props, normalizedProps);
                    this.props.logLevel && (0, _lib.setLogLevel)(this.props.logLevel);
                    var _iterator = this.onPropHandlers, _isArray = Array.isArray(_iterator), _i3 = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray) {
                            if (_i3 >= _iterator.length) break;
                            _ref3 = _iterator[_i3++];
                        } else {
                            if ((_i3 = _iterator.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        _ref3.call(this, this.props);
                    }
                };
                ChildComponent.prototype.sendToParent = function(name) {
                    var data = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, parentWindow = (0, 
                    _window.getParentComponentWindow)();
                    if (!parentWindow) throw new Error("Can not find parent component window to message");
                    this.component.log("send_to_parent_" + name);
                    return (0, _src2.send)(parentWindow, name, data, _extends({
                        domain: (0, _window.getParentDomain)()
                    }, options));
                };
                ChildComponent.prototype.setWindows = function() {
                    if (window.__activeZoidComponent__) throw this.component.createError("Can not attach multiple components to the same window");
                    window.__activeZoidComponent__ = this;
                    if (!(0, _window.getParentComponentWindow)()) throw this.component.createError("Can not find parent window");
                    var componentMeta = (0, _window.getComponentMeta)();
                    if (componentMeta.tag !== this.component.tag) throw this.component.createError("Parent is " + componentMeta.tag + " - can not attach " + this.component.tag);
                    this.watchForClose();
                };
                ChildComponent.prototype.watchForClose = function() {
                    var _this4 = this;
                    window.addEventListener("unload", function() {
                        return _this4.checkClose();
                    });
                };
                ChildComponent.prototype.enableAutoResize = function() {
                    var _ref4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref4$width = _ref4.width, width = void 0 === _ref4$width || _ref4$width, _ref4$height = _ref4.height, height = void 0 === _ref4$height || _ref4$height;
                    this.autoResize = {
                        width: width,
                        height: height
                    };
                    this.watchForResize();
                };
                ChildComponent.prototype.getAutoResize = function() {
                    var width = !1, height = !1, autoResize = this.autoResize || this.component.autoResize;
                    if ("object" === (void 0 === autoResize ? "undefined" : _typeof(autoResize))) {
                        width = Boolean(autoResize.width);
                        height = Boolean(autoResize.height);
                    } else if (autoResize) {
                        width = !0;
                        height = !0;
                    }
                    return {
                        width: width,
                        height: height,
                        element: autoResize.element ? (0, _lib.getElement)(autoResize.element) : window.navigator.userAgent.match(/MSIE (9|10)\./) ? document.body : document.documentElement
                    };
                };
                ChildComponent.prototype.watchForResize = function() {
                    var _this5 = this, _getAutoResize = this.getAutoResize(), width = _getAutoResize.width, height = _getAutoResize.height, element = _getAutoResize.element;
                    if ((width || height) && this.context !== _constants.CONTEXT_TYPES.POPUP && !this.watchingForResize) {
                        this.watchingForResize = !0;
                        return _src3.ZalgoPromise.try(function() {
                            return _lib.documentReady;
                        }).then(function() {
                            if (!(0, _lib.dimensionsMatchViewport)(element, {
                                width: width,
                                height: height
                            })) return _this5.resizeToElement(element, {
                                width: width,
                                height: height
                            });
                        }).then(function() {
                            return (0, _lib.cycle)(function() {
                                return (0, _lib.onDimensionsChange)(element, {
                                    width: width,
                                    height: height
                                }).then(function() {
                                    return _this5.resizeToElement(element, {
                                        width: width,
                                        height: height
                                    });
                                });
                            });
                        });
                    }
                };
                ChildComponent.prototype.exports = function() {
                    var self = this;
                    return {
                        updateProps: function(props) {
                            var _this6 = this;
                            return _src3.ZalgoPromise.try(function() {
                                return self.setProps(props, _this6.origin, !1);
                            });
                        },
                        close: function() {
                            return _src3.ZalgoPromise.try(function() {
                                return self.destroy();
                            });
                        }
                    };
                };
                ChildComponent.prototype.resize = function(width, height) {
                    var _this7 = this;
                    return _src3.ZalgoPromise.resolve().then(function() {
                        _this7.component.log("resize", {
                            width: (0, _lib.stringify)(width),
                            height: (0, _lib.stringify)(height)
                        });
                        if (_this7.context !== _constants.CONTEXT_TYPES.POPUP) return _this7.sendToParent(_constants.POST_MESSAGE.RESIZE, {
                            width: width,
                            height: height
                        }).then(_lib.noop);
                    });
                };
                ChildComponent.prototype.resizeToElement = function(el, _ref5) {
                    var _this8 = this, width = _ref5.width, height = _ref5.height, history = [];
                    return function resize() {
                        return _src3.ZalgoPromise.try(function() {
                            var tracker = (0, _lib.trackDimensions)(el, {
                                width: width,
                                height: height
                            }), dimensions = tracker.check().dimensions, _iterator2 = history, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray2) {
                                    if (_i4 >= _iterator2.length) break;
                                    _ref6 = _iterator2[_i4++];
                                } else {
                                    if ((_i4 = _iterator2.next()).done) break;
                                    _ref6 = _i4.value;
                                }
                                var size = _ref6, widthMatch = !width || size.width === dimensions.width, heightMatch = !height || size.height === dimensions.height;
                                if (widthMatch && heightMatch) return;
                            }
                            history.push({
                                width: dimensions.width,
                                height: dimensions.height
                            });
                            return _this8.resize(width ? dimensions.width : null, height ? dimensions.height : null).then(function() {
                                if (tracker.check().changed) return resize();
                            });
                        });
                    }();
                };
                ChildComponent.prototype.hide = function() {
                    return this.sendToParent(_constants.POST_MESSAGE.HIDE).then(_lib.noop);
                };
                ChildComponent.prototype.show = function() {
                    return this.sendToParent(_constants.POST_MESSAGE.SHOW).then(_lib.noop);
                };
                ChildComponent.prototype.userClose = function() {
                    return this.close(_constants.CLOSE_REASONS.USER_CLOSED);
                };
                ChildComponent.prototype.close = function() {
                    var reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.CHILD_CALL;
                    this.component.log("close_child");
                    this.sendToParent(_constants.POST_MESSAGE.CLOSE, {
                        reason: reason
                    });
                };
                ChildComponent.prototype.checkClose = function() {
                    this.sendToParent(_constants.POST_MESSAGE.CHECK_CLOSE, {}, {
                        fireAndForget: !0
                    });
                };
                ChildComponent.prototype.destroy = function() {
                    return (0, _client.flush)().then(function() {
                        window.close();
                    });
                };
                ChildComponent.prototype.focus = function() {
                    this.component.log("focus");
                    window.focus();
                };
                ChildComponent.prototype.error = function(err) {
                    var stringifiedError = (0, _lib.stringifyError)(err);
                    this.component.logError("error", {
                        error: stringifiedError
                    });
                    return this.sendToParent(_constants.POST_MESSAGE.ERROR, {
                        error: stringifiedError
                    }).then(_lib.noop);
                };
                return ChildComponent;
            }(_base.BaseComponent);
        },
        "./src/component/child/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.normalizeChildProp = normalizeChildProp;
            exports.normalizeChildProps = function(component, props, origin) {
                for (var required = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], result = {}, _iterator = Object.keys(props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var _key = _ref, prop = component.getProp(_key), value = props[_key];
                    if (!prop || !prop.sameDomain || origin === (0, _src.getDomain)(window)) {
                        result[_key] = normalizeChildProp(component, props, _key, value);
                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);
                    }
                }
                if (required) for (var _iterator2 = component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var key = _ref2;
                    props.hasOwnProperty(key) || (result[key] = normalizeChildProp(component, props, key, props[key]));
                }
                return result;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            function normalizeChildProp(component, props, key, value) {
                var prop = component.getProp(key);
                return prop ? "function" == typeof prop.childDecorate ? prop.childDecorate(value) : value : component.looseProps ? value : void 0;
            }
        },
        "./src/component/component/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.Component = void 0;
            var _class, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _child = __webpack_require__("./src/component/child/index.js"), _parent = __webpack_require__("./src/component/parent/index.js"), _delegate = __webpack_require__("./src/component/delegate/index.js"), _window = __webpack_require__("./src/component/window.js"), _constants = __webpack_require__("./src/constants.js"), _index = __webpack_require__("./src/drivers/index.js"), _lib = __webpack_require__("./src/lib/index.js"), _validate = __webpack_require__("./src/component/component/validate.js"), _templates = __webpack_require__("./src/component/component/templates/index.js"), _props = __webpack_require__("./src/component/component/props.js");
            var drivers = {
                angular: _index.angular,
                angular2: _index.angular2,
                glimmer: _index.glimmer,
                react: _index.react,
                vue: _index.vue,
                script: _index.script
            };
            (exports.Component = (function(target, property, decorators, descriptor, context) {
                var desc = {};
                Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                });
                desc.enumerable = !!desc.enumerable;
                desc.configurable = !!desc.configurable;
                ("value" in desc || desc.initializer) && (desc.writable = !0);
                desc = decorators.slice().reverse().reduce(function(desc, decorator) {
                    return decorator(target, property, desc) || desc;
                }, desc);
                if (context && void 0 !== desc.initializer) {
                    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                    desc.initializer = void 0;
                }
                if (void 0 === desc.initializer) {
                    Object.defineProperty(target, property, desc);
                    desc = null;
                }
            }((_class = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(Component, _BaseComponent);
                function Component(options) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, Component);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    (0, _validate.validate)(options);
                    _this.addProp(options, "tag");
                    _this.addProp(options, "defaultLogLevel", "info");
                    _this.addProp(options, "allowedParentDomains", _constants.WILDCARD);
                    (0, _lib.setLogLevel)(_this.defaultLogLevel);
                    if (Component.components[_this.tag]) throw new Error("Can not register multiple components with the same tag");
                    _this.addProp(options, "name", _this.tag.replace(/-/g, "_"));
                    _this.builtinProps = (0, _props.getInternalProps)();
                    _this.props = options.props || {};
                    options.props || (_this.looseProps = !0);
                    _this.addProp(options, "dimensions");
                    _this.addProp(options, "scrolling");
                    _this.addProp(options, "listenForResize");
                    _this.addProp(options, "version", "latest");
                    _this.addProp(options, "defaultEnv");
                    _this.addProp(options, "buildUrl");
                    _this.addProp(options, "url");
                    _this.addProp(options, "domain");
                    _this.addProp(options, "bridgeUrl");
                    _this.addProp(options, "bridgeDomain");
                    _this.addProp(options, "attributes", {});
                    _this.addProp(options, "contexts", {
                        iframe: !0,
                        popup: !1
                    });
                    _this.addProp(options, "defaultContext");
                    _this.addProp(options, "autoResize", !1);
                    _this.addProp(options, "containerTemplate", _templates.defaultContainerTemplate);
                    _this.addProp(options, "prerenderTemplate", _templates.defaultPrerenderTemplate);
                    _this.addProp(options, "validate");
                    _this.addProp(options, "unsafeRenderTo", !1);
                    Component.components[_this.tag] = _this;
                    _this.registerDrivers();
                    _this.registerChild();
                    _this.listenDelegate();
                    return _this;
                }
                Component.prototype.getPropNames = function() {
                    var props = Object.keys(this.props), _iterator = Object.keys(this.builtinProps), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref;
                        -1 === props.indexOf(key) && props.push(key);
                    }
                    return props;
                };
                Component.prototype.getProp = function(name) {
                    return this.props[name] || this.builtinProps[name];
                };
                Component.prototype.registerDrivers = function() {
                    this.driverCache = {};
                    var _iterator2 = Object.keys(drivers), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var driverName = _ref2;
                        if (0 !== driverName.indexOf("_")) {
                            var glob = drivers[driverName].global();
                            glob && this.driver(driverName, glob);
                        }
                    }
                };
                Component.prototype.driver = function(name, dep) {
                    if (!drivers[name]) throw new Error("Could not find driver for framework: " + name);
                    this.driverCache[name] || (this.driverCache[name] = drivers[name].register(this, dep));
                    return this.driverCache[name];
                };
                Component.prototype.registerChild = function() {
                    var _this2 = this;
                    return _src2.ZalgoPromise.try(function() {
                        if (_this2.isChild()) return new _child.ChildComponent(_this2);
                    });
                };
                Component.prototype.listenDelegate = function() {
                    var _this3 = this;
                    (0, _src.on)(_constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + this.name, function() {
                        return !0;
                    });
                    (0, _src.on)(_constants.POST_MESSAGE.DELEGATE + "_" + this.name, function(_ref3) {
                        var source = _ref3.source, origin = _ref3.origin, data = _ref3.data, domain = _this3.getDomain(null, data.env || _this3.defaultEnv);
                        if (!domain) throw new Error("Could not determine domain to allow remote render");
                        if (!(0, _src3.matchDomain)(domain, origin)) throw new Error("Can not render from " + origin + " - expected " + domain.toString());
                        var delegate = _this3.delegate(source, data.options);
                        return {
                            overrides: delegate.getOverrides(data.context),
                            destroy: function() {
                                return delegate.destroy();
                            }
                        };
                    });
                };
                Component.prototype.canRenderTo = function(win) {
                    return (0, _src.send)(win, _constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + this.name).then(function(_ref4) {
                        return _ref4.data;
                    }).catch(function() {
                        return !1;
                    });
                };
                Component.prototype.getValidDomain = function(url) {
                    if (url) {
                        var domain = (0, _src3.getDomainFromUrl)(url);
                        if ("string" == typeof this.domain && domain === this.domain) return domain;
                        var domains = this.domain;
                        if (domains && "object" === (void 0 === domains ? "undefined" : _typeof(domains)) && !(domains instanceof RegExp)) {
                            var _iterator3 = Object.keys(domains), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref5;
                                if (_isArray3) {
                                    if (_i3 >= _iterator3.length) break;
                                    _ref5 = _iterator3[_i3++];
                                } else {
                                    if ((_i3 = _iterator3.next()).done) break;
                                    _ref5 = _i3.value;
                                }
                                if ("test" !== _ref5 && domain === domains[_ref5]) return domain;
                            }
                        }
                    }
                };
                Component.prototype.getDomain = function(url, env) {
                    var domain = this.getForEnv(this.domain, env);
                    if (domain) return domain;
                    if (domain = this.getValidDomain(url)) return domain;
                    var envUrl = this.getForEnv(this.url, env);
                    return envUrl ? (0, _src3.getDomainFromUrl)(envUrl) : url ? (0, _src3.getDomainFromUrl)(url) : void 0;
                };
                Component.prototype.getBridgeUrl = function(env) {
                    return this.getForEnv(this.bridgeUrl, env);
                };
                Component.prototype.getForEnv = function(item, env) {
                    if (item) {
                        if ("string" == typeof item || item instanceof RegExp) return item;
                        env || (env = this.defaultEnv);
                        if (env) return env && "object" === (void 0 === item ? "undefined" : _typeof(item)) && item[env] ? item[env] : void 0;
                    }
                };
                Component.prototype.getBridgeDomain = function(env) {
                    var bridgeDomain = this.getForEnv(this.bridgeDomain, env);
                    if (bridgeDomain) return bridgeDomain;
                    var bridgeUrl = this.getBridgeUrl(env);
                    return bridgeUrl ? (0, _src3.getDomainFromUrl)(bridgeUrl) : void 0;
                };
                Component.prototype.getUrl = function(env, props) {
                    var url = this.getForEnv(this.url, env);
                    if (url) return url;
                    if (this.buildUrl) return this.buildUrl(props);
                    throw new Error("Unable to get url");
                };
                Component.prototype.isZoidComponent = function() {
                    return (0, _window.isZoidComponentWindow)();
                };
                Component.prototype.isChild = function() {
                    return (0, _window.isZoidComponentWindow)() && (0, _window.getComponentMeta)().tag === this.tag;
                };
                Component.prototype.createError = function(message, tag) {
                    return new Error("[" + (tag || this.tag) + "] " + message);
                };
                Component.prototype.init = function(props, context, element) {
                    return new _parent.ParentComponent(this, this.getRenderContext(context, element), {
                        props: props
                    });
                };
                Component.prototype.delegate = function(source, options) {
                    return new _delegate.DelegateComponent(this, source, options);
                };
                Component.prototype.validateRenderContext = function(context, element) {
                    if (context && !this.contexts[context]) throw new Error("[" + this.tag + "] Can not render to " + context);
                    if (!element && context === _constants.CONTEXT_TYPES.IFRAME) throw new Error("[" + this.tag + "] Context type " + _constants.CONTEXT_TYPES.IFRAME + " requires an element selector");
                };
                Component.prototype.getDefaultContext = function() {
                    if (this.defaultContext) return this.defaultContext;
                    if (this.contexts[_constants.CONTEXT_TYPES.IFRAME]) return _constants.CONTEXT_TYPES.IFRAME;
                    if (this.contexts[_constants.CONTEXT_TYPES.POPUP]) return _constants.CONTEXT_TYPES.POPUP;
                    throw new Error("Can not determine default context");
                };
                Component.prototype.getRenderContext = function(context, element) {
                    context = context || this.getDefaultContext();
                    this.validateRenderContext(context, element);
                    return context;
                };
                Component.prototype.render = function(props, element) {
                    var _this4 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this4, _this4.getRenderContext(null, element), {
                            props: props
                        }).render(element);
                    });
                };
                Component.prototype.renderIframe = function(props, element) {
                    var _this5 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this5, _this5.getRenderContext(_constants.CONTEXT_TYPES.IFRAME, element), {
                            props: props
                        }).render(element);
                    });
                };
                Component.prototype.renderPopup = function(props) {
                    var _this6 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this6, _this6.getRenderContext(_constants.CONTEXT_TYPES.POPUP), {
                            props: props
                        }).render();
                    });
                };
                Component.prototype.renderTo = function(win, props, element) {
                    var _this7 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this7, _this7.getRenderContext(null, element), {
                            props: props
                        }).renderTo(win, element);
                    });
                };
                Component.prototype.renderIframeTo = function(win, props, element) {
                    var _this8 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this8, _this8.getRenderContext(_constants.CONTEXT_TYPES.IFRAME, element), {
                            props: props
                        }).renderTo(win, element);
                    });
                };
                Component.prototype.renderPopupTo = function(win, props) {
                    var _this9 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this9, _this9.getRenderContext(_constants.CONTEXT_TYPES.POPUP), {
                            props: props
                        }).renderTo(win);
                    });
                };
                Component.prototype.prerender = function(props, element) {
                    var instance = new _parent.ParentComponent(this, this.getRenderContext(null, element), {
                        props: props
                    });
                    instance.prefetch();
                    return {
                        render: function(innerProps, innerElement) {
                            innerProps && instance.updateProps(innerProps);
                            return instance.render(innerElement);
                        },
                        renderTo: function(win, innerProps, innerElement) {
                            innerProps && instance.updateProps(innerProps);
                            return instance.renderTo(win, innerElement);
                        },
                        get html() {
                            return instance.html;
                        },
                        set html(value) {
                            instance.html = value;
                        }
                    };
                };
                Component.prototype.log = function(event) {
                    var payload = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    (0, _lib.info)(this.name, event, payload);
                };
                Component.prototype.logWarning = function(event, payload) {
                    (0, _lib.warn)(this.name, event, payload);
                };
                Component.prototype.logError = function(event, payload) {
                    (0, _lib.error)(this.name, event, payload);
                };
                Component.getByTag = function(tag) {
                    return Component.components[tag];
                };
                return Component;
            }(_base.BaseComponent)).prototype, "getPropNames", [ _lib.memoize ], Object.getOwnPropertyDescriptor(_class.prototype, "getPropNames"), _class.prototype), 
            _class)).components = {};
        },
        "./src/component/component/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.getInternalProps = function() {
                return {
                    env: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.defaultEnv;
                        }
                    },
                    uid: {
                        type: "string",
                        def: function() {
                            return (0, _lib.uniqueID)();
                        },
                        queryParam: !0
                    },
                    logLevel: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.defaultLogLevel;
                        }
                    },
                    url: {
                        type: "string",
                        required: !1,
                        promise: !0,
                        sendToChild: !1
                    },
                    dimensions: {
                        type: "object",
                        required: !1
                    },
                    version: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.version;
                        }
                    },
                    timeout: {
                        type: "number",
                        required: !1,
                        sendToChild: !1
                    },
                    onDisplay: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        memoize: !0,
                        sendToChild: !1
                    },
                    onEnter: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onRender: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onClose: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        once: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onTimeout: {
                        type: "function",
                        required: !1,
                        memoize: !0,
                        promisify: !0,
                        sendToChild: !1,
                        def: function() {
                            return function(err) {
                                if (this.props.onError) return this.props.onError(err);
                                throw err;
                            };
                        }
                    },
                    onError: {
                        type: "function",
                        required: !1,
                        promisify: !0,
                        sendToChild: !0,
                        once: !0,
                        def: function() {
                            return function(err) {
                                setTimeout(function() {
                                    throw err;
                                });
                            };
                        }
                    }
                };
            };
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _lib = __webpack_require__("./src/lib/index.js");
            __webpack_require__("./src/types.js");
        },
        "./src/component/component/templates/component.jsx": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.defaultPrerenderTemplate = function(_ref) {
                var jsxDom = _ref.jsxDom;
                return jsxDom("html", null, jsxDom("head", null, jsxDom("style", null, "\n                        html, body {\n                            width: 100%;\n                            height: 100%;\n                            overflow: hidden;\n                            top: 0;\n                            left: 0;\n                            margin: 0;\n                            text-align: center;\n                        }\n\n                        .spinner {\n                            position: absolute;\n                            max-height: 60vmin;\n                            max-width: 60vmin;\n                            height: 40px;\n                            width: 40px;\n                            top: 50%;\n                            left: 50%;\n                            transform: translateX(-50%) translateY(-50%);\n                            z-index: 10;\n                        }\n\n                        .spinner .loader {\n                            height: 100%;\n                            width: 100%;\n                            box-sizing: border-box;\n                            border: 3px solid rgba(0, 0, 0, .2);\n                            border-top-color: rgba(33, 128, 192, 0.8);\n                            border-radius: 100%;\n                            animation: rotation .7s infinite linear;\n\n                        }\n\n                        @keyframes rotation {\n                            from {\n                                transform: rotate(0deg)\n                            }\n                            to {\n                                transform: rotate(359deg)\n                            }\n                        }\n                    ")), jsxDom("body", null, jsxDom("div", {
                    class: "spinner"
                }, jsxDom("div", {
                    id: "loader",
                    class: "loader"
                }))));
            };
            __webpack_require__("./src/component/parent/index.js");
        },
        "./src/component/component/templates/container.jsx": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.defaultContainerTemplate = function(_ref) {
                var id = _ref.id, tag = _ref.tag, context = _ref.context, CLASS = _ref.CLASS, outlet = _ref.outlet, jsxDom = _ref.jsxDom, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;
                return jsxDom("div", {
                    id: id,
                    class: CLASS.ZOID + " " + CLASS.ZOID + "-tag-" + tag + " " + CLASS.ZOID + "-context-" + context
                }, jsxDom("style", null, "\n                    #" + id + ", #" + id + " > ." + CLASS.OUTLET + " {\n                        width: " + width + ";\n                        height: " + height + ";\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " {\n                        display: inline-block;\n                        position: relative;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe {\n                        height: 100%;\n                        width: 100%;\n                        position: absolute;\n                        top: 0;\n                        left: 0;\n                        transition: opacity .2s ease-in-out;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe." + CLASS.VISIBLE + " {\n                        opacity: 1;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe." + CLASS.INVISIBLE + " {\n                        opacity: 0;\n                    }\n                "), outlet);
            };
            __webpack_require__("./src/component/parent/index.js");
        },
        "./src/component/component/templates/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _container = __webpack_require__("./src/component/component/templates/container.jsx");
            Object.keys(_container).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _container[key];
                    }
                });
            });
            var _component = __webpack_require__("./src/component/component/templates/component.jsx");
            Object.keys(_component).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _component[key];
                    }
                });
            });
        },
        "./src/component/component/validate.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.validate = function(options) {
                if (!options) throw new Error("Expecred options to be passed");
                if (!options.tag || !options.tag.match(/^[a-z0-9-]+$/)) throw new Error("Invalid options.tag: " + options.tag);
                !function(options) {
                    if (options.props && "object" !== _typeof(options.props)) throw new Error("Expected options.props to be an object");
                    if (options.props) for (var _iterator = Object.keys(options.props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref, prop = options.props[key];
                        if (!prop || "object" !== (void 0 === prop ? "undefined" : _typeof(prop))) throw new Error("Expected options.props." + key + " to be an object");
                        if (!prop.type) throw new Error("Expected prop.type");
                        if (-1 === _constants.PROP_TYPES_LIST.indexOf(prop.type)) throw new Error("Expected prop.type to be one of " + _constants.PROP_TYPES_LIST.join(", "));
                        if (prop.required && prop.def) throw new Error("Required prop can not have a default value");
                    }
                }(options);
                if (options.dimensions) {
                    if (options.dimensions && !(0, _lib.isPx)(options.dimensions.width) && !(0, _lib.isPerc)(options.dimensions.width)) throw new Error("Expected options.dimensions.width to be a px or % string value");
                    if (options.dimensions && !(0, _lib.isPx)(options.dimensions.height) && !(0, _lib.isPerc)(options.dimensions.height)) throw new Error("Expected options.dimensions.height to be a px or % string value");
                }
                if (options.contexts) {
                    if (options.contexts.popup) throw new Error("Popups not supported in this build -- please use the full zoid.js build");
                    for (var anyEnabled = !1, _iterator2 = Object.keys(options.contexts), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var context = _ref2;
                        if (-1 === _constants.CONTEXT_TYPES_LIST.indexOf(context)) throw new Error("Unsupported context type: " + context);
                        (options.contexts && options.contexts[context] || options.contexts && void 0 === options.contexts[context]) && (anyEnabled = !0);
                    }
                    if (!anyEnabled) throw new Error("No context type is enabled");
                }
                if (options.defaultContext) {
                    if (-1 === _constants.CONTEXT_TYPES_LIST.indexOf(options.defaultContext)) throw new Error("Unsupported context type: " + (options.defaultContext || "unknown"));
                    if (options.contexts && options.defaultContext && !options.contexts[options.defaultContext]) throw new Error("Disallowed default context type: " + (options.defaultContext || "unknown"));
                }
                if (options.url && options.buildUrl) throw new Error("Can not pass both options.url and options.buildUrl");
                if (options.defaultEnv) {
                    if ("string" != typeof options.defaultEnv) throw new TypeError("Expected options.defaultEnv to be a string");
                    if (!options.buildUrl && "object" !== _typeof(options.url)) throw new Error("Expected options.url to be an object mapping env->url");
                    if (options.url && "object" === _typeof(options.url) && !options.url[options.defaultEnv]) throw new Error("No url found for default env: " + options.defaultEnv);
                }
                if (options.url && "object" === _typeof(options.url)) {
                    if (!options.defaultEnv) throw new Error("Must pass options.defaultEnv with env->url mapping");
                    for (var _iterator3 = Object.keys(options.url), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var env = _ref3;
                        if (!options.url[env]) throw new Error("No url specified for env: " + env);
                    }
                }
                if (options.prerenderTemplate && "function" != typeof options.prerenderTemplate) throw new Error("Expected options.prerenderTemplate to be a function");
                if (options.containerTemplate && "function" != typeof options.containerTemplate) throw new Error("Expected options.containerTemplate to be a function");
            };
            var _constants = __webpack_require__("./src/constants.js"), _lib = __webpack_require__("./src/lib/index.js");
        },
        "./src/component/delegate/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.DelegateComponent = void 0;
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        "value" in descriptor && (descriptor.writable = !0);
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    protoProps && defineProperties(Constructor.prototype, protoProps);
                    staticProps && defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }(), _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _base = (__webpack_require__("./node_modules/zalgo-promise/src/index.js"), 
            __webpack_require__("./src/component/base.js")), _parent = __webpack_require__("./src/component/parent/index.js"), _drivers = __webpack_require__("./src/component/parent/drivers.js"), _lib = __webpack_require__("./src/lib/index.js");
            exports.DelegateComponent = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(DelegateComponent, _BaseComponent);
                function DelegateComponent(component, source, options) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, DelegateComponent);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    _this.component = component;
                    _this.clean.set("source", source);
                    _this.context = options.context;
                    _this.props = {
                        uid: options.props.uid,
                        dimensions: options.props.dimensions,
                        onClose: options.props.onClose,
                        onDisplay: options.props.onDisplay
                    };
                    var _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var propName = _ref;
                        _this.component.getProp(propName).allowDelegate && (_this.props[propName] = options.props[propName]);
                    }
                    _this.focus = function() {
                        return options.overrides.focus.call(_this);
                    };
                    _this.clean.register("destroyFocusOverride", function() {
                        _this.focus = _lib.noop;
                    });
                    _this.userClose = options.overrides.userClose;
                    _this.getDomain = options.overrides.getDomain;
                    _this.error = options.overrides.error;
                    _this.on = options.overrides.on;
                    var delegateOverrides = _drivers.RENDER_DRIVERS[options.context].delegateOverrides, _iterator2 = Object.keys(delegateOverrides), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var key = _ref2;
                        _this[key] = _parent.ParentComponent.prototype[key];
                    }
                    _this.childWindowName = options.childWindowName;
                    _parent.ParentComponent.prototype.registerActiveComponent.call(_this);
                    _this.watchForClose();
                    return _this;
                }
                DelegateComponent.prototype.watchForClose = function() {
                    var _this2 = this, closeWindowListener = (0, _src.onCloseWindow)(this.source, function() {
                        return _this2.destroy();
                    }, 3e3);
                    this.clean.register("destroyCloseWindowListener", closeWindowListener.cancel);
                };
                DelegateComponent.prototype.getOverrides = function(context) {
                    var delegateOverrides = _drivers.RENDER_DRIVERS[context].delegateOverrides, overrides = {}, self = this, _loop = function() {
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) return "break";
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) return "break";
                            _ref3 = _i3.value;
                        }
                        var key = _ref3;
                        overrides[key] = function() {
                            return _parent.ParentComponent.prototype[key].apply(self, arguments);
                        };
                    }, _iterator3 = Object.keys(delegateOverrides), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if ("break" === _loop()) break;
                    }
                    return overrides;
                };
                DelegateComponent.prototype.destroy = function() {
                    return this.clean.all();
                };
                _createClass(DelegateComponent, [ {
                    key: "driver",
                    get: function() {
                        if (!this.context) throw new Error("Context not set");
                        return _drivers.RENDER_DRIVERS[this.context];
                    }
                } ]);
                return DelegateComponent;
            }(_base.BaseComponent);
        },
        "./src/component/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _component = __webpack_require__("./src/component/component/index.js");
            Object.keys(_component).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _component[key];
                    }
                });
            });
            var _parent = __webpack_require__("./src/component/parent/index.js");
            Object.keys(_parent).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _parent[key];
                    }
                });
            });
            var _child = __webpack_require__("./src/component/child/index.js");
            Object.keys(_child).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _child[key];
                    }
                });
            });
        },
        "./src/component/parent/drivers.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.RENDER_DRIVERS = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _window = __webpack_require__("./src/component/window.js"), RENDER_DRIVERS = exports.RENDER_DRIVERS = {};
            RENDER_DRIVERS[_constants.CONTEXT_TYPES.IFRAME] = {
                focusable: !1,
                renderedIntoContainerTemplate: !0,
                allowResize: !0,
                openOnClick: !1,
                needsBridge: !1,
                open: function(url) {
                    var _this = this, attributes = this.component.attributes.iframe || {};
                    this.iframe = (0, _lib.iframe)({
                        url: url,
                        attributes: _extends({
                            name: this.childWindowName,
                            title: this.component.name,
                            scrolling: this.component.scrolling ? "yes" : "no"
                        }, attributes),
                        class: [ _constants.CLASS_NAMES.COMPONENT_FRAME, _constants.CLASS_NAMES.INVISIBLE ]
                    }, this.element);
                    return (0, _lib.awaitFrameWindow)(this.iframe).then(function(frameWindow) {
                        _this.window = frameWindow;
                        var detectClose = function() {
                            return _src.ZalgoPromise.try(function() {
                                return _this.props.onClose(_constants.CLOSE_REASONS.CLOSE_DETECTED);
                            }).finally(function() {
                                return _this.destroy();
                            });
                        }, iframeWatcher = (0, _lib.watchElementForClose)(_this.iframe, detectClose), elementWatcher = (0, 
                        _lib.watchElementForClose)(_this.element, detectClose);
                        _this.clean.register("destroyWindow", function() {
                            iframeWatcher.cancel();
                            elementWatcher.cancel();
                            (0, _src2.cleanUpWindow)(_this.window);
                            delete _this.window;
                            if (_this.iframe) {
                                (0, _lib.destroyElement)(_this.iframe);
                                delete _this.iframe;
                            }
                        });
                    });
                },
                openPrerender: function() {
                    var _this2 = this, attributes = this.component.attributes.iframe || {};
                    this.prerenderIframe = (0, _lib.iframe)({
                        attributes: _extends({
                            name: "__prerender__" + this.childWindowName,
                            scrolling: this.component.scrolling ? "yes" : "no"
                        }, attributes),
                        class: [ _constants.CLASS_NAMES.PRERENDER_FRAME, _constants.CLASS_NAMES.VISIBLE ]
                    }, this.element);
                    return (0, _lib.awaitFrameWindow)(this.prerenderIframe).then(function(prerenderFrameWindow) {
                        _this2.prerenderWindow = prerenderFrameWindow;
                        _this2.clean.register("destroyPrerender", function() {
                            if (_this2.prerenderIframe) {
                                (0, _lib.destroyElement)(_this2.prerenderIframe);
                                delete _this2.prerenderIframe;
                            }
                        });
                    });
                },
                switchPrerender: function() {
                    var _this3 = this;
                    (0, _lib.addClass)(this.prerenderIframe, _constants.CLASS_NAMES.INVISIBLE);
                    (0, _lib.removeClass)(this.prerenderIframe, _constants.CLASS_NAMES.VISIBLE);
                    (0, _lib.addClass)(this.iframe, _constants.CLASS_NAMES.VISIBLE);
                    (0, _lib.removeClass)(this.iframe, _constants.CLASS_NAMES.INVISIBLE);
                    setTimeout(function() {
                        _this3.prerenderIframe && (0, _lib.destroyElement)(_this3.prerenderIframe);
                    }, 1e3);
                },
                delegateOverrides: {
                    openContainer: _constants.DELEGATE.CALL_DELEGATE,
                    destroyComponent: _constants.DELEGATE.CALL_DELEGATE,
                    destroyContainer: _constants.DELEGATE.CALL_DELEGATE,
                    cancelContainerEvents: _constants.DELEGATE.CALL_DELEGATE,
                    createPrerenderTemplate: _constants.DELEGATE.CALL_DELEGATE,
                    elementReady: _constants.DELEGATE.CALL_DELEGATE,
                    showContainer: _constants.DELEGATE.CALL_DELEGATE,
                    showComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hideContainer: _constants.DELEGATE.CALL_DELEGATE,
                    hideComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hide: _constants.DELEGATE.CALL_DELEGATE,
                    show: _constants.DELEGATE.CALL_DELEGATE,
                    resize: _constants.DELEGATE.CALL_DELEGATE,
                    loadUrl: _constants.DELEGATE.CALL_DELEGATE,
                    hijackSubmit: _constants.DELEGATE.CALL_DELEGATE,
                    openPrerender: _constants.DELEGATE.CALL_DELEGATE,
                    switchPrerender: _constants.DELEGATE.CALL_DELEGATE,
                    renderTemplate: _constants.DELEGATE.CALL_ORIGINAL,
                    openContainerFrame: _constants.DELEGATE.CALL_ORIGINAL,
                    getOutlet: _constants.DELEGATE.CALL_ORIGINAL,
                    open: function(original, override) {
                        return function() {
                            var _this4 = this;
                            return override.apply(this, arguments).then(function() {
                                _this4.clean.set("window", (0, _src3.findFrameByName)((0, _window.getParentComponentWindow)(), _this4.childWindowName));
                                if (!_this4.window) throw new Error("Unable to find parent component iframe window");
                            });
                        };
                    }
                },
                resize: function(width, height) {
                    if (width) {
                        this.container.style.width = (0, _lib.toCSS)(width);
                        this.element.style.width = (0, _lib.toCSS)(width);
                    }
                    if (height) {
                        this.container.style.height = (0, _lib.toCSS)(height);
                        this.element.style.height = (0, _lib.toCSS)(height);
                    }
                },
                show: function() {
                    (0, _lib.showElement)(this.element);
                },
                hide: function() {
                    (0, _lib.hideElement)(this.element);
                },
                loadUrl: function(url) {
                    this.iframe.setAttribute("src", url);
                }
            };
            0;
        },
        "./src/component/parent/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ParentComponent = void 0;
            var _class, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        "value" in descriptor && (descriptor.writable = !0);
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    protoProps && defineProperties(Constructor.prototype, protoProps);
                    staticProps && defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }(), _client = __webpack_require__("./node_modules/beaver-logger/client/index.js"), _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _window = __webpack_require__("./src/component/window.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _error = __webpack_require__("./src/error.js"), _drivers = __webpack_require__("./src/component/parent/drivers.js"), _validate = __webpack_require__("./src/component/parent/validate.js"), _props = __webpack_require__("./src/component/parent/props.js");
            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
                var desc = {};
                Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                });
                desc.enumerable = !!desc.enumerable;
                desc.configurable = !!desc.configurable;
                ("value" in desc || desc.initializer) && (desc.writable = !0);
                desc = decorators.slice().reverse().reduce(function(desc, decorator) {
                    return decorator(target, property, desc) || desc;
                }, desc);
                if (context && void 0 !== desc.initializer) {
                    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                    desc.initializer = void 0;
                }
                if (void 0 === desc.initializer) {
                    Object.defineProperty(target, property, desc);
                    desc = null;
                }
                return desc;
            }
            _lib.global.props = _lib.global.props || {};
            _lib.global.windows = _lib.global.windows || {};
            (exports.ParentComponent = (_applyDecoratedDescriptor((_class = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(ParentComponent, _BaseComponent);
                function ParentComponent(component, context, _ref) {
                    var props = _ref.props;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ParentComponent);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    _this.component = component;
                    _this.validateParentDomain();
                    _this.context = context;
                    _this.setProps(props);
                    _this.props.logLevel && (0, _lib.setLogLevel)(_this.props.logLevel);
                    _this.childWindowName = _this.buildChildWindowName({
                        renderTo: window
                    });
                    _this.registerActiveComponent();
                    _this.component.log("construct_parent");
                    _this.watchForUnload();
                    _this.onInit = new _src3.ZalgoPromise();
                    _this.onInit.catch(function(err) {
                        return _this.error(err);
                    });
                    return _this;
                }
                ParentComponent.prototype.render = function(element) {
                    var _this2 = this, loadUrl = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return this.tryInit(function() {
                        _this2.component.log("render_" + _this2.context, {
                            context: _this2.context,
                            element: element,
                            loadUrl: (0, _lib.stringify)(loadUrl)
                        });
                        var tasks = {};
                        tasks.onRender = _this2.props.onRender();
                        tasks.getDomain = _this2.getDomain();
                        tasks.elementReady = _src3.ZalgoPromise.try(function() {
                            if (element) return _this2.elementReady(element);
                        });
                        tasks.openContainer = tasks.elementReady.then(function() {
                            return _this2.openContainer(element);
                        });
                        tasks.showContainer = tasks.openContainer.then(function() {
                            return _this2.showContainer();
                        });
                        tasks.openPrerender = tasks.openContainer.then(function() {
                            return _this2.openPrerender();
                        });
                        tasks.switchPrerender = _src3.ZalgoPromise.all([ tasks.openPrerender, _this2.onInit ]).then(function() {
                            return _this2.switchPrerender();
                        });
                        tasks.open = _this2.driver.openOnClick ? _this2.open() : tasks.openContainer.then(function() {
                            return _this2.open();
                        });
                        tasks.listen = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref2) {
                            var domain = _ref2[0];
                            _this2.listen(_this2.window, domain);
                        });
                        tasks.watchForClose = tasks.open.then(function() {
                            return _this2.watchForClose();
                        });
                        tasks.linkDomain = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref3) {
                            var domain = _ref3[0];
                            if (_src.bridge && "string" == typeof domain) return _src.bridge.linkUrl(_this2.window, domain);
                        });
                        if (!_this2.html) {
                            tasks.createPrerenderTemplate = tasks.openPrerender.then(function() {
                                return _this2.createPrerenderTemplate();
                            });
                            tasks.showComponent = tasks.createPrerenderTemplate.then(function() {
                                return _this2.showComponent();
                            });
                        }
                        tasks.openBridge = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref4) {
                            var domain = _ref4[0];
                            return _this2.openBridge("string" == typeof domain ? domain : null);
                        });
                        if (_this2.html) tasks.loadHTML = tasks.open.then(function() {
                            return _this2.loadHTML();
                        }); else if (loadUrl) {
                            tasks.buildUrl = _this2.buildUrl();
                            tasks.loadUrl = _src3.ZalgoPromise.all([ tasks.buildUrl, tasks.open, tasks.linkDomain, tasks.listen, tasks.open, tasks.openBridge, tasks.createPrerenderTemplate ]).then(function(_ref5) {
                                var url = _ref5[0];
                                return _this2.loadUrl(url);
                            });
                            tasks.runTimeout = tasks.loadUrl.then(function() {
                                return _this2.runTimeout();
                            });
                        }
                        return _src3.ZalgoPromise.hash(tasks);
                    }).then(function() {
                        return _this2.props.onEnter();
                    }).then(function() {
                        return _this2;
                    });
                };
                ParentComponent.prototype.getOutlet = function() {
                    var outlet = document.createElement("div");
                    (0, _lib.addClass)(outlet, _constants.CLASS_NAMES.OUTLET);
                    return outlet;
                };
                ParentComponent.prototype.validateParentDomain = function() {
                    var domain = (0, _src2.getDomain)();
                    if (!(0, _src2.matchDomain)(this.component.allowedParentDomains, domain)) throw new _error.RenderError("Can not be rendered by domain: " + domain);
                };
                ParentComponent.prototype.renderTo = function(win, element) {
                    var _this3 = this;
                    return this.tryInit(function() {
                        if (win === window) return _this3.render(element);
                        if (!(0, _src2.isSameTopWindow)(window, win)) throw new Error("Can only renderTo an adjacent frame");
                        if (element && "string" != typeof element) throw new Error("Element passed to renderTo must be a string selector, got " + (void 0 === element ? "undefined" : _typeof(element)) + " " + element);
                        _this3.checkAllowRenderTo(win);
                        _this3.component.log("render_" + _this3.context + "_to_win", {
                            element: (0, _lib.stringify)(element),
                            context: _this3.context
                        });
                        _this3.childWindowName = _this3.buildChildWindowName({
                            renderTo: win
                        });
                        _this3.delegate(win);
                        return _this3.render(element);
                    });
                };
                ParentComponent.prototype.prefetch = function() {
                    var _this4 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this4.html = _this4.buildUrl().then(function(url) {
                            return (0, _lib.prefetchPage)(url).then(function(html) {
                                return '\n                        <base href="' + ("" + url.split("/").slice(0, 3).join("/")) + '">\n\n                        ' + html + "\n\n                        <script>\n                            if (window.history && window.history.pushState) {\n                                window.history.pushState({}, '', '" + ("/" + url.split("/").slice(3).join("/")) + "');\n                            }\n                        <\/script>\n                    ";
                            });
                        });
                    });
                };
                ParentComponent.prototype.loadHTML = function() {
                    var _this5 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (!_this5.html) throw new Error("Html not prefetched");
                        return _this5.html.then(function(html) {
                            return (0, _lib.writeToWindow)(_this5.window, html);
                        });
                    });
                };
                ParentComponent.prototype.checkAllowRenderTo = function(win) {
                    if (!win) throw this.component.createError("Must pass window to renderTo");
                    if (!(0, _src2.isSameDomain)(win)) {
                        var origin = (0, _src2.getDomain)(), domain = this.component.getDomain(null, this.props.env);
                        if (!domain) throw new Error("Could not determine domain to allow remote render");
                        if (!(0, _src2.matchDomain)(domain, origin)) throw new Error("Can not render remotely to " + domain.toString() + " - can only render to " + origin);
                    }
                };
                ParentComponent.prototype.registerActiveComponent = function() {
                    var _this6 = this;
                    ParentComponent.activeComponents.push(this);
                    this.clean.register(function() {
                        ParentComponent.activeComponents.splice(ParentComponent.activeComponents.indexOf(_this6), 1);
                    });
                };
                ParentComponent.prototype.getComponentParentRef = function() {
                    var renderToWindow = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window;
                    if (this.context === _constants.CONTEXT_TYPES.POPUP) return {
                        ref: _constants.WINDOW_REFERENCES.OPENER
                    };
                    if (renderToWindow === window) return (0, _src2.isTop)(window) ? {
                        ref: _constants.WINDOW_REFERENCES.TOP
                    } : {
                        ref: _constants.WINDOW_REFERENCES.PARENT,
                        distance: (0, _src2.getDistanceFromTop)(window)
                    };
                    var uid = (0, _lib.uniqueID)();
                    _lib.global.windows[uid] = window;
                    this.clean.register(function() {
                        delete _lib.global.windows[uid];
                    });
                    return {
                        ref: _constants.WINDOW_REFERENCES.GLOBAL,
                        uid: uid
                    };
                };
                ParentComponent.prototype.getRenderParentRef = function() {
                    var renderToWindow = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window;
                    if (renderToWindow === window) return this.getComponentParentRef(renderToWindow);
                    var uid = (0, _lib.uniqueID)();
                    _lib.global.windows[uid] = renderToWindow;
                    this.clean.register(function() {
                        delete _lib.global.windows[uid];
                    });
                    return {
                        ref: _constants.WINDOW_REFERENCES.GLOBAL,
                        uid: uid
                    };
                };
                ParentComponent.prototype.buildChildWindowName = function() {
                    var _ref6$renderTo = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).renderTo, renderTo = void 0 === _ref6$renderTo ? window : _ref6$renderTo, sameDomain = (0, 
                    _src2.isSameDomain)(renderTo), uid = (0, _lib.uniqueID)(), tag = this.component.tag, sProps = (0, 
                    _lib.serializeFunctions)(this.getPropsForChild()), componentParent = this.getComponentParentRef(renderTo), renderParent = this.getRenderParentRef(renderTo), props = !sameDomain && !this.component.unsafeRenderTo ? {
                        type: _constants.INITIAL_PROPS.UID,
                        uid: uid
                    } : {
                        type: _constants.INITIAL_PROPS.RAW,
                        value: sProps
                    };
                    if (props.type === _constants.INITIAL_PROPS.UID) {
                        _lib.global.props[uid] = JSON.stringify(sProps);
                        this.clean.register(function() {
                            delete _lib.global.props[uid];
                        });
                    }
                    return (0, _window.buildChildWindowName)(this.component.name, this.component.version, {
                        uid: uid,
                        tag: tag,
                        componentParent: componentParent,
                        renderParent: renderParent,
                        props: props
                    });
                };
                ParentComponent.prototype.sendToParent = function(name, data) {
                    if (!(0, _window.getParentComponentWindow)()) throw new Error("Can not find parent component window to message");
                    this.component.log("send_to_parent_" + name);
                    return (0, _src.send)((0, _window.getParentComponentWindow)(), name, data, {
                        domain: (0, _window.getParentDomain)()
                    });
                };
                ParentComponent.prototype.setProps = function(props) {
                    var required = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    (0, _validate.validateProps)(this.component, props, required);
                    this.component.validate && this.component.validate(this.component, props);
                    this.props = this.props || {};
                    (0, _lib.extend)(this.props, (0, _props.normalizeProps)(this.component, this, props));
                };
                ParentComponent.prototype.buildUrl = function() {
                    var _this7 = this, propUrl = this.props.url;
                    return _src3.ZalgoPromise.all([ propUrl, (0, _props.propsToQuery)(_extends({}, this.component.props, this.component.builtinProps), this.props) ]).then(function(_ref7) {
                        var url = _ref7[0], query = _ref7[1];
                        return url && !_this7.component.getValidDomain(url) ? url : _src3.ZalgoPromise.try(function() {
                            return url || _this7.component.getUrl(_this7.props.env, _this7.props);
                        }).then(function(finalUrl) {
                            query.xcomponent = "1";
                            return (0, _lib.extendUrl)(finalUrl, {
                                query: query
                            });
                        });
                    });
                };
                ParentComponent.prototype.getDomain = function() {
                    var _this8 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this8.props.url;
                    }).then(function(url) {
                        var domain = _this8.component.getDomain(url, _this8.props.env);
                        return domain || (_this8.component.buildUrl ? _src3.ZalgoPromise.try(function() {
                            return _this8.component.buildUrl(_this8.props);
                        }).then(function(builtUrl) {
                            return _this8.component.getDomain(builtUrl, _this8.props.env);
                        }) : void 0);
                    }).then(function(domain) {
                        if (!domain) throw new Error("Could not determine domain");
                        return domain;
                    });
                };
                ParentComponent.prototype.getPropsForChild = function() {
                    var result = {}, _iterator = Object.keys(this.props), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref8 = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref8 = _i.value;
                        }
                        var key = _ref8, prop = this.component.getProp(key);
                        prop && !1 === prop.sendToChild || (result[key] = this.props[key]);
                    }
                    return result;
                };
                ParentComponent.prototype.updateProps = function(props) {
                    var _this9 = this;
                    this.setProps(props, !1);
                    return this.onInit.then(function() {
                        if (_this9.childExports) return _this9.childExports.updateProps(_this9.getPropsForChild());
                        throw new Error("Child exports were not available");
                    });
                };
                ParentComponent.prototype.openBridge = function(domain) {
                    var _this10 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_src.bridge && _this10.driver.needsBridge) {
                            var needsBridgeParams = {
                                win: _this10.window
                            };
                            domain && (needsBridgeParams.domain = domain);
                            var needsBridge = _src.bridge.needsBridge(needsBridgeParams), bridgeUrl = _this10.component.getBridgeUrl(_this10.props.env);
                            if (bridgeUrl) {
                                bridgeUrl = (0, _lib.extendUrl)(bridgeUrl, {
                                    query: {
                                        version: _this10.component.version
                                    }
                                });
                                var bridgeDomain = _this10.component.getBridgeDomain(_this10.props.env);
                                if (!bridgeDomain) throw new Error("Can not determine domain for bridge");
                                return needsBridge ? _src.bridge.openBridge(bridgeUrl, bridgeDomain).then(function(result) {
                                    if (result) return result;
                                }) : void 0;
                            }
                            if (needsBridge && domain && !_src.bridge.hasBridge(domain, domain)) throw new Error("Bridge url needed to render " + _this10.context);
                        }
                    });
                };
                ParentComponent.prototype.open = function() {
                    var _this11 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this11.component.log("open_" + _this11.context, {
                            windowName: _this11.childWindowName
                        });
                        return _this11.driver.open.call(_this11);
                    });
                };
                ParentComponent.prototype.openPrerender = function() {
                    var _this12 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this12.component.prerenderTemplate) return _this12.driver.openPrerender.call(_this12);
                    });
                };
                ParentComponent.prototype.switchPrerender = function() {
                    var _this13 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this13.prerenderWindow && _this13.driver.switchPrerender) return _this13.driver.switchPrerender.call(_this13);
                    });
                };
                ParentComponent.prototype.elementReady = function(element) {
                    return (0, _lib.elementReady)(element).then(_lib.noop);
                };
                ParentComponent.prototype.delegate = function(win) {
                    var _this14 = this;
                    this.component.log("delegate_" + this.context);
                    var props = {
                        uid: this.props.uid,
                        dimensions: this.props.dimensions,
                        onClose: this.props.onClose,
                        onDisplay: this.props.onDisplay
                    }, _iterator2 = this.component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref9 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref9 = _i2.value;
                        }
                        var propName = _ref9;
                        this.component.getProp(propName).allowDelegate && (props[propName] = this.props[propName]);
                    }
                    var delegate = (0, _src.send)(win, _constants.POST_MESSAGE.DELEGATE + "_" + this.component.name, {
                        context: this.context,
                        env: this.props.env,
                        options: {
                            context: this.context,
                            childWindowName: this.childWindowName,
                            props: props,
                            overrides: {
                                focus: function() {
                                    return _this14.focus();
                                },
                                userClose: function() {
                                    return _this14.userClose();
                                },
                                getDomain: function() {
                                    return _this14.getDomain();
                                },
                                error: function(err) {
                                    return _this14.error(err);
                                },
                                on: function(eventName, handler) {
                                    return _this14.on(eventName, handler);
                                }
                            }
                        }
                    }).then(function(_ref10) {
                        var data = _ref10.data;
                        _this14.clean.register(data.destroy);
                        return data;
                    }).catch(function(err) {
                        throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + (0, 
                        _lib.stringifyError)(err));
                    }), overrides = this.driver.delegateOverrides, _loop = function() {
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) return "break";
                            _ref11 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) return "break";
                            _ref11 = _i3.value;
                        }
                        var key = _ref11, val = overrides[key];
                        if (val === _constants.DELEGATE.CALL_ORIGINAL) return "continue";
                        var original = _this14[key];
                        _this14[key] = function() {
                            var _this15 = this, _arguments = arguments;
                            return delegate.then(function(data) {
                                var override = data.overrides[key];
                                if (val === _constants.DELEGATE.CALL_DELEGATE) return override.apply(_this15, _arguments);
                                if ("function" == typeof val) return val(original, override).apply(_this15, _arguments);
                                throw new Error("Expected delgate to be CALL_ORIGINAL, CALL_DELEGATE, or factory method");
                            });
                        };
                    };
                    var _iterator3 = Object.keys(overrides), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    _loop2: for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref11;
                        switch (_loop()) {
                          case "break":
                            break _loop2;

                          case "continue":
                            continue;
                        }
                    }
                };
                ParentComponent.prototype.watchForClose = function() {
                    var _this16 = this, closeWindowListener = (0, _src2.onCloseWindow)(this.window, function() {
                        _this16.component.log("detect_close_child");
                        return _src3.ZalgoPromise.try(function() {
                            return _this16.props.onClose(_constants.CLOSE_REASONS.CLOSE_DETECTED);
                        }).finally(function() {
                            return _this16.destroy();
                        });
                    }, 3e3);
                    this.clean.register("destroyCloseWindowListener", closeWindowListener.cancel);
                };
                ParentComponent.prototype.watchForUnload = function() {
                    var _this17 = this, onunload = (0, _lib.once)(function() {
                        _this17.component.log("navigate_away");
                        (0, _client.flush)();
                        _this17.destroyComponent();
                    }), unloadWindowListener = (0, _lib.addEventListener)(window, "unload", onunload);
                    this.clean.register("destroyUnloadWindowListener", unloadWindowListener.cancel);
                };
                ParentComponent.prototype.loadUrl = function(url) {
                    var _this18 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this18.component.log("load_url");
                        if (window.location.href.split("#")[0] === url.split("#")[0]) {
                            var _query;
                            url = (0, _lib.extendUrl)(url, {
                                query: (_query = {}, _query[(0, _lib.uniqueID)()] = "1", _query)
                            });
                        }
                        return _this18.driver.loadUrl.call(_this18, url);
                    });
                };
                ParentComponent.prototype.hijack = function(targetElement) {
                    targetElement.target = this.childWindowName;
                };
                ParentComponent.prototype.runTimeout = function() {
                    var _this19 = this, timeout = this.props.timeout;
                    if (timeout) {
                        var _id = this.timeout = setTimeout(function() {
                            _this19.component.log("timed_out", {
                                timeout: timeout.toString()
                            });
                            var error = _this19.component.createError("Loading component timed out after " + timeout + " milliseconds");
                            _this19.onInit.reject(error);
                            _this19.props.onTimeout(error);
                        }, timeout);
                        this.clean.register(function() {
                            clearTimeout(_id);
                            delete _this19.timeout;
                        });
                    }
                };
                ParentComponent.prototype.listeners = function() {
                    var _ref12;
                    return (_ref12 = {})[_constants.POST_MESSAGE.INIT] = function(source, data) {
                        this.childExports = data.exports;
                        this.onInit.resolve(this);
                        this.timeout && clearTimeout(this.timeout);
                        return {
                            props: this.getPropsForChild(),
                            context: this.context
                        };
                    }, _ref12[_constants.POST_MESSAGE.CLOSE] = function(source, data) {
                        this.close(data.reason);
                    }, _ref12[_constants.POST_MESSAGE.CHECK_CLOSE] = function() {
                        this.checkClose();
                    }, _ref12[_constants.POST_MESSAGE.RESIZE] = function(source, data) {
                        var _this20 = this;
                        return _src3.ZalgoPromise.try(function() {
                            if (_this20.driver.allowResize) return _this20.resize(data.width, data.height);
                        });
                    }, _ref12[_constants.POST_MESSAGE.ONRESIZE] = function() {
                        this.event.trigger("resize");
                    }, _ref12[_constants.POST_MESSAGE.HIDE] = function() {
                        this.hide();
                    }, _ref12[_constants.POST_MESSAGE.SHOW] = function() {
                        this.show();
                    }, _ref12[_constants.POST_MESSAGE.ERROR] = function(source, data) {
                        this.error(new Error(data.error));
                    }, _ref12;
                };
                ParentComponent.prototype.resize = function(width, height) {
                    var _this21 = this, _ref13$waitForTransit = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).waitForTransition, waitForTransition = void 0 === _ref13$waitForTransit || _ref13$waitForTransit;
                    return _src3.ZalgoPromise.try(function() {
                        _this21.component.log("resize", {
                            height: (0, _lib.stringify)(height),
                            width: (0, _lib.stringify)(width)
                        });
                        _this21.driver.resize.call(_this21, width, height);
                        if (waitForTransition && (_this21.element || _this21.iframe)) {
                            var overflow = void 0;
                            _this21.element && (overflow = (0, _lib.setOverflow)(_this21.element, "hidden"));
                            return (0, _lib.elementStoppedMoving)(_this21.element || _this21.iframe).then(function() {
                                overflow && overflow.reset();
                            });
                        }
                    });
                };
                ParentComponent.prototype.hide = function() {
                    this.container && (0, _lib.hideElement)(this.container);
                    return this.driver.hide.call(this);
                };
                ParentComponent.prototype.show = function() {
                    this.container && (0, _lib.showElement)(this.container);
                    return this.driver.show.call(this);
                };
                ParentComponent.prototype.checkClose = function() {
                    var _this22 = this, closeWindowListener = (0, _src2.onCloseWindow)(this.window, function() {
                        _this22.userClose();
                    }, 50, 500);
                    this.clean.register(closeWindowListener.cancel);
                };
                ParentComponent.prototype.userClose = function() {
                    return this.close(_constants.CLOSE_REASONS.USER_CLOSED);
                };
                ParentComponent.prototype.close = function() {
                    var _this23 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL;
                    return _src3.ZalgoPromise.try(function() {
                        _this23.component.log("close", {
                            reason: reason
                        });
                        _this23.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this23.props.onClose(reason);
                    }).then(function() {
                        return _src3.ZalgoPromise.all([ _this23.closeComponent(), _this23.closeContainer() ]);
                    }).then(function() {
                        return _this23.destroy();
                    });
                };
                ParentComponent.prototype.closeContainer = function() {
                    var _this24 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL;
                    return _src3.ZalgoPromise.try(function() {
                        _this24.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this24.props.onClose(reason);
                    }).then(function() {
                        return _src3.ZalgoPromise.all([ _this24.closeComponent(reason), _this24.hideContainer() ]);
                    }).then(function() {
                        return _this24.destroyContainer();
                    });
                };
                ParentComponent.prototype.destroyContainer = function() {
                    var _this25 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this25.clean.run("destroyContainerEvents");
                        _this25.clean.run("destroyContainerTemplate");
                    });
                };
                ParentComponent.prototype.closeComponent = function() {
                    var _this26 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL, win = this.window;
                    return _src3.ZalgoPromise.try(function() {
                        return _this26.cancelContainerEvents();
                    }).then(function() {
                        _this26.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this26.props.onClose(reason);
                    }).then(function() {
                        return _this26.hideComponent();
                    }).then(function() {
                        return _this26.destroyComponent();
                    }).then(function() {
                        _this26.childExports && _this26.context === _constants.CONTEXT_TYPES.POPUP && !(0, 
                        _src2.isWindowClosed)(win) && _this26.childExports.close().catch(_lib.noop);
                    });
                };
                ParentComponent.prototype.destroyComponent = function() {
                    this.clean.run("destroyUnloadWindowListener");
                    this.clean.run("destroyCloseWindowListener");
                    this.clean.run("destroyContainerEvents");
                    this.clean.run("destroyWindow");
                };
                ParentComponent.prototype.showContainer = function() {
                    var _this27 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this27.props.onDisplay) return _this27.props.onDisplay();
                    }).then(function() {
                        if (_this27.container) return (0, _lib.showAndAnimate)(_this27.container, _constants.ANIMATION_NAMES.SHOW_CONTAINER, _this27.clean.register);
                    });
                };
                ParentComponent.prototype.showComponent = function() {
                    var _this28 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this28.props.onDisplay) return _this28.props.onDisplay();
                    }).then(function() {
                        if (_this28.element) return (0, _lib.showAndAnimate)(_this28.element, _constants.ANIMATION_NAMES.SHOW_COMPONENT, _this28.clean.register);
                    });
                };
                ParentComponent.prototype.hideContainer = function() {
                    var _this29 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this29.container ? (0, _lib.animateAndHide)(_this29.container, _constants.ANIMATION_NAMES.HIDE_CONTAINER, _this29.clean.register) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.hideComponent = function() {
                    var _this30 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this30.element ? (0, _lib.animateAndHide)(_this30.element, _constants.ANIMATION_NAMES.HIDE_COMPONENT, _this30.clean.register) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.focus = function() {
                    if (!this.window || (0, _src2.isWindowClosed)(this.window)) throw new Error("No window to focus");
                    this.component.log("focus");
                    this.window.focus();
                };
                ParentComponent.prototype.createPrerenderTemplate = function() {
                    var _this31 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this31.component.prerenderTemplate ? _src3.ZalgoPromise.try(function() {
                            return _this31.prerenderIframe ? (0, _lib.awaitFrameLoad)(_this31.prerenderIframe).then(function() {
                                return _this31.prerenderWindow;
                            }) : _this31.prerenderWindow;
                        }).then(function(win) {
                            var doc = void 0;
                            try {
                                doc = win.document;
                            } catch (err) {
                                return;
                            }
                            try {
                                (0, _lib.writeElementToWindow)(win, _this31.renderTemplate(_this31.component.prerenderTemplate, {
                                    jsxDom: _lib.jsxDom.bind(doc),
                                    document: doc
                                }));
                            } catch (err) {}
                        }) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.renderTemplate = function(renderer) {
                    var _this32 = this, options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref14 = this.component.dimensions || {}, _ref14$width = _ref14.width, width = void 0 === _ref14$width ? _constants.DEFAULT_DIMENSIONS.WIDTH + "px" : _ref14$width, _ref14$height = _ref14.height, height = void 0 === _ref14$height ? _constants.DEFAULT_DIMENSIONS.HEIGHT + "px" : _ref14$height;
                    return renderer.call(this, _extends({
                        id: _constants.CLASS_NAMES.ZOID + "-" + this.component.tag + "-" + this.props.uid,
                        props: renderer.__xdomain__ ? null : this.props,
                        tag: this.component.tag,
                        context: this.context,
                        outlet: this.getOutlet(),
                        CLASS: _constants.CLASS_NAMES,
                        ANIMATION: _constants.ANIMATION_NAMES,
                        CONTEXT: _constants.CONTEXT_TYPES,
                        EVENT: _constants.EVENTS,
                        actions: {
                            close: function() {
                                return _this32.userClose();
                            },
                            focus: function() {
                                return _this32.focus();
                            }
                        },
                        on: function(eventName, handler) {
                            return _this32.on(eventName, handler);
                        },
                        jsxDom: _lib.jsxDom,
                        document: document,
                        dimensions: {
                            width: width,
                            height: height
                        }
                    }, options));
                };
                ParentComponent.prototype.openContainer = function(element) {
                    var _this33 = this;
                    return _src3.ZalgoPromise.try(function() {
                        var el = void 0;
                        if (!(el = element ? (0, _lib.getElement)(element) : document.body)) throw new Error("Could not find element to open container into");
                        if (_this33.component.containerTemplate) {
                            var container = _this33.renderTemplate(_this33.component.containerTemplate, {
                                container: el
                            });
                            _this33.container = container;
                            (0, _lib.hideElement)(_this33.container);
                            (0, _lib.appendChild)(el, _this33.container);
                            if (_this33.driver.renderedIntoContainerTemplate) {
                                _this33.element = _this33.getOutlet();
                                (0, _lib.hideElement)(_this33.element);
                                if (!_this33.element) throw new Error("Could not find element to render component into");
                                (0, _lib.hideElement)(_this33.element);
                            }
                            _this33.clean.register("destroyContainerTemplate", function() {
                                _this33.container && _this33.container.parentNode && _this33.container.parentNode.removeChild(_this33.container);
                                delete _this33.container;
                            });
                        } else if (_this33.driver.renderedIntoContainerTemplate) throw new Error("containerTemplate needed to render " + _this33.context);
                    });
                };
                ParentComponent.prototype.cancelContainerEvents = function() {
                    this.clean.run("destroyContainerEvents");
                };
                ParentComponent.prototype.destroy = function() {
                    var _this34 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this34.clean.hasTasks()) {
                            _this34.component.log("destroy");
                            (0, _client.flush)();
                            return _this34.clean.all();
                        }
                    });
                };
                ParentComponent.prototype.tryInit = function(method) {
                    var _this35 = this;
                    return _src3.ZalgoPromise.try(method).catch(function(err) {
                        _this35.onInit.reject(err);
                    }).then(function() {
                        return _this35.onInit;
                    });
                };
                ParentComponent.prototype.error = function(err) {
                    var _this36 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this36.handledErrors = _this36.handledErrors || [];
                        if (-1 === _this36.handledErrors.indexOf(err)) {
                            _this36.handledErrors.push(err);
                            _this36.onInit.reject(err);
                            return _this36.destroy();
                        }
                    }).then(function() {
                        if (_this36.props.onError) return _this36.props.onError(err);
                    }).catch(function(errErr) {
                        throw new Error("An error was encountered while handling error:\n\n " + (0, _lib.stringifyError)(err) + "\n\n" + (0, 
                        _lib.stringifyError)(errErr));
                    }).then(function() {
                        if (!_this36.props.onError) throw err;
                    });
                };
                ParentComponent.destroyAll = function() {
                    for (var results = []; ParentComponent.activeComponents.length; ) results.push(ParentComponent.activeComponents[0].destroy());
                    return _src3.ZalgoPromise.all(results).then(_lib.noop);
                };
                _createClass(ParentComponent, [ {
                    key: "driver",
                    get: function() {
                        if (!this.context) throw new Error("Context not set");
                        return _drivers.RENDER_DRIVERS[this.context];
                    }
                } ]);
                return ParentComponent;
            }(_base.BaseComponent)).prototype, "getOutlet", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "getOutlet"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "prefetch", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "prefetch"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "loadHTML", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "loadHTML"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "buildUrl", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "buildUrl"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "open", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "open"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "openPrerender", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "openPrerender"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "switchPrerender", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "switchPrerender"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "close", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "close"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "closeContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "closeContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "destroyContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "destroyContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "closeComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "closeComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "showContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "showContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "showComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "showComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "hideContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "hideContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "hideComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "hideComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "createPrerenderTemplate", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "createPrerenderTemplate"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "openContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "openContainer"), _class.prototype), 
            _class)).activeComponents = [];
        },
        "./src/component/parent/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.normalizeProp = normalizeProp;
            exports.normalizeProps = function(component, instance, props) {
                var result = {};
                props = props || {};
                for (var _iterator = Object.keys(props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var key = _ref;
                    -1 !== component.getPropNames().indexOf(key) ? result[key] = normalizeProp(component, instance, props, key, props[key]) : result[key] = props[key];
                }
                for (var _iterator2 = component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _key = _ref2;
                    if (!(props.hasOwnProperty(_key) || instance.props && instance.props.hasOwnProperty(_key))) {
                        var normalizedProp = normalizeProp(component, instance, props, _key, props[_key]);
                        void 0 !== normalizedProp && (result[_key] = normalizedProp);
                    }
                }
                return result;
            };
            exports.propsToQuery = function(propsDef, props) {
                var params = {};
                return _src.ZalgoPromise.all(Object.keys(props).map(function(key) {
                    var prop = propsDef[key];
                    if (prop) return _src.ZalgoPromise.resolve().then(function() {
                        var value = props[key];
                        if (value && prop.queryParam) return value;
                    }).then(function(value) {
                        if (value) return _src.ZalgoPromise.all([ function(prop, key, value) {
                            return _src.ZalgoPromise.try(function() {
                                return "function" == typeof prop.queryParam ? prop.queryParam(value) : "string" == typeof prop.queryParam ? prop.queryParam : key;
                            });
                        }(prop, key, value), function(prop, key, value) {
                            return _src.ZalgoPromise.try(function() {
                                return "function" == typeof prop.queryValue ? prop.queryValue(value) : value;
                            });
                        }(prop, 0, value) ]).then(function(_ref3) {
                            var queryParam = _ref3[0], queryValue = _ref3[1], result = void 0;
                            if ("boolean" == typeof queryValue) result = "1"; else if ("string" == typeof queryValue) result = queryValue.toString(); else {
                                if ("function" == typeof queryValue) return;
                                if ("object" === (void 0 === queryValue ? "undefined" : _typeof(queryValue)) && null !== queryValue) {
                                    if ("json" !== prop.serialization) {
                                        result = (0, _lib.dotify)(queryValue, key);
                                        for (var _iterator3 = Object.keys(result), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                            var _ref4;
                                            if (_isArray3) {
                                                if (_i3 >= _iterator3.length) break;
                                                _ref4 = _iterator3[_i3++];
                                            } else {
                                                if ((_i3 = _iterator3.next()).done) break;
                                                _ref4 = _i3.value;
                                            }
                                            var dotkey = _ref4;
                                            params[dotkey] = result[dotkey];
                                        }
                                        return;
                                    }
                                    result = JSON.stringify(queryValue);
                                } else "number" == typeof queryValue && (result = queryValue.toString());
                            }
                            params[queryParam] = result;
                        });
                    });
                })).then(function() {
                    return params;
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _lib = __webpack_require__("./src/lib/index.js");
            function normalizeProp(component, instance, props, key, value) {
                var prop = component.getProp(key), resultValue = void 0;
                !(resultValue = prop.value ? prop.value : !prop.def || props.hasOwnProperty(key) && function(value) {
                    return null !== value && void 0 !== value && "" !== value;
                }(value) ? value : prop.def.call(component, props)) && prop.alias && props[prop.alias] && (resultValue = props[prop.alias]);
                var decorated = !1;
                if (prop.decorate && null !== resultValue && void 0 !== resultValue) {
                    resultValue = prop.decorate.call(instance, resultValue, props);
                    decorated = !0;
                }
                var type = prop.type;
                if ("boolean" === type) resultValue = Boolean(resultValue); else if ("function" === type) {
                    if (!resultValue && prop.noop) {
                        resultValue = _lib.noop;
                        !decorated && prop.decorate && (resultValue = prop.decorate.call(instance, _lib.noop, props));
                    }
                    if (resultValue && "function" == typeof resultValue) {
                        resultValue = resultValue.bind(instance);
                        prop.denodeify && (resultValue = (0, _lib.denodeify)(resultValue));
                        prop.promisify && (resultValue = (0, _lib.promisify)(resultValue));
                        var original = resultValue;
                        resultValue = function() {
                            component.log("call_prop_" + key);
                            return original.apply(this, arguments);
                        };
                        prop.once && (resultValue = (0, _lib.once)(resultValue));
                        prop.memoize && (resultValue = (0, _lib.memoize)(resultValue));
                    }
                } else "string" === type || "object" === type || "number" === type && void 0 !== resultValue && (resultValue = parseInt(resultValue, 10));
                return resultValue;
            }
        },
        "./src/component/parent/validate.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.validateProp = validateProp;
            exports.validateProps = function(component, props) {
                var required = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                if ((props = props || {}).env && "object" === _typeof(component.url) && !component.url[props.env]) throw new Error("Invalid env: " + props.env);
                for (var _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var key = _ref, prop = component.getProp(key);
                    if (prop.alias && props.hasOwnProperty(prop.alias)) {
                        var value = props[prop.alias];
                        delete props[prop.alias];
                        props[key] || (props[key] = value);
                    }
                }
                for (var _iterator2 = Object.keys(props), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _key = _ref2, _prop = component.getProp(_key), _value = props[_key];
                    _prop && validateProp(_prop, _key, _value, props, required);
                }
                for (var _iterator3 = component.getPropNames(), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _key2 = _ref3, _prop2 = component.getProp(_key2), _value2 = props[_key2];
                    _prop2 && !props.hasOwnProperty(_key2) && validateProp(_prop2, _key2, _value2, props, required);
                }
            };
            function validateProp(prop, key, value, props) {
                var required = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
                if (null !== value && void 0 !== value && "" !== value) {
                    if (!value || "function" != typeof value.then || !prop.promise) {
                        if ("function" === prop.type) {
                            if ("function" != typeof value) throw new TypeError("Prop is not of type function: " + key);
                        } else if ("string" === prop.type) {
                            if ("string" != typeof value) throw new TypeError("Prop is not of type string: " + key);
                        } else if ("object" === prop.type) try {
                            JSON.stringify(value);
                        } catch (err) {
                            throw new Error("Unable to serialize prop: " + key);
                        } else if ("number" === prop.type && isNaN(parseInt(value, 10))) throw new TypeError("Prop is not a number: " + key);
                        "function" == typeof prop.validate && value && prop.validate(value, props);
                    }
                } else if (required && !1 !== prop.required && !prop.hasOwnProperty("def")) throw new Error("Prop is required: " + key);
            }
        },
        "./src/component/window.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.getParentRenderWindow = exports.getParentComponentWindow = exports.getComponentMeta = exports.isZoidComponentWindow = void 0;
            exports.buildChildWindowName = function(name, version) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                options.id = (0, _lib.uniqueID)();
                options.domain = (0, _src.getDomain)(window);
                var encodedName = normalize(name), encodedVersion = normalize(version), encodedOptions = (str = JSON.stringify(options), 
                _hiBase2.default.encode(str).replace(/\=/g, "").toLowerCase());
                var str;
                if (!encodedName) throw new Error("Invalid name: " + name + " - must contain alphanumeric characters");
                if (!encodedVersion) throw new Error("Invalid version: " + version + " - must contain alphanumeric characters");
                return [ "xcomponent", encodedName, encodedVersion, encodedOptions, "" ].join("__");
            };
            exports.getParentDomain = function() {
                return getComponentMeta().domain;
            };
            exports.getPosition = function(_ref3) {
                var width = _ref3.width, height = _ref3.height, x = 0, y = 0;
                width && (window.outerWidth ? x = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (x = Math.round((window.screen.width - width) / 2)));
                height && (window.outerHeight ? y = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (y = Math.round((window.screen.height - height) / 2)));
                return {
                    x: x,
                    y: y
                };
            };
            var obj, _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _hiBase = __webpack_require__("./node_modules/hi-base32/src/base32.js"), _hiBase2 = (obj = _hiBase) && obj.__esModule ? obj : {
                default: obj
            }, _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js");
            function normalize(str) {
                return str.replace(/^[^a-z0-9A-Z]+|[^a-z0-9A-Z]+$/g, "").replace(/[^a-z0-9A-Z]+/g, "_");
            }
            exports.isZoidComponentWindow = (0, _lib.memoize)(function() {
                return !!window.name && "xcomponent" === window.name.split("__")[0];
            });
            var getComponentMeta = exports.getComponentMeta = (0, _lib.memoize)(function() {
                if (!window.name) throw new Error("Can not get component meta without window name");
                var _window$name$split2 = window.name.split("__"), zoidcomp = _window$name$split2[0], name = _window$name$split2[1], version = _window$name$split2[2], encodedOptions = _window$name$split2[3];
                if ("xcomponent" !== zoidcomp) throw new Error("Window not rendered by zoid - got " + zoidcomp);
                var str, componentMeta = void 0;
                try {
                    componentMeta = JSON.parse((str = encodedOptions, _hiBase2.default.decode(str.toUpperCase())));
                } catch (err) {
                    throw new Error("Can not decode component-meta: " + encodedOptions + " " + (0, _lib.stringifyError)(err));
                }
                componentMeta.name = name;
                componentMeta.version = version.replace(/_/g, ".");
                return componentMeta;
            });
            function getWindowByRef(_ref) {
                var ref = _ref.ref, uid = _ref.uid, distance = _ref.distance, result = void 0;
                ref === _constants.WINDOW_REFERENCES.OPENER ? result = (0, _src.getOpener)(window) : ref === _constants.WINDOW_REFERENCES.TOP ? result = (0, 
                _src.getTop)(window) : ref === _constants.WINDOW_REFERENCES.PARENT && (result = distance ? (0, 
                _src.getNthParentFromTop)(window, distance) : (0, _src.getParent)(window));
                if (ref === _constants.WINDOW_REFERENCES.GLOBAL) {
                    var ancestor = (0, _src.getAncestor)(window);
                    if (ancestor) {
                        var _iterator = (0, _src.getAllFramesInWindow)(ancestor), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref2 = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref2 = _i.value;
                            }
                            var frame = _ref2, global = (0, _lib.globalFor)(frame);
                            if (global && global.windows && global.windows[uid]) {
                                result = global.windows[uid];
                                break;
                            }
                        }
                    }
                }
                if (!result) throw new Error("Unable to find window by ref");
                return result;
            }
            exports.getParentComponentWindow = (0, _lib.memoize)(function() {
                var componentMeta = getComponentMeta();
                if (!componentMeta) throw new Error("Can not get parent component window - window not rendered by zoid");
                return getWindowByRef(componentMeta.componentParent);
            }), exports.getParentRenderWindow = (0, _lib.memoize)(function() {
                var componentMeta = getComponentMeta();
                if (!componentMeta) throw new Error("Can not get parent component window - window not rendered by zoid");
                return getWindowByRef(componentMeta.renderParent);
            });
        },
        "./src/constants.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var ZOID = exports.ZOID = "zoid", PROP_TYPES = (exports.__ZOID__ = "__" + ZOID + "__", 
            exports.POST_MESSAGE = {
                INIT: ZOID + "_init",
                PROPS: ZOID + "_props",
                PROP_CALLBACK: ZOID + "_prop_callback",
                CLOSE: ZOID + "_close",
                CHECK_CLOSE: ZOID + "_check_close",
                REDIRECT: ZOID + "_redirect",
                RESIZE: ZOID + "_resize",
                ONRESIZE: ZOID + "_onresize",
                DELEGATE: ZOID + "_delegate",
                ALLOW_DELEGATE: ZOID + "_allow_delegate",
                ERROR: ZOID + "_error",
                HIDE: ZOID + "_hide",
                SHOW: ZOID + "_show"
            }, exports.PROP_TYPES = {
                STRING: "string",
                OBJECT: "object",
                FUNCTION: "function",
                BOOLEAN: "boolean",
                NUMBER: "number"
            }), CONTEXT_TYPES = (exports.INITIAL_PROPS = {
                RAW: "raw",
                UID: "uid"
            }, exports.WINDOW_REFERENCES = {
                OPENER: "opener",
                TOP: "top",
                PARENT: "parent",
                GLOBAL: "global"
            }, exports.PROP_TYPES_LIST = Object.keys(PROP_TYPES).map(function(key) {
                return PROP_TYPES[key];
            }), exports.CONTEXT_TYPES = {
                IFRAME: "iframe",
                POPUP: "popup"
            });
            exports.CLASS_NAMES = {
                ZOID: "" + ZOID,
                OUTLET: ZOID + "-outlet",
                COMPONENT_FRAME: ZOID + "-component-frame",
                PRERENDER_FRAME: ZOID + "-prerender-frame",
                VISIBLE: ZOID + "-visible",
                INVISIBLE: ZOID + "-invisible"
            }, exports.EVENTS = {
                CLOSE: ZOID + "-close"
            }, exports.ATTRIBUTES = {
                IFRAME_PLACEHOLDER: "data-zoid-" + ZOID + "-placeholder"
            }, exports.ANIMATION_NAMES = {
                SHOW_CONTAINER: ZOID + "-show-container",
                SHOW_COMPONENT: ZOID + "-show-component",
                HIDE_CONTAINER: ZOID + "-hide-container",
                HIDE_COMPONENT: ZOID + "-hide-component"
            }, exports.EVENT_NAMES = {
                CLICK: "click"
            }, exports.CLOSE_REASONS = {
                PARENT_CALL: "parent_call",
                CHILD_CALL: "child_call",
                CLOSE_DETECTED: "close_detected",
                USER_CLOSED: "user_closed",
                PARENT_CLOSE_DETECTED: "parent_close_detected"
            }, exports.CONTEXT_TYPES_LIST = Object.keys(CONTEXT_TYPES).map(function(key) {
                return CONTEXT_TYPES[key];
            }), exports.DELEGATE = {
                CALL_ORIGINAL: "call_original",
                CALL_DELEGATE: "call_delegate"
            }, exports.WILDCARD = "*", exports.DEFAULT_DIMENSIONS = {
                WIDTH: 300,
                HEIGHT: 150
            };
        },
        "./src/drivers/angular.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.angular = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.angular = {
                global: function() {
                    return window.angular;
                },
                register: function(component, ng) {
                    return ng.module(component.tag, []).directive((0, _lib.dasherizeToCamel)(component.tag), function() {
                        var scope = {}, _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            scope[_ref] = "=";
                        }
                        component.looseProps && (scope.props = "=");
                        return {
                            scope: scope,
                            restrict: "E",
                            controller: [ "$scope", "$element", function($scope, $element) {
                                if (component.looseProps && !$scope.props) throw new Error("For angular bindings to work, prop definitions must be passed to zoid.create");
                                component.log("instantiate_angular_component");
                                var getProps = function() {
                                    var scopeProps = void 0;
                                    if ($scope.props) scopeProps = $scope.props; else {
                                        scopeProps = {};
                                        var _iterator2 = Object.keys(scope), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                            var _ref2;
                                            if (_isArray2) {
                                                if (_i2 >= _iterator2.length) break;
                                                _ref2 = _iterator2[_i2++];
                                            } else {
                                                if ((_i2 = _iterator2.next()).done) break;
                                                _ref2 = _i2.value;
                                            }
                                            var key = _ref2;
                                            void 0 !== $scope[key] && (scopeProps[key] = $scope[key]);
                                        }
                                    }
                                    return scopeProps = (0, _lib.replaceObject)(scopeProps, {
                                        function: function(value) {
                                            return function() {
                                                var result = value.apply(this, arguments);
                                                !function() {
                                                    if ("$apply" !== $scope.$root.$$phase && "$digest" !== $scope.$root.$$phase) try {
                                                        $scope.$apply();
                                                    } catch (err) {}
                                                }();
                                                return result;
                                            };
                                        }
                                    });
                                }, parent = component.init(getProps(), null, $element[0]);
                                parent.render($element[0]);
                                $scope.$watch(function() {
                                    parent.updateProps(getProps());
                                });
                            } ]
                        };
                    });
                }
            };
        },
        "./src/drivers/angular2.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.angular2 = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _lib = __webpack_require__("./src/lib/index.js");
            exports.angular2 = {
                global: function() {},
                register: function(zoid, _ref) {
                    var AngularComponent = _ref.Component, NgModule = _ref.NgModule, ElementRef = _ref.ElementRef, NgZone = _ref.NgZone;
                    zoid.log("initializing angular2 component");
                    var getProps = function(component) {
                        return (0, _lib.replaceObject)(_extends({}, component.internalProps, component.props), {
                            function: function(value) {
                                if ("function" == typeof value) return function() {
                                    var _this = this, _arguments = arguments;
                                    return component.zone.run(function() {
                                        return value.apply(_this, _arguments);
                                    });
                                };
                            }
                        });
                    }, ComponentInstance = AngularComponent({
                        selector: zoid.tag,
                        template: "<div></div>",
                        inputs: [ "props" ]
                    }).Class({
                        constructor: [ ElementRef, NgZone, function(elementRef, zone) {
                            this.elementRef = elementRef;
                            this.zone = zone;
                        } ],
                        ngOnInit: function() {
                            var targetElement = this.elementRef.nativeElement, parent = zoid.init(getProps(this), null, targetElement);
                            parent.render(targetElement);
                            this.parent = parent;
                        },
                        ngOnChanges: function() {
                            this.parent && this.parent.updateProps(getProps(this));
                        }
                    });
                    return NgModule({
                        declarations: [ ComponentInstance ],
                        exports: [ ComponentInstance ]
                    }).Class({
                        constructor: function() {}
                    });
                }
            };
        },
        "./src/drivers/ember.js": function(module, exports, __webpack_require__) {
            "use strict";
        },
        "./src/drivers/glimmer.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            };
            exports.glimmer = {
                global: function() {},
                register: function(component, GlimmerComponent) {
                    return function(_GlimmerComponent) {
                        !function(subClass, superClass) {
                            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            });
                            superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                        }(_class, _GlimmerComponent);
                        function _class() {
                            !function(instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                            }(this, _class);
                            return function(self, call) {
                                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !call || "object" != typeof call && "function" != typeof call ? self : call;
                            }(this, _GlimmerComponent.apply(this, arguments));
                        }
                        _class.prototype.didInsertElement = function() {
                            component.render(_extends({}, this.args), this.element);
                        };
                        return _class;
                    }(GlimmerComponent);
                }
            };
        },
        "./src/drivers/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _script = __webpack_require__("./src/drivers/script.js");
            Object.keys(_script).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _script[key];
                    }
                });
            });
            var _react = __webpack_require__("./src/drivers/react.js");
            Object.keys(_react).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _react[key];
                    }
                });
            });
            var _vue = __webpack_require__("./src/drivers/vue.js");
            Object.keys(_vue).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _vue[key];
                    }
                });
            });
            var _angular = __webpack_require__("./src/drivers/angular.js");
            Object.keys(_angular).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _angular[key];
                    }
                });
            });
            var _ember = __webpack_require__("./src/drivers/ember.js");
            Object.keys(_ember).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ember[key];
                    }
                });
            });
            var _glimmer = __webpack_require__("./src/drivers/glimmer.js");
            Object.keys(_glimmer).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _glimmer[key];
                    }
                });
            });
            var _angular2 = __webpack_require__("./src/drivers/angular2.js");
            Object.keys(_angular2).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _angular2[key];
                    }
                });
            });
        },
        "./src/drivers/react.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.react = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.react = {
                global: function() {
                    if (window.React && window.ReactDOM) return {
                        React: window.React,
                        ReactDOM: window.ReactDOM
                    };
                },
                register: function(component, _ref) {
                    var React = _ref.React, ReactDOM = _ref.ReactDOM;
                    React.createClass ? component.react = React.createClass({
                        render: function() {
                            return React.createElement("div", null);
                        },
                        componentDidMount: function() {
                            component.log("instantiate_react_component");
                            var el = ReactDOM.findDOMNode(this), parent = component.init((0, _lib.extend)({}, this.props), null, el);
                            this.setState({
                                parent: parent
                            });
                            parent.render(el);
                        },
                        componentDidUpdate: function() {
                            this.state && this.state.parent && this.state.parent.updateProps((0, _lib.extend)({}, this.props));
                        }
                    }) : component.react = function(_React$Component) {
                        !function(subClass, superClass) {
                            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            });
                            superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                        }(_class, _React$Component);
                        function _class() {
                            !function(instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                            }(this, _class);
                            return function(self, call) {
                                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !call || "object" != typeof call && "function" != typeof call ? self : call;
                            }(this, _React$Component.apply(this, arguments));
                        }
                        _class.prototype.render = function() {
                            return React.createElement("div", null);
                        };
                        _class.prototype.componentDidMount = function() {
                            component.log("instantiate_react_component");
                            var el = ReactDOM.findDOMNode(this), parent = component.init((0, _lib.extend)({}, this.props), null, el);
                            this.setState({
                                parent: parent
                            });
                            parent.render(el);
                        };
                        _class.prototype.componentDidUpdate = function() {
                            this.state && this.state.parent && this.state.parent.updateProps((0, _lib.extend)({}, this.props));
                        };
                        return _class;
                    }(React.Component);
                    return component.react;
                }
            };
        },
        "./src/drivers/script.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var script = exports.script = {
                global: function() {
                    return window.document;
                },
                register: function register(component, document) {
                    function render(element) {
                        if (element && element.tagName && "script" === element.tagName.toLowerCase() && element.attributes.type && "application/x-component" === element.attributes.type.value && element.parentNode) {
                            var tag = element.getAttribute("data-component");
                            if (tag && tag === component.tag) {
                                component.log("instantiate_script_component");
                                var props = element.innerText ? eval("(" + element.innerText + ")") : {}, container = document.createElement("div");
                                if (!element.parentNode) throw new Error("Element has no parent");
                                element.parentNode.replaceChild(container, element);
                                component.render(props, container);
                            }
                        }
                    }
                    function scan() {
                        var _iterator = Array.prototype.slice.call(document.getElementsByTagName("script")), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            render(_ref);
                        }
                    }
                    scan();
                    document.addEventListener("DOMContentLoaded", scan);
                    window.addEventListener("load", scan);
                    document.addEventListener("DOMNodeInserted", function(event) {
                        render(event.target);
                    });
                }
            };
        },
        "./src/drivers/vue.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.vue = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.vue = {
                global: function() {},
                register: function(component) {
                    return {
                        render: function(createElement) {
                            return createElement("div");
                        },
                        inheritAttrs: !1,
                        mounted: function() {
                            var el = this.$el;
                            this.parent = component.init((0, _lib.extend)({}, this.$attrs), null, el);
                            this.parent.render(el);
                        },
                        beforeUpdate: function() {
                            this.parent && this.$attrs && this.parent.updateProps((0, _lib.extend)({}, this.$attrs));
                        }
                    };
                }
            };
        },
        "./src/error.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.PopupOpenError = PopupOpenError;
            exports.IntegrationError = IntegrationError;
            exports.RenderError = RenderError;
            function PopupOpenError(message) {
                this.message = message;
            }
            PopupOpenError.prototype = Object.create(Error.prototype);
            function IntegrationError(message) {
                this.message = message;
            }
            IntegrationError.prototype = Object.create(Error.prototype);
            function RenderError(message) {
                this.message = message;
            }
            RenderError.prototype = Object.create(Error.prototype);
        },
        "./src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = exports.postRobot = exports.getCurrentScriptDir = void 0;
            exports.create = function(options) {
                return new _component.Component(options);
            };
            exports.getByTag = function(tag) {
                return _component.Component.getByTag(tag);
            };
            var _lib = __webpack_require__("./src/lib/index.js");
            Object.defineProperty(exports, "getCurrentScriptDir", {
                enumerable: !0,
                get: function() {
                    return _lib.getCurrentScriptDir;
                }
            });
            exports.destroyAll = function() {
                return _parent.ParentComponent.destroyAll();
            };
            var _error = __webpack_require__("./src/error.js");
            Object.keys(_error).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _error[key];
                    }
                });
            });
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _postRobot = _interopRequireWildcard(__webpack_require__("./node_modules/post-robot/src/index.js")), _component = __webpack_require__("./src/component/index.js"), _parent = __webpack_require__("./src/component/parent/index.js"), _CONSTANTS = _interopRequireWildcard(__webpack_require__("./src/constants.js"));
            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }
            exports.postRobot = _postRobot, exports.CONSTANTS = _CONSTANTS;
        },
        "./src/lib/css.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isPerc = isPerc;
            exports.isPx = isPx;
            exports.toNum = toNum;
            exports.toPx = toPx;
            exports.toCSS = function(val) {
                if ("number" == typeof val) return toPx(val);
                return isPerc(val) ? val : toPx(val);
            };
            exports.percOf = percOf;
            exports.normalizeDimension = function(dim, max) {
                if ("number" == typeof dim) return dim;
                if (isPerc(dim)) return percOf(max, dim);
                if (isPx(dim)) return toNum(dim);
                throw new Error("Can not normalize dimension: " + dim);
            };
            function isPerc(str) {
                return "string" == typeof str && /^[0-9]+%$/.test(str);
            }
            function isPx(str) {
                return "string" == typeof str && /^[0-9]+px$/.test(str);
            }
            function toNum(val) {
                if ("number" == typeof val) return val;
                var match = val.match(/^([0-9]+)(px|%)$/);
                if (!match) throw new Error("Could not match css value from " + val);
                return parseInt(match[1], 10);
            }
            function toPx(val) {
                return toNum(val) + "px";
            }
            function percOf(num, perc) {
                return parseInt(num * toNum(perc) / 100, 10);
            }
        },
        "./src/lib/decorators.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.memoized = function(target, name, descriptor) {
                var method = descriptor.value;
                descriptor.value = function() {
                    this.__memoized__ = this.__memoized__ || {};
                    this.__memoized__.hasOwnProperty(name) || (this.__memoized__[name] = method.apply(this, arguments));
                    return this.__memoized__[name];
                };
                descriptor.value.displayName = name + ":memoized";
            };
            exports.promise = function(target, name, descriptor) {
                var method = descriptor.value;
                descriptor.value = function() {
                    return _src.ZalgoPromise.try(method, this, arguments);
                };
                descriptor.value.displayName = name + ":promisified";
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
        },
        "./src/lib/dom.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.parseQuery = exports.documentReady = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.appendChild = appendChild;
            exports.querySelectorAll = querySelectorAll;
            exports.getElementSafe = getElementSafe;
            exports.getElement = getElement;
            exports.isDocumentReady = isDocumentReady;
            exports.elementReady = function(id) {
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var name = (0, _util.stringify)(id), el = getElementSafe(id);
                    if (el) return resolve(el);
                    if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
                    var interval = setInterval(function() {
                        if (el = getElementSafe(id)) {
                            clearInterval(interval);
                            return resolve(el);
                        }
                        if (isDocumentReady()) {
                            clearInterval(interval);
                            return reject(new Error("Document is ready and element " + name + " does not exist"));
                        }
                    }, 10);
                });
            };
            exports.popup = function(url, options) {
                var params = Object.keys(options).map(function(key) {
                    if (options[key]) return key + "=" + (0, _util.stringify)(options[key]);
                }).filter(Boolean).join(","), win = void 0;
                try {
                    win = window.open(url, options.name, params, !0);
                } catch (err) {
                    throw new _error.PopupOpenError("Can not open popup window - " + (err.stack || err.message));
                }
                if ((0, _src.isWindowClosed)(win)) {
                    var err = new _error.PopupOpenError("Can not open popup window - blocked");
                    throw err;
                }
                return win;
            };
            exports.writeToWindow = writeToWindow;
            exports.writeElementToWindow = writeElementToWindow;
            exports.setStyle = setStyle;
            exports.createElement = createElement;
            exports.awaitFrameLoad = awaitFrameLoad;
            exports.awaitFrameWindow = function(frame) {
                if (frame.contentWindow) return _src2.ZalgoPromise.resolve(frame.contentWindow);
                return awaitFrameLoad(frame).then(function(loadedFrame) {
                    if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
                    return loadedFrame.contentWindow;
                });
            };
            exports.iframe = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, el = getElement(arguments[1]), attributes = options.attributes || {}, style = options.style || {}, frame = createElement("iframe", {
                    attributes: _extends({
                        frameBorder: "0",
                        allowTransparency: "true"
                    }, attributes),
                    style: _extends({
                        backgroundColor: "transparent"
                    }, style),
                    html: options.html,
                    class: options.class
                });
                awaitFrameLoad(frame);
                el.appendChild(frame);
                (options.url || window.navigator.userAgent.match(/MSIE|Edge/i)) && frame.setAttribute("src", options.url || "about:blank");
                return frame;
            };
            exports.addEventListener = function(obj, event, handler) {
                obj.addEventListener(event, handler);
                return {
                    cancel: function() {
                        obj.removeEventListener(event, handler);
                    }
                };
            };
            exports.scanForJavascript = function(str) {
                if (!str) return str;
                if (str.match(/<script|on\w+\s*=|javascript:|expression\s*\(|eval\(|new\s*Function/)) throw new Error("HTML contains potential javascript: " + str);
                return str;
            };
            exports.getQueryParam = function(name) {
                return parseQuery(window.location.search.slice(1))[name];
            };
            exports.formatQuery = formatQuery;
            exports.extendQuery = extendQuery;
            exports.extendUrl = function(url) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, query = options.query || {}, hash = options.hash || {}, originalUrl = void 0, originalHash = void 0, _url$split = url.split("#");
                originalUrl = _url$split[0];
                originalHash = _url$split[1];
                var _originalUrl$split = originalUrl.split("?");
                originalUrl = _originalUrl$split[0];
                var queryString = extendQuery(_originalUrl$split[1], query), hashString = extendQuery(originalHash, hash);
                queryString && (originalUrl = originalUrl + "?" + queryString);
                hashString && (originalUrl = originalUrl + "#" + hashString);
                return originalUrl;
            };
            exports.elementStoppedMoving = function(element) {
                var timeout = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var el = getElement(element), start = el.getBoundingClientRect(), interval = void 0, timer = void 0;
                    interval = setInterval(function() {
                        var end = el.getBoundingClientRect();
                        if (start.top === end.top && start.bottom === end.bottom && start.left === end.left && start.right === end.right && start.width === end.width && start.height === end.height) {
                            clearTimeout(timer);
                            clearInterval(interval);
                            return resolve();
                        }
                        start = end;
                    }, 50);
                    timer = setTimeout(function() {
                        clearInterval(interval);
                        reject(new Error("Timed out waiting for element to stop animating after " + timeout + "ms"));
                    }, timeout);
                });
            };
            exports.getCurrentDimensions = getCurrentDimensions;
            exports.changeStyle = function(el, styles) {
                return new _src2.ZalgoPromise(function(resolve) {
                    for (var _iterator3 = Object.keys(styles), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var key = _ref3;
                        el.style[key] = styles[key];
                    }
                    setTimeout(resolve, 1);
                });
            };
            exports.setOverflow = function(el) {
                var value = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "auto", _el$style = el.style, overflow = _el$style.overflow, overflowX = _el$style.overflowX, overflowY = _el$style.overflowY;
                el.style.overflow = el.style.overflowX = el.style.overflowY = value;
                return {
                    reset: function() {
                        el.style.overflow = overflow;
                        el.style.overflowX = overflowX;
                        el.style.overflowY = overflowY;
                    }
                };
            };
            exports.trackDimensions = trackDimensions;
            exports.onDimensionsChange = function(el, _ref6) {
                var _ref6$width = _ref6.width, width = void 0 === _ref6$width || _ref6$width, _ref6$height = _ref6.height, height = void 0 === _ref6$height || _ref6$height, _ref6$delay = _ref6.delay, delay = void 0 === _ref6$delay ? 50 : _ref6$delay, _ref6$threshold = _ref6.threshold, threshold = void 0 === _ref6$threshold ? 0 : _ref6$threshold;
                return new _src2.ZalgoPromise(function(resolve) {
                    var tracker = trackDimensions(el, {
                        width: width,
                        height: height,
                        threshold: threshold
                    }), interval = void 0, resolver = (0, _fn.debounce)(function(dimensions) {
                        clearInterval(interval);
                        return resolve(dimensions);
                    }, 4 * delay);
                    interval = setInterval(function() {
                        var _tracker$check = tracker.check(), changed = _tracker$check.changed, dimensions = _tracker$check.dimensions;
                        if (changed) {
                            tracker.reset();
                            return resolver(dimensions);
                        }
                    }, delay);
                    window.addEventListener("resize", function onWindowResize() {
                        var _tracker$check2 = tracker.check(), changed = _tracker$check2.changed, dimensions = _tracker$check2.dimensions;
                        if (changed) {
                            tracker.reset();
                            window.removeEventListener("resize", onWindowResize);
                            resolver(dimensions);
                        }
                    });
                });
            };
            exports.dimensionsMatchViewport = function(el, _ref7) {
                var width = _ref7.width, height = _ref7.height, dimensions = getCurrentDimensions(el);
                if (width && dimensions.width !== window.innerWidth) return !1;
                if (height && dimensions.height !== window.innerHeight) return !1;
                return !0;
            };
            exports.bindEvents = bindEvents;
            exports.setVendorCSS = setVendorCSS;
            exports.animate = animate;
            exports.makeElementVisible = function(element) {
                element.style.setProperty("visibility", "");
            };
            exports.makeElementInvisible = function(element) {
                element.style.setProperty("visibility", STYLE.VISIBILITY.HIDDEN, STYLE.IMPORTANT);
            };
            exports.showElement = showElement;
            exports.hideElement = hideElement;
            exports.destroyElement = function(element) {
                element.parentNode && element.parentNode.removeChild(element);
            };
            exports.showAndAnimate = function(element, name, clean) {
                var animation = animate(element, name, clean);
                showElement(element);
                return animation;
            };
            exports.animateAndHide = function(element, name, clean) {
                return animate(element, name, clean).then(function() {
                    hideElement(element);
                });
            };
            exports.addClass = function(element, name) {
                element.classList ? element.classList.add(name) : -1 === element.className.split(/\s+/).indexOf(name) && (element.className += " " + name);
            };
            exports.removeClass = function(element, name) {
                element.classList ? element.classList.remove(name) : -1 !== element.className.split(/\s+/).indexOf(name) && (element.className = element.className.replace(name, ""));
            };
            exports.getCurrentScriptDir = function() {
                console.warn("Do not use zoid.getCurrentScriptDir() in production -- browser support is limited");
                if (document.currentScript) return document.currentScript.src.split("/").slice(0, -1).join("/");
                return ".";
            };
            exports.getElementName = function(element) {
                if ("string" == typeof element) return element;
                if (!element || !element.tagName) return "<unknown>";
                var name = element.tagName.toLowerCase();
                element.id ? name += "#" + element.id : element.className && (name += "." + element.className.split(" ").join("."));
                return name;
            };
            exports.isElementClosed = isElementClosed;
            exports.watchElementForClose = function(element, handler) {
                handler = (0, _fn.once)(handler);
                var interval = void 0;
                isElementClosed(element) ? handler() : interval = (0, _util.safeInterval)(function() {
                    if (isElementClosed(element)) {
                        interval.cancel();
                        handler();
                    }
                }, 50);
                return {
                    cancel: function() {
                        interval && interval.cancel();
                    }
                };
            };
            exports.getHttpType = getHttpType;
            exports.getHTML = getHTML;
            exports.getCSS = function(url) {
                return getHttpType("text/css", url);
            };
            exports.getScript = function(url) {
                return getHttpType("*/*", url);
            };
            exports.prefetchPage = function(url) {
                return getHTML(url);
            };
            exports.fixScripts = fixScripts;
            exports.jsxDom = function(name, props, content) {
                name = name.toLowerCase();
                var doc = this && this.createElement ? this : window.document, el = doc.createElement(name);
                for (var prop in props) if (prop in JSX_EVENTS) el.addEventListener(JSX_EVENTS[prop], props[prop]); else if ("innerHTML" === prop) {
                    el.innerHTML = props[prop];
                    fixScripts(el, doc);
                } else el.setAttribute(prop, props[prop]);
                if ("style" === name) {
                    if ("string" != typeof content) throw new TypeError("Expected " + name + " tag content to be string, got " + (void 0 === content ? "undefined" : _typeof(content)));
                    if (arguments.length > 3) throw new Error("Expected only text content for " + name + " tag");
                    setStyle(el, content, doc);
                } else if ("iframe" === name) {
                    if (arguments.length > 3) throw new Error("Expected only single child node for iframe");
                    el.addEventListener("load", function() {
                        var win = el.contentWindow;
                        if (!win) throw new Error("Expected frame to have contentWindow");
                        "string" == typeof content ? writeToWindow(win, content) : writeElementToWindow(win, content);
                    });
                } else if ("script" === name) {
                    if ("string" != typeof content) throw new TypeError("Expected " + name + " tag content to be string, got " + (void 0 === content ? "undefined" : _typeof(content)));
                    if (arguments.length > 3) throw new Error("Expected only text content for " + name + " tag");
                    el.text = content;
                } else for (var i = 2; i < arguments.length; i++) if ("string" == typeof arguments[i]) {
                    var textNode = document.createTextNode(arguments[i]);
                    appendChild(el, textNode);
                } else appendChild(el, arguments[i]);
                return el;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _error = __webpack_require__("./src/error.js"), _fn = __webpack_require__("./src/lib/fn.js"), _util = __webpack_require__("./src/lib/util.js");
            function appendChild(container, child) {
                container.appendChild(child);
            }
            function querySelectorAll(el, selector) {
                return Array.prototype.slice.call(el.querySelectorAll(selector));
            }
            function getElementSafe(id) {
                if (function(element) {
                    return element instanceof window.Element || null !== element && "object" === (void 0 === element ? "undefined" : _typeof(element)) && 1 === element.nodeType && "object" === _typeof(element.style) && "object" === _typeof(element.ownerDocument);
                }(id)) return id;
                if ("string" == typeof id) {
                    var element = document.getElementById(id);
                    if (element) return element;
                    document.querySelector && (element = document.querySelector(id));
                    if (element) return element;
                }
            }
            function getElement(id) {
                var element = getElementSafe(id);
                if (element) return element;
                throw new Error("Can not find element: " + (0, _util.stringify)(id));
            }
            exports.documentReady = new _src2.ZalgoPromise(function(resolve) {
                if ("complete" === window.document.readyState) return resolve(window.document);
                var interval = setInterval(function() {
                    if ("complete" === window.document.readyState) {
                        clearInterval(interval);
                        return resolve(window.document);
                    }
                }, 10);
            });
            function isDocumentReady() {
                return "complete" === window.document.readyState;
            }
            function writeToWindow(win, html) {
                try {
                    win.document.open();
                    win.document.write(html);
                    win.document.close();
                } catch (err) {
                    try {
                        win.location = "javascript: document.open(); document.write(" + JSON.stringify(html) + "); document.close();";
                    } catch (err2) {}
                }
            }
            function writeElementToWindow(win, el) {
                var tag = el.tagName.toLowerCase();
                if ("html" !== tag) throw new Error("Expected element to be html, got " + tag);
                for (var documentElement = win.document.documentElement; documentElement.children && documentElement.children.length; ) documentElement.removeChild(documentElement.children[0]);
                for (;el.children.length; ) documentElement.appendChild(el.children[0]);
            }
            function setStyle(el, styleText) {
                var doc = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.document;
                el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
            }
            function createElement() {
                var tag = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div", options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, container = arguments[2];
                tag = tag.toLowerCase();
                var element = document.createElement(tag);
                options.style && (0, _util.extend)(element.style, options.style);
                options.class && (element.className = options.class.join(" "));
                if (options.attributes) {
                    var _iterator = Object.keys(options.attributes), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref;
                        element.setAttribute(key, options.attributes[key]);
                    }
                }
                options.styleSheet && setStyle(element, options.styleSheet);
                container && appendChild(container, element);
                if (options.html) if ("iframe" === tag) {
                    if (!container || !element.contentWindow) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
                    writeToWindow(element.contentWindow, options.html);
                } else element.innerHTML = options.html;
                return element;
            }
            var awaitFrameLoadPromises = new _src3.WeakMap();
            function awaitFrameLoad(frame) {
                if (awaitFrameLoadPromises.has(frame)) {
                    var _promise = awaitFrameLoadPromises.get(frame);
                    if (_promise) return _promise;
                }
                var promise = new _src2.ZalgoPromise(function(resolve, reject) {
                    frame.addEventListener("load", function() {
                        (0, _src.linkFrameWindow)(frame);
                        resolve(frame);
                    });
                    frame.addEventListener("error", function(err) {
                        frame.contentWindow ? resolve(frame) : reject(err);
                    });
                });
                awaitFrameLoadPromises.set(frame, promise);
                return promise;
            }
            var parseQuery = exports.parseQuery = (0, _fn.memoize)(function(queryString) {
                var params = {};
                if (!queryString) return params;
                if (-1 === queryString.indexOf("=")) throw new Error("Can not parse query string params: " + queryString);
                var _iterator2 = queryString.split("&"), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var pair = _ref2;
                    (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
                }
                return params;
            });
            function formatQuery() {
                var obj = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return Object.keys(obj).filter(function(key) {
                    return "string" == typeof obj[key];
                }).map(function(key) {
                    return (0, _util.urlEncode)(key) + "=" + (0, _util.urlEncode)(obj[key]);
                }).join("&");
            }
            function extendQuery(originalQuery) {
                var props = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return props && Object.keys(props).length ? formatQuery(_extends({}, parseQuery(originalQuery), props)) : originalQuery;
            }
            function getCurrentDimensions(el) {
                return {
                    width: el.offsetWidth,
                    height: el.offsetHeight
                };
            }
            function trackDimensions(el, _ref5) {
                var _ref5$width = _ref5.width, width = void 0 === _ref5$width || _ref5$width, _ref5$height = _ref5.height, height = void 0 === _ref5$height || _ref5$height, _ref5$threshold = _ref5.threshold, threshold = void 0 === _ref5$threshold ? 0 : _ref5$threshold, currentDimensions = getCurrentDimensions(el);
                return {
                    check: function() {
                        var newDimensions = getCurrentDimensions(el);
                        return {
                            changed: function(one, two, _ref4) {
                                var _ref4$width = _ref4.width, width = void 0 === _ref4$width || _ref4$width, _ref4$height = _ref4.height, height = void 0 === _ref4$height || _ref4$height, _ref4$threshold = _ref4.threshold, threshold = void 0 === _ref4$threshold ? 0 : _ref4$threshold;
                                return !!(width && Math.abs(one.width - two.width) > threshold) || !!(height && Math.abs(one.height - two.height) > threshold);
                            }(currentDimensions, newDimensions, {
                                width: width,
                                height: height,
                                threshold: threshold
                            }),
                            dimensions: newDimensions
                        };
                    },
                    reset: function() {
                        currentDimensions = getCurrentDimensions(el);
                    }
                };
            }
            function bindEvents(element, eventNames, handler) {
                handler = (0, _fn.once)(handler);
                var _iterator4 = eventNames, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref8 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref8 = _i4.value;
                    }
                    var eventName = _ref8;
                    element.addEventListener(eventName, handler);
                }
                return {
                    cancel: (0, _fn.once)(function() {
                        var _iterator5 = eventNames, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref9;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref9 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref9 = _i5.value;
                            }
                            var eventName = _ref9;
                            element.removeEventListener(eventName, handler);
                        }
                    })
                };
            }
            var VENDOR_PREFIXES = [ "webkit", "moz", "ms", "o" ];
            function setVendorCSS(element, name, value) {
                element.style[name] = value;
                var capitalizedName = (0, _util.capitalizeFirstLetter)(name), _iterator6 = VENDOR_PREFIXES, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref10 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref10 = _i6.value;
                    }
                    var prefix = _ref10;
                    element.style["" + prefix + capitalizedName] = value;
                }
            }
            var CSSRule = window.CSSRule, KEYFRAMES_RULE = CSSRule.KEYFRAMES_RULE || CSSRule.WEBKIT_KEYFRAMES_RULE || CSSRule.MOZ_KEYFRAMES_RULE || CSSRule.O_KEYFRAMES_RULE || CSSRule.MS_KEYFRAMES_RULE;
            var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart", "oAnimationStart", "MSAnimationStart" ], ANIMATION_END_EVENTS = [ "animationend", "webkitAnimationEnd", "oAnimationEnd", "MSAnimationEnd" ];
            function animate(element, name, clean) {
                var timeout = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var el = getElement(element);
                    if (!el || !function(element, name) {
                        var stylesheets = element.ownerDocument.styleSheets;
                        try {
                            for (var i = 0; i < stylesheets.length; i++) {
                                var cssRules = stylesheets[i].cssRules;
                                if (cssRules) for (var j = 0; j < cssRules.length; j++) {
                                    var cssRule = cssRules[j];
                                    if (cssRule && cssRule.type === KEYFRAMES_RULE && cssRule.name === name) return !0;
                                }
                            }
                        } catch (err) {
                            return !1;
                        }
                        return !1;
                    }(el, name)) return resolve();
                    var hasStarted = !1, startTimeout = void 0, endTimeout = void 0, startEvent = void 0, endEvent = void 0;
                    function cleanUp() {
                        setVendorCSS(el, "animationName", "");
                        clearTimeout(startTimeout);
                        clearTimeout(endTimeout);
                        startEvent.cancel();
                        endEvent.cancel();
                    }
                    startEvent = bindEvents(el, ANIMATION_START_EVENTS, function(event) {
                        if (event.target === el && event.animationName === name) {
                            clearTimeout(startTimeout);
                            event.stopPropagation();
                            startEvent.cancel();
                            hasStarted = !0;
                            endTimeout = setTimeout(function() {
                                cleanUp();
                                resolve();
                            }, timeout);
                        }
                    });
                    endEvent = bindEvents(el, ANIMATION_END_EVENTS, function(event) {
                        if (event.target === el && event.animationName === name) {
                            cleanUp();
                            return "string" == typeof event.animationName && event.animationName !== name ? reject("Expected animation name to be " + name + ", found " + event.animationName) : resolve();
                        }
                    });
                    setVendorCSS(el, "animationName", name);
                    startTimeout = setTimeout(function() {
                        if (!hasStarted) {
                            cleanUp();
                            return resolve();
                        }
                    }, 200);
                    clean && clean(cleanUp);
                });
            }
            var STYLE = {
                DISPLAY: {
                    NONE: "none",
                    BLOCK: "block"
                },
                VISIBILITY: {
                    VISIBLE: "visible",
                    HIDDEN: "hidden"
                },
                IMPORTANT: "important"
            };
            function showElement(element) {
                element.style.setProperty("display", "");
            }
            function hideElement(element) {
                element.style.setProperty("display", STYLE.DISPLAY.NONE, STYLE.IMPORTANT);
            }
            function isElementClosed(el) {
                return !el || !el.parentNode;
            }
            function getHttpType(contentType, url) {
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var req = new window.XMLHttpRequest();
                    req.open("GET", url);
                    req.setRequestHeader("Accept", contentType);
                    req.send(null);
                    req.onload = function() {
                        resolve(req.responseText);
                    };
                    req.onerror = function() {
                        return reject(new Error("prefetch failed"));
                    };
                });
            }
            function getHTML(url) {
                return getHttpType("text/html", url);
            }
            var JSX_EVENTS = {
                onClick: "click"
            };
            function fixScripts(el) {
                var doc = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : window.document, _iterator7 = querySelectorAll(el, "script"), _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref11;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref11 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref11 = _i7.value;
                    }
                    var script = _ref11, newScript = doc.createElement("script");
                    newScript.text = script.textContent;
                    script.parentNode.replaceChild(newScript, script);
                }
            }
        },
        "./src/lib/fn.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.noop = function() {};
            exports.once = function(method) {
                var called = !1, result = void 0;
                return function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    if (called) return result;
                    called = !0;
                    return result = method.apply(this, arguments);
                };
            };
            exports.memoize = function(method) {
                var results = {};
                return function() {
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    var cacheKey = void 0;
                    try {
                        cacheKey = JSON.stringify(Array.prototype.slice.call(arguments), function(key, val) {
                            return "function" == typeof val ? "zoid:memoize[" + (0, _util.getObjectID)(val) + "]" : val;
                        });
                    } catch (err) {
                        throw new Error("Arguments not serializable -- can not be used to memoize");
                    }
                    results.hasOwnProperty(cacheKey) || (results[cacheKey] = method.apply(this, arguments));
                    return results[cacheKey];
                };
            };
            exports.debounce = function(method) {
                var time = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100, timeout = void 0;
                return function() {
                    var _this = this, _arguments = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(function() {
                        return method.apply(_this, _arguments);
                    }, time);
                };
            };
            exports.serializeFunctions = function(obj) {
                return (0, _util.replaceObject)(obj, {
                    function: function() {
                        return {
                            __type__: "__function__"
                        };
                    }
                });
            };
            exports.deserializeFunctions = function(obj, handler) {
                return (0, _util.replaceObject)(obj, {
                    object: function(value, key, fullKey) {
                        if (value && "__function__" === value.__type__) return function() {
                            return handler({
                                key: key,
                                fullKey: fullKey,
                                self: this,
                                args: arguments
                            });
                        };
                    }
                });
            };
            var _util = __webpack_require__("./src/lib/util.js");
        },
        "./src/lib/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.global = void 0;
            exports.globalFor = globalFor;
            exports.localGlobal = localGlobal;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _constants = __webpack_require__("./src/constants.js");
            function globalFor(win) {
                if ((0, _src.isSameDomain)(win)) {
                    win[_constants.__ZOID__] || (win[_constants.__ZOID__] = {});
                    return win[_constants.__ZOID__];
                }
            }
            function localGlobal() {
                var global = globalFor(window);
                if (!global) throw new Error("Could not get local global");
                return global;
            }
            exports.global = localGlobal();
        },
        "./src/lib/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _dom = __webpack_require__("./src/lib/dom.js");
            Object.keys(_dom).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _dom[key];
                    }
                });
            });
            var _fn = __webpack_require__("./src/lib/fn.js");
            Object.keys(_fn).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _fn[key];
                    }
                });
            });
            var _promise = __webpack_require__("./src/lib/promise.js");
            Object.keys(_promise).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _promise[key];
                    }
                });
            });
            var _util = __webpack_require__("./src/lib/util.js");
            Object.keys(_util).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _util[key];
                    }
                });
            });
            var _css = __webpack_require__("./src/lib/css.js");
            Object.keys(_css).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _css[key];
                    }
                });
            });
            var _decorators = __webpack_require__("./src/lib/decorators.js");
            Object.keys(_decorators).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _decorators[key];
                    }
                });
            });
            var _logger = __webpack_require__("./src/lib/logger.js");
            Object.keys(_logger).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _logger[key];
                    }
                });
            });
            var _global = __webpack_require__("./src/lib/global.js");
            Object.keys(_global).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _global[key];
                    }
                });
            });
        },
        "./src/lib/logger.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.setLogLevel = function(logLevel) {
                if (-1 === _client.logLevels.indexOf(logLevel)) throw new Error("Invalid logLevel: " + logLevel);
                _client.config.logLevel = logLevel;
                _src.CONFIG.LOG_LEVEL = logLevel;
                window.LOG_LEVEL = logLevel;
            };
            exports.info = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.info)("xc_" + name + "_" + event, payload);
            };
            exports.warn = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.warn)("xc_" + name + "_" + event, payload);
            };
            exports.error = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.error)("xc_" + name + "_" + event, payload);
            };
            var _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _client = __webpack_require__("./node_modules/beaver-logger/client/index.js");
        },
        "./src/lib/promise.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.denodeify = function(method) {
                return function() {
                    var self = this, args = Array.prototype.slice.call(arguments);
                    return args.length >= method.length ? _src.ZalgoPromise.resolve(method.apply(self, args)) : new _src.ZalgoPromise(function(resolve, reject) {
                        args.push(function(err, result) {
                            if (err && !(err instanceof Error)) throw new Error("Passed non-Error object in callback: [ " + err + " ] -- callbacks should either be called with callback(new Error(...)) or callback(null, result).");
                            return err ? reject(err) : resolve(result);
                        });
                        method.apply(self, args);
                    });
                };
            };
            exports.promisify = function(method) {
                return function() {
                    var _this = this, _arguments = arguments;
                    return _src.ZalgoPromise.try(function() {
                        return method.apply(_this, _arguments);
                    });
                };
            };
            exports.delay = function() {
                var time = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                return new _src.ZalgoPromise(function(resolve) {
                    setTimeout(resolve, time);
                });
            };
            exports.cycle = function cycle(method) {
                return _src.ZalgoPromise.try(method).then(function() {
                    return cycle(method);
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
        },
        "./src/lib/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.urlEncode = function(str) {
                return str.replace(/\?/g, "%3F").replace(/&/g, "%26").replace(/#/g, "%23").replace(/\+/g, "%2B");
            };
            exports.camelToDasherize = function(string) {
                return string.replace(/([A-Z])/g, function(g) {
                    return "-" + g.toLowerCase();
                });
            };
            exports.dasherizeToCamel = function(string) {
                return string.replace(/-([a-z])/g, function(g) {
                    return g[1].toUpperCase();
                });
            };
            exports.extend = function(obj, source) {
                if (!source) return obj;
                for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
                return obj;
            };
            exports.values = function(obj) {
                var results = [];
                for (var key in obj) obj.hasOwnProperty(key) && results.push(obj[key]);
                return results;
            };
            exports.uniqueID = uniqueID;
            exports.stringifyWithFunctions = function(obj) {
                return JSON.stringify(obj, function(key, val) {
                    return "function" == typeof val ? val.toString() : val;
                });
            };
            exports.safeGet = function(obj, prop) {
                var result = void 0;
                try {
                    result = obj[prop];
                } catch (err) {}
                return result;
            };
            exports.capitalizeFirstLetter = function(string) {
                return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
            };
            exports.get = function(item, path, def) {
                if (!path) return def;
                for (var pathParts = path.split("."), i = 0; i < pathParts.length; i++) {
                    if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item) return def;
                    item = item[pathParts[i]];
                }
                return void 0 === item ? def : item;
            };
            exports.safeInterval = safeInterval;
            exports.safeTimeout = function(method, time) {
                var interval = safeInterval(function() {
                    if ((time -= 100) <= 0) {
                        interval.cancel();
                        method();
                    }
                }, 100);
            };
            exports.each = function(item, callback) {
                if (!item) return;
                if (Array.isArray(item)) for (var len = item.length, i = 0; i < len; i++) callback(item[i], i); else if ("object" === (void 0 === item ? "undefined" : _typeof(item))) for (var keys = Object.keys(item), _len = keys.length, _i = 0; _i < _len; _i++) {
                    var key = keys[_i];
                    callback(item[key], key);
                }
            };
            exports.replaceObject = function replaceObject(item, replacers) {
                var fullKey = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                if (Array.isArray(item)) {
                    var _ret = function() {
                        for (var length = item.length, result = [], _loop = function(i) {
                            Object.defineProperty(result, i, {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    var itemKey = fullKey ? fullKey + "." + i : "" + i, child = item[i], type = void 0 === child ? "undefined" : _typeof(child), replacer = replacers[type];
                                    if (replacer) {
                                        var replaced = replacer(child, i, itemKey);
                                        if (void 0 !== replaced) {
                                            result[i] = replaced;
                                            return result[i];
                                        }
                                    }
                                    if ("object" === (void 0 === child ? "undefined" : _typeof(child)) && null !== child) {
                                        result[i] = replaceObject(child, replacers, itemKey);
                                        return result[i];
                                    }
                                    result[i] = child;
                                    return result[i];
                                },
                                set: function(value) {
                                    delete result[i];
                                    result[i] = value;
                                }
                            });
                        }, i = 0; i < length; i++) _loop(i);
                        return {
                            v: result
                        };
                    }();
                    if ("object" === (void 0 === _ret ? "undefined" : _typeof(_ret))) return _ret.v;
                } else {
                    if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item) throw new Error("Pass an object or array");
                    var _ret3 = function() {
                        var result = {}, _loop2 = function(key) {
                            if (!item.hasOwnProperty(key)) return "continue";
                            Object.defineProperty(result, key, {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    var itemKey = fullKey ? fullKey + "." + key : "" + key, child = item[key], type = void 0 === child ? "undefined" : _typeof(child), replacer = replacers[type];
                                    if (replacer) {
                                        var replaced = replacer(child, key, itemKey);
                                        if (void 0 !== replaced) {
                                            result[key] = replaced;
                                            return result[key];
                                        }
                                    }
                                    if ("object" === (void 0 === child ? "undefined" : _typeof(child)) && null !== child) {
                                        result[key] = replaceObject(child, replacers, itemKey);
                                        return result[key];
                                    }
                                    result[key] = child;
                                    return result[key];
                                },
                                set: function(value) {
                                    delete result[key];
                                    result[key] = value;
                                }
                            });
                        };
                        for (var key in item) _loop2(key);
                        return {
                            v: result
                        };
                    }();
                    if ("object" === (void 0 === _ret3 ? "undefined" : _typeof(_ret3))) return _ret3.v;
                }
            };
            exports.copyProp = function(source, target, name, def) {
                if (source.hasOwnProperty(name)) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, name);
                    Object.defineProperty(target, name, descriptor);
                } else target[name] = def;
            };
            exports.dotify = function dotify(obj) {
                var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                var newobj = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                prefix = prefix ? prefix + "." : prefix;
                for (var key in obj) void 0 !== obj[key] && null !== obj[key] && "function" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every(function(val) {
                    return "object" !== (void 0 === val ? "undefined" : _typeof(val));
                }) ? newobj["" + prefix + key] = obj[key].join(",") : obj[key] && "object" === _typeof(obj[key]) ? newobj = dotify(obj[key], "" + prefix + key, newobj) : newobj["" + prefix + key] = obj[key].toString());
                return newobj;
            };
            exports.getObjectID = function(obj) {
                if (null === obj || void 0 === obj || "object" !== (void 0 === obj ? "undefined" : _typeof(obj)) && "function" != typeof obj) throw new Error("Invalid object");
                var uid = objectIDs.get(obj);
                if (!uid) {
                    uid = (void 0 === obj ? "undefined" : _typeof(obj)) + ":" + uniqueID();
                    objectIDs.set(obj, uid);
                }
                return uid;
            };
            exports.regex = regex;
            exports.regexAll = function(pattern, string) {
                var matches = [], start = 0;
                for (;;) {
                    var match = regex(pattern, string, start);
                    if (!match) break;
                    matches.push(match);
                    start = match.end;
                }
                return matches;
            };
            exports.count = function(str, substr) {
                var startIndex = 0, itemCount = 0;
                for (;;) {
                    var index = str.indexOf(substr, startIndex);
                    if (-1 === index) break;
                    startIndex = index;
                    itemCount += 1;
                }
                return itemCount;
            };
            exports.stringify = stringify;
            exports.stringifyError = function(err) {
                if (err) {
                    var stack = err.stack, message = err.message;
                    if ("string" == typeof stack) return stack;
                    if ("string" == typeof message) return message;
                }
                return stringify(err);
            };
            exports.eventEmitter = function() {
                var triggered = {}, handlers = {};
                return {
                    on: function(eventName, handler) {
                        var handlerList = handlers[eventName] = handlers[eventName] || [];
                        handlerList.push(handler);
                        var cancelled = !1;
                        return {
                            cancel: function() {
                                if (!cancelled) {
                                    cancelled = !0;
                                    handlerList.splice(handlerList.indexOf(handler), 1);
                                }
                            }
                        };
                    },
                    once: function(eventName, handler) {
                        var listener = this.on(eventName, function() {
                            listener.cancel();
                            handler();
                        });
                        return listener;
                    },
                    trigger: function(eventName) {
                        var handlerList = handlers[eventName];
                        if (handlerList) for (var _iterator = handlerList, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i2 >= _iterator.length) break;
                                _ref = _iterator[_i2++];
                            } else {
                                if ((_i2 = _iterator.next()).done) break;
                                _ref = _i2.value;
                            }
                            var _handler = _ref;
                            _handler();
                        }
                    },
                    triggerOnce: function(eventName) {
                        if (!triggered[eventName]) {
                            triggered[eventName] = !0;
                            this.trigger(eventName);
                        }
                    }
                };
            };
            function uniqueID() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            }
            function safeInterval(method, time) {
                var timeout = void 0;
                timeout = setTimeout(function runInterval() {
                    timeout = setTimeout(runInterval, time);
                    method.call();
                }, time);
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            }
            var objectIDs = new (__webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js").WeakMap)();
            function regex(pattern, string) {
                var start = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                "string" == typeof pattern && (pattern = new RegExp(pattern));
                var result = string.slice(start).match(pattern);
                if (result) {
                    var index = result.index, match = result[0];
                    return {
                        text: match,
                        groups: result.slice(1),
                        start: start + index,
                        end: start + index + match.length,
                        length: match.length,
                        replace: function(text) {
                            return match ? "" + match.slice(0, start + index) + text + match.slice(index + match.length) : "";
                        }
                    };
                }
            }
            function stringify(item) {
                return "string" == typeof item ? item : item && "function" == typeof item.toString ? item.toString() : Object.prototype.toString.call(item);
            }
        },
        "./src/types.js": function(module, exports, __webpack_require__) {
            "use strict";
        }
    });
});
//# sourceMappingURL=zoid.frame.js.map
//# sourceMappingURL=zoid.frame.js.map

/***/ }),

/***/ "./node_modules/zoid/dist/zoid.js":
/*!****************************************!*\
  !*** ./node_modules/zoid/dist/zoid.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(root, factory) {
     true ? module.exports = factory() : undefined;
}("undefined" != typeof self ? self : this, function() {
    return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                i: moduleId,
                l: !1,
                exports: {}
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = !0;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports, name, getter) {
            __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                configurable: !1,
                enumerable: !0,
                get: getter
            });
        };
        __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ? function() {
                return module.default;
            } : function() {
                return module;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
        };
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = "./src/index.js");
    }({
        "./node_modules/beaver-logger/client/builders.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.addPayloadBuilder = function(builder) {
                payloadBuilders.push(builder);
            };
            exports.addMetaBuilder = function(builder) {
                metaBuilders.push(builder);
            };
            exports.addTrackingBuilder = function(builder) {
                trackingBuilders.push(builder);
            };
            exports.addHeaderBuilder = function(builder) {
                headerBuilders.push(builder);
            };
            var payloadBuilders = exports.payloadBuilders = [], metaBuilders = exports.metaBuilders = [], trackingBuilders = exports.trackingBuilders = [], headerBuilders = exports.headerBuilders = [];
        },
        "./node_modules/beaver-logger/client/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.config = {
                uri: "",
                prefix: "",
                initial_state_name: "init",
                flushInterval: 6e5,
                debounceInterval: 10,
                sizeLimit: 300,
                silent: !1,
                heartbeat: !0,
                heartbeatConsoleLog: !0,
                heartbeatInterval: 5e3,
                heartbeatTooBusy: !1,
                heartbeatTooBusyThreshold: 1e4,
                logLevel: "warn",
                autoLog: [ "warn", "error" ],
                logUnload: !0,
                logPerformance: !0
            }, exports.logLevels = [ "error", "warn", "info", "debug" ];
        },
        "./node_modules/beaver-logger/client/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/beaver-logger/client/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/beaver-logger/client/init.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.init = function(conf) {
                (0, _util.extend)(_config.config, conf || {});
                if (initiated) return;
                initiated = !0;
                _config.config.logPerformance && (0, _performance.initPerformance)();
                _config.config.heartbeat && (0, _performance.initHeartBeat)();
                if (_config.config.logUnload) {
                    window.addEventListener("beforeunload", function() {
                        (0, _logger.info)("window_beforeunload");
                        (0, _logger.immediateFlush)({
                            fireAndForget: !0
                        });
                    });
                    window.addEventListener("unload", function() {
                        (0, _logger.info)("window_unload");
                        (0, _logger.immediateFlush)({
                            fireAndForget: !0
                        });
                    });
                }
                _config.config.flushInterval && setInterval(_logger.flush, _config.config.flushInterval);
                if (window.beaverLogQueue) {
                    window.beaverLogQueue.forEach(function(payload) {
                        (0, _logger.log)(payload.level, payload.event, payload);
                    });
                    delete window.beaverLogQueue;
                }
            };
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _performance = __webpack_require__("./node_modules/beaver-logger/client/performance.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), initiated = !1;
        },
        "./node_modules/beaver-logger/client/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js");
            Object.keys(_logger).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _logger[key];
                    }
                });
            });
            var _init = __webpack_require__("./node_modules/beaver-logger/client/init.js");
            Object.keys(_init).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _init[key];
                    }
                });
            });
            var _transitions = __webpack_require__("./node_modules/beaver-logger/client/transitions.js");
            Object.keys(_transitions).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _transitions[key];
                    }
                });
            });
            var _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js");
            Object.keys(_builders).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _builders[key];
                    }
                });
            });
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
        },
        "./node_modules/beaver-logger/client/logger.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.track = exports.flush = exports.tracking = exports.buffer = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.getTransport = function() {
                return transport;
            };
            exports.setTransport = function(newTransport) {
                transport = newTransport;
            };
            exports.print = print;
            exports.immediateFlush = immediateFlush;
            exports.log = log;
            exports.prefix = function(name) {
                return {
                    debug: function(event, payload) {
                        return log("debug", name + "_" + event, payload);
                    },
                    info: function(event, payload) {
                        return log("info", name + "_" + event, payload);
                    },
                    warn: function(event, payload) {
                        return log("warn", name + "_" + event, payload);
                    },
                    error: function(event, payload) {
                        return log("error", name + "_" + event, payload);
                    },
                    track: function(payload) {
                        return _track(payload);
                    },
                    flush: function() {
                        return _flush();
                    }
                };
            };
            exports.debug = function(event, payload) {
                return log("debug", event, payload);
            };
            exports.info = function(event, payload) {
                return log("info", event, payload);
            };
            exports.warn = function(event, payload) {
                return log("warn", event, payload);
            };
            exports.error = function(event, payload) {
                return log("error", event, payload);
            };
            var _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), buffer = exports.buffer = [], tracking = exports.tracking = [];
            Function.prototype.bind && window.console && "object" === _typeof(console.log) && [ "log", "info", "warn", "error" ].forEach(function(method) {
                console[method] = this.bind(console[method], console);
            }, Function.prototype.call);
            var transport = function(headers, data, options) {
                return (0, _util.ajax)("post", _config.config.uri, headers, data, options);
            };
            var loaded = !1;
            setTimeout(function() {
                loaded = !0;
            }, 1);
            function print(level, event, payload) {
                if (!loaded) return setTimeout(function() {
                    return print(level, event, payload);
                }, 1);
                if (window.console && window.console.log) {
                    var logLevel = window.LOG_LEVEL || _config.config.logLevel;
                    if (!(_config.logLevels.indexOf(level) > _config.logLevels.indexOf(logLevel))) {
                        payload = payload || {};
                        var args = [ event ];
                        (0, _util.isIE)() && (payload = JSON.stringify(payload));
                        args.push(payload);
                        (payload.error || payload.warning) && args.push("\n\n", payload.error || payload.warning);
                        try {
                            window.console[level] && window.console[level].apply ? window.console[level].apply(window.console, args) : window.console.log && window.console.log.apply && window.console.log.apply(window.console, args);
                        } catch (err) {}
                    }
                }
            }
            function immediateFlush() {
                var _ref$fireAndForget = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).fireAndForget, fireAndForget = void 0 !== _ref$fireAndForget && _ref$fireAndForget;
                if (_config.config.uri) {
                    var hasBuffer = buffer.length, hasTracking = tracking.length;
                    if (hasBuffer || hasTracking) {
                        var meta = {}, _iterator = _builders.metaBuilders, _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref2 = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref2 = _i.value;
                            }
                            var builder = _ref2;
                            try {
                                (0, _util.extend)(meta, builder(meta), !1);
                            } catch (err) {
                                console.error("Error in custom meta builder:", err.stack || err.toString());
                            }
                        }
                        var headers = {}, _iterator2 = _builders.headerBuilders, _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref3;
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) break;
                                _ref3 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) break;
                                _ref3 = _i2.value;
                            }
                            var _builder = _ref3;
                            try {
                                (0, _util.extend)(headers, _builder(headers), !1);
                            } catch (err) {
                                console.error("Error in custom header builder:", err.stack || err.toString());
                            }
                        }
                        var req = transport(headers, {
                            events: buffer,
                            meta: meta,
                            tracking: tracking
                        }, {
                            fireAndForget: fireAndForget
                        });
                        exports.buffer = buffer = [];
                        exports.tracking = tracking = [];
                        return req;
                    }
                }
            }
            var _flush = (0, _util.promiseDebounce)(immediateFlush, _config.config.debounceInterval);
            exports.flush = _flush;
            function enqueue(level, event, payload) {
                buffer.push({
                    level: level,
                    event: event,
                    payload: payload
                });
                _config.config.autoLog.indexOf(level) > -1 && _flush();
            }
            function log(level, event, payload) {
                _config.config.prefix && (event = _config.config.prefix + "_" + event);
                "string" == typeof (payload = payload || {}) ? payload = {
                    message: payload
                } : payload instanceof Error && (payload = {
                    error: payload.stack || payload.toString()
                });
                try {
                    JSON.stringify(payload);
                } catch (err) {
                    return;
                }
                payload.timestamp = Date.now();
                var _iterator3 = _builders.payloadBuilders, _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref4 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref4 = _i3.value;
                    }
                    var builder = _ref4;
                    try {
                        (0, _util.extend)(payload, builder(payload), !1);
                    } catch (err) {
                        console.error("Error in custom payload builder:", err.stack || err.toString());
                    }
                }
                _config.config.silent || print(level, event, payload);
                buffer.length === _config.config.sizeLimit ? enqueue("info", "logger_max_buffer_length") : buffer.length < _config.config.sizeLimit && enqueue(level, event, payload);
            }
            function _track(payload) {
                if (payload) {
                    try {
                        JSON.stringify(payload);
                    } catch (err) {
                        return;
                    }
                    var _iterator4 = _builders.trackingBuilders, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                    for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref5;
                        if (_isArray4) {
                            if (_i4 >= _iterator4.length) break;
                            _ref5 = _iterator4[_i4++];
                        } else {
                            if ((_i4 = _iterator4.next()).done) break;
                            _ref5 = _i4.value;
                        }
                        var builder = _ref5;
                        try {
                            (0, _util.extend)(payload, builder(payload), !1);
                        } catch (err) {
                            console.error("Error in custom tracking builder:", err.stack || err.toString());
                        }
                    }
                    print("debug", "tracking", payload);
                    tracking.push(payload);
                }
            }
            exports.track = _track;
        },
        "./node_modules/beaver-logger/client/performance.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.reqTimer = exports.clientTimer = void 0;
            exports.now = now;
            exports.reqStartElapsed = reqStartElapsed;
            exports.initHeartBeat = function() {
                var heartBeatTimer = timer(), heartbeatCount = 0;
                (0, _util.safeInterval)(function() {
                    if (!(_config.config.heartbeatMaxThreshold && heartbeatCount > _config.config.heartbeatMaxThreshold)) {
                        heartbeatCount += 1;
                        var elapsed = heartBeatTimer.elapsed(), lag = elapsed - _config.config.heartbeatInterval, heartbeatPayload = {
                            count: heartbeatCount,
                            elapsed: elapsed
                        };
                        if (_config.config.heartbeatTooBusy) {
                            heartbeatPayload.lag = lag;
                            lag >= _config.config.heartbeatTooBusyThreshold && (0, _logger.info)("toobusy", heartbeatPayload, {
                                noConsole: !_config.config.heartbeatConsoleLog
                            });
                        }
                        (0, _logger.info)("heartbeat", heartbeatPayload, {
                            noConsole: !_config.config.heartbeatConsoleLog
                        });
                    }
                }, _config.config.heartbeatInterval);
            };
            exports.initPerformance = function() {
                if (!enablePerformance) return (0, _logger.info)("no_performance_data");
                (0, _builders.addPayloadBuilder)(function() {
                    var payload = {};
                    payload.client_elapsed = clientTimer.elapsed();
                    enablePerformance && (payload.req_elapsed = reqTimer.elapsed());
                    return payload;
                });
                _util.windowReady.then(function() {
                    var timing = {};
                    [ "connectEnd", "connectStart", "domComplete", "domContentLoadedEventEnd", "domContentLoadedEventStart", "domInteractive", "domLoading", "domainLookupEnd", "domainLookupStart", "fetchStart", "loadEventEnd", "loadEventStart", "navigationStart", "redirectEnd", "redirectStart", "requestStart", "responseEnd", "responseStart", "secureConnectionStart", "unloadEventEnd", "unloadEventStart" ].forEach(function(key) {
                        timing[key] = parseInt(window.performance.timing[key], 10) || 0;
                    });
                    var offset = timing.connectEnd - timing.navigationStart;
                    timing.connectEnd && Object.keys(timing).forEach(function(name) {
                        var time = timing[name];
                        time && (0, _logger.info)("timing_" + name, {
                            client_elapsed: parseInt(time - timing.connectEnd - (clientTimer.startTime - offset), 10),
                            req_elapsed: parseInt(time - timing.connectEnd, 10)
                        });
                    });
                    (0, _logger.info)("timing", timing);
                    (0, _logger.info)("memory", window.performance.memory);
                    (0, _logger.info)("navigation", window.performance.navigation);
                    window.performance.getEntries && window.performance.getEntries().forEach(function(resource) {
                        [ "link", "script", "img", "css" ].indexOf(resource.initiatorType) > -1 && (0, _logger.info)(resource.initiatorType, resource);
                    });
                });
            };
            var _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), enablePerformance = window && window.performance && performance.now && performance.timing && performance.timing.connectEnd && performance.timing.navigationStart && Math.abs(performance.now() - Date.now()) > 1e3 && performance.now() - (performance.timing.connectEnd - performance.timing.navigationStart) > 0;
            function now() {
                return enablePerformance ? performance.now() : Date.now();
            }
            function timer(startTime) {
                return {
                    startTime: startTime = void 0 !== startTime ? startTime : now(),
                    elapsed: function() {
                        return parseInt(now() - startTime, 10);
                    },
                    reset: function() {
                        startTime = now();
                    }
                };
            }
            function reqStartElapsed() {
                if (enablePerformance) {
                    var timing = window.performance.timing;
                    return parseInt(timing.connectEnd - timing.navigationStart, 10);
                }
            }
            var clientTimer = exports.clientTimer = timer(), reqTimer = exports.reqTimer = timer(reqStartElapsed());
        },
        "./node_modules/beaver-logger/client/transitions.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.startTransition = startTransition;
            exports.endTransition = endTransition;
            exports.transition = function(toState) {
                startTransition();
                endTransition(toState);
            };
            var _performance = __webpack_require__("./node_modules/beaver-logger/client/performance.js"), _logger = __webpack_require__("./node_modules/beaver-logger/client/logger.js"), _builders = __webpack_require__("./node_modules/beaver-logger/client/builders.js"), _util = __webpack_require__("./node_modules/beaver-logger/client/util.js"), _config = __webpack_require__("./node_modules/beaver-logger/client/config.js"), windowID = (0, 
            _util.uniqueID)(), pageID = (0, _util.uniqueID)(), currentState = _config.config.initial_state_name, startTime = void 0;
            function startTransition() {
                startTime = (0, _performance.now)();
            }
            function endTransition(toState) {
                startTime = startTime || (0, _performance.reqStartElapsed)();
                var currentTime = (0, _performance.now)(), elapsedTime = void 0;
                void 0 !== startTime && (elapsedTime = parseInt(currentTime - startTime, 0));
                var transitionName = "transition_" + currentState + "_to_" + toState;
                (0, _logger.info)(transitionName, {
                    duration: elapsedTime
                });
                (0, _logger.track)({
                    transition: transitionName,
                    transition_time: elapsedTime
                });
                (0, _logger.immediateFlush)();
                startTime = currentTime;
                currentState = toState;
                pageID = (0, _util.uniqueID)();
            }
            (0, _builders.addPayloadBuilder)(function() {
                return {
                    windowID: windowID,
                    pageID: pageID
                };
            });
            (0, _builders.addMetaBuilder)(function() {
                return {
                    state: "ui_" + currentState
                };
            });
        },
        "./node_modules/beaver-logger/client/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.windowReady = void 0;
            exports.extend = function(dest, src) {
                var over = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                dest = dest || {};
                src = src || {};
                for (var i in src) src.hasOwnProperty(i) && (!over && dest.hasOwnProperty(i) || (dest[i] = src[i]));
                return dest;
            };
            exports.isSameProtocol = isSameProtocol;
            exports.isSameDomain = isSameDomain;
            exports.ajax = function(method, url) {
                var headers = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, data = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, _ref$fireAndForget = (arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}).fireAndForget, fireAndForget = void 0 !== _ref$fireAndForget && _ref$fireAndForget;
                return new _src.ZalgoPromise(function(resolve) {
                    var XRequest = window.XMLHttpRequest || window.ActiveXObject;
                    if (window.XDomainRequest && !isSameDomain(url)) {
                        if (!isSameProtocol(url)) return resolve();
                        XRequest = window.XDomainRequest;
                    }
                    var req = new XRequest("MSXML2.XMLHTTP.3.0");
                    req.open(method.toUpperCase(), url, !0);
                    if ("function" == typeof req.setRequestHeader) {
                        req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                        req.setRequestHeader("Content-type", "application/json");
                        for (var headerName in headers) headers.hasOwnProperty(headerName) && req.setRequestHeader(headerName, headers[headerName]);
                    }
                    fireAndForget ? resolve() : req.onreadystatechange = function() {
                        req.readyState > 3 && resolve();
                    };
                    req.send(JSON.stringify(data).replace(/&/g, "%26"));
                });
            };
            exports.promiseDebounce = function(method, interval) {
                var debounce = {};
                return function() {
                    var args = arguments;
                    if (debounce.timeout) {
                        clearTimeout(debounce.timeout);
                        delete debounce.timeout;
                    }
                    debounce.timeout = setTimeout(function() {
                        var resolver = debounce.resolver, rejector = debounce.rejector;
                        delete debounce.promise;
                        delete debounce.resolver;
                        delete debounce.rejector;
                        delete debounce.timeout;
                        return _src.ZalgoPromise.resolve().then(function() {
                            return method.apply(null, args);
                        }).then(resolver, rejector);
                    }, interval);
                    debounce.promise = debounce.promise || new _src.ZalgoPromise(function(resolver, rejector) {
                        debounce.resolver = resolver;
                        debounce.rejector = rejector;
                    });
                    return debounce.promise;
                };
            };
            exports.safeInterval = function(method, time) {
                var timeout = void 0;
                !function loop() {
                    timeout = setTimeout(function() {
                        method();
                        loop();
                    }, time);
                }();
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            };
            exports.uniqueID = function() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            };
            exports.isIE = function() {
                return Boolean(window.document.documentMode);
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            function isSameProtocol(url) {
                return window.location.protocol === url.split("/")[0];
            }
            function isSameDomain(url) {
                var match = url.match(/https?:\/\/[^/]+/);
                return !match || match[0] === window.location.protocol + "//" + window.location.host;
            }
            exports.windowReady = new _src.ZalgoPromise(function(resolve) {
                "undefined" != typeof document && "complete" === document.readyState && resolve();
                window.addEventListener && window.addEventListener("load", resolve);
            });
        },
        "./node_modules/cross-domain-safe-weakmap/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/cross-domain-safe-weakmap/src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _weakmap = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/weakmap.js");
            Object.defineProperty(exports, "WeakMap", {
                enumerable: !0,
                get: function() {
                    return _weakmap.CrossDomainSafeWeakMap;
                }
            });
        },
        "./node_modules/cross-domain-safe-weakmap/src/native.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.hasNativeWeakMap = function() {
                if (!window.WeakMap) return !1;
                if (!window.Object.freeze) return !1;
                try {
                    var testWeakMap = new window.WeakMap(), testKey = {};
                    window.Object.freeze(testKey);
                    testWeakMap.set(testKey, "__testvalue__");
                    return "__testvalue__" === testWeakMap.get(testKey);
                } catch (err) {
                    return !1;
                }
            };
        },
        "./node_modules/cross-domain-safe-weakmap/src/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.safeIndexOf = function(collection, item) {
                for (var i = 0; i < collection.length; i++) try {
                    if (collection[i] === item) return i;
                } catch (err) {}
                return -1;
            };
            exports.noop = function() {};
        },
        "./node_modules/cross-domain-safe-weakmap/src/weakmap.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CrossDomainSafeWeakMap = void 0;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _native = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/native.js"), _util = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/util.js");
            var defineProperty = Object.defineProperty, counter = Date.now() % 1e9;
            exports.CrossDomainSafeWeakMap = function() {
                function CrossDomainSafeWeakMap() {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, CrossDomainSafeWeakMap);
                    counter += 1;
                    this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__" + counter;
                    if ((0, _native.hasNativeWeakMap)()) try {
                        this.weakmap = new window.WeakMap();
                    } catch (err) {}
                    this.keys = [];
                    this.values = [];
                }
                CrossDomainSafeWeakMap.prototype._cleanupClosedWindows = function() {
                    for (var weakmap = this.weakmap, keys = this.keys, i = 0; i < keys.length; i++) {
                        var value = keys[i];
                        if ((0, _src.isWindow)(value) && (0, _src.isWindowClosed)(value)) {
                            if (weakmap) try {
                                weakmap.delete(value);
                            } catch (err) {}
                            keys.splice(i, 1);
                            this.values.splice(i, 1);
                            i -= 1;
                        }
                    }
                };
                CrossDomainSafeWeakMap.prototype.isSafeToReadWrite = function(key) {
                    if ((0, _src.isWindow)(key)) return !1;
                    try {
                        (0, _util.noop)(key && key.self);
                        (0, _util.noop)(key && key[this.name]);
                    } catch (err) {
                        return !1;
                    }
                    return !0;
                };
                CrossDomainSafeWeakMap.prototype.set = function(key, value) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.set(key, value);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var name = this.name, entry = key[name];
                        entry && entry[0] === key ? entry[1] = value : defineProperty(key, name, {
                            value: [ key, value ],
                            writable: !0
                        });
                    } else {
                        this._cleanupClosedWindows();
                        var keys = this.keys, values = this.values, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 === index) {
                            keys.push(key);
                            values.push(value);
                        } else values[index] = value;
                    }
                };
                CrossDomainSafeWeakMap.prototype.get = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        if (weakmap.has(key)) return weakmap.get(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (!this.isSafeToReadWrite(key)) {
                        this._cleanupClosedWindows();
                        var keys = this.keys, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 === index) return;
                        return this.values[index];
                    }
                    var entry = key[this.name];
                    if (entry && entry[0] === key) return entry[1];
                };
                CrossDomainSafeWeakMap.prototype.delete = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        weakmap.delete(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var entry = key[this.name];
                        entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                    } else {
                        this._cleanupClosedWindows();
                        var keys = this.keys, index = (0, _util.safeIndexOf)(keys, key);
                        if (-1 !== index) {
                            keys.splice(index, 1);
                            this.values.splice(index, 1);
                        }
                    }
                };
                CrossDomainSafeWeakMap.prototype.has = function(key) {
                    if (!key) throw new Error("WeakMap expected key");
                    var weakmap = this.weakmap;
                    if (weakmap) try {
                        return weakmap.has(key);
                    } catch (err) {
                        delete this.weakmap;
                    }
                    if (this.isSafeToReadWrite(key)) {
                        var entry = key[this.name];
                        return !(!entry || entry[0] !== key);
                    }
                    this._cleanupClosedWindows();
                    return -1 !== (0, _util.safeIndexOf)(this.keys, key);
                };
                return CrossDomainSafeWeakMap;
            }();
        },
        "./node_modules/cross-domain-utils/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _utils = __webpack_require__("./node_modules/cross-domain-utils/src/utils.js");
            Object.keys(_utils).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _utils[key];
                    }
                });
            });
            var _types = __webpack_require__("./node_modules/cross-domain-utils/src/types.js");
            Object.keys(_types).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _types[key];
                    }
                });
            });
        },
        "./node_modules/cross-domain-utils/src/types.js": function(module, exports, __webpack_require__) {
            "use strict";
        },
        "./node_modules/cross-domain-utils/src/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isRegex = function(item) {
                return "[object RegExp]" === Object.prototype.toString.call(item);
            };
            exports.noop = function() {};
        },
        "./node_modules/cross-domain-utils/src/utils.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isFileProtocol = function() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window).location.protocol === CONSTANTS.FILE_PROTOCOL;
            };
            exports.isAboutProtocol = isAboutProtocol;
            exports.getParent = getParent;
            exports.getOpener = getOpener;
            exports.canReadFromWindow = canReadFromWindow;
            exports.getActualDomain = getActualDomain;
            exports.getDomain = getDomain;
            exports.isBlankDomain = function(win) {
                try {
                    if (!win.location.href) return !0;
                    if ("about:blank" === win.location.href) return !0;
                } catch (err) {}
                return !1;
            };
            exports.isActuallySameDomain = isActuallySameDomain;
            exports.isSameDomain = isSameDomain;
            exports.getParents = getParents;
            exports.isAncestorParent = isAncestorParent;
            exports.getFrames = getFrames;
            exports.getAllChildFrames = getAllChildFrames;
            exports.getTop = getTop;
            exports.getAllFramesInWindow = getAllFramesInWindow;
            exports.isTop = function(win) {
                return win === getTop(win);
            };
            exports.isFrameWindowClosed = isFrameWindowClosed;
            exports.isWindowClosed = isWindowClosed;
            exports.linkFrameWindow = function(frame) {
                !function() {
                    for (var i = 0; i < iframeFrames.length; i++) if (isFrameWindowClosed(iframeFrames[i])) {
                        iframeFrames.splice(i, 1);
                        iframeWindows.splice(i, 1);
                    }
                    for (var _i5 = 0; _i5 < iframeWindows.length; _i5++) if (isWindowClosed(iframeWindows[_i5])) {
                        iframeFrames.splice(_i5, 1);
                        iframeWindows.splice(_i5, 1);
                    }
                }();
                if (frame && frame.contentWindow) try {
                    iframeWindows.push(frame.contentWindow);
                    iframeFrames.push(frame);
                } catch (err) {}
            };
            exports.getUserAgent = function(win) {
                return (win = win || window).navigator.mockUserAgent || win.navigator.userAgent;
            };
            exports.getFrameByName = getFrameByName;
            exports.findChildFrameByName = findChildFrameByName;
            exports.findFrameByName = function(win, name) {
                var frame = void 0;
                if (frame = getFrameByName(win, name)) return frame;
                return findChildFrameByName(getTop(win) || win, name);
            };
            exports.isParent = function(win, frame) {
                var frameParent = getParent(frame);
                if (frameParent) return frameParent === win;
                for (var _iterator6 = getFrames(win), _isArray6 = Array.isArray(_iterator6), _i8 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref6;
                    if (_isArray6) {
                        if (_i8 >= _iterator6.length) break;
                        _ref6 = _iterator6[_i8++];
                    } else {
                        if ((_i8 = _iterator6.next()).done) break;
                        _ref6 = _i8.value;
                    }
                    var childFrame = _ref6;
                    if (childFrame === frame) return !0;
                }
                return !1;
            };
            exports.isOpener = function(parent, child) {
                return parent === getOpener(child);
            };
            exports.getAncestor = getAncestor;
            exports.getAncestors = function(win) {
                var results = [], ancestor = win;
                for (;ancestor; ) (ancestor = getAncestor(ancestor)) && results.push(ancestor);
                return results;
            };
            exports.isAncestor = function(parent, child) {
                var actualParent = getAncestor(child);
                if (actualParent) return actualParent === parent;
                if (child === parent) return !1;
                if (getTop(child) === child) return !1;
                for (var _iterator7 = getFrames(parent), _isArray7 = Array.isArray(_iterator7), _i9 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref7;
                    if (_isArray7) {
                        if (_i9 >= _iterator7.length) break;
                        _ref7 = _iterator7[_i9++];
                    } else {
                        if ((_i9 = _iterator7.next()).done) break;
                        _ref7 = _i9.value;
                    }
                    var frame = _ref7;
                    if (frame === child) return !0;
                }
                return !1;
            };
            exports.isPopup = isPopup;
            exports.isIframe = isIframe;
            exports.isFullpage = function() {
                return Boolean(!isIframe() && !isPopup());
            };
            exports.getDistanceFromTop = getDistanceFromTop;
            exports.getNthParent = getNthParent;
            exports.getNthParentFromTop = function(win) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return getNthParent(win, getDistanceFromTop(win) - n);
            };
            exports.isSameTopWindow = function(win1, win2) {
                var top1 = getTop(win1) || win1, top2 = getTop(win2) || win2;
                try {
                    if (top1 && top2) return top1 === top2;
                } catch (err) {}
                var allFrames1 = getAllFramesInWindow(win1), allFrames2 = getAllFramesInWindow(win2);
                if (anyMatch(allFrames1, allFrames2)) return !0;
                var opener1 = getOpener(top1), opener2 = getOpener(top2);
                if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) return !1;
                if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) return !1;
                return !1;
            };
            exports.matchDomain = function matchDomain(pattern, origin) {
                if ("string" == typeof pattern) {
                    if ("string" == typeof origin) return pattern === CONSTANTS.WILDCARD || origin === pattern;
                    if ((0, _util.isRegex)(origin)) return !1;
                    if (Array.isArray(origin)) return !1;
                }
                if ((0, _util.isRegex)(pattern)) return (0, _util.isRegex)(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern));
                if (Array.isArray(pattern)) return Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !(0, 
                _util.isRegex)(origin) && pattern.some(function(subpattern) {
                    return matchDomain(subpattern, origin);
                });
                return !1;
            };
            exports.stringifyDomainPattern = function(pattern) {
                return Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : (0, _util.isRegex)(pattern) ? "RegExp(" + pattern.toString() : pattern.toString();
            };
            exports.getDomainFromUrl = function(url) {
                var domain = void 0;
                if (!url.match(/^(https?|mock|file):\/\//)) return getDomain();
                domain = url;
                return domain = domain.split("/").slice(0, 3).join("/");
            };
            exports.onCloseWindow = function(win, callback) {
                var delay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3, maxtime = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0, timeout = void 0;
                !function check() {
                    if (isWindowClosed(win)) {
                        timeout && clearTimeout(timeout);
                        return callback();
                    }
                    if (maxtime <= 0) clearTimeout(timeout); else {
                        maxtime -= delay;
                        timeout = setTimeout(check, delay);
                    }
                }();
                return {
                    cancel: function() {
                        timeout && clearTimeout(timeout);
                    }
                };
            };
            exports.isWindow = function(obj) {
                try {
                    if (obj === window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if ("[object Window]" === Object.prototype.toString.call(obj)) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (window.Window && obj instanceof window.Window) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.self === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.parent === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    if (obj && obj.top === obj) return !0;
                } catch (err) {
                    if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                }
                try {
                    (0, _util.noop)(obj == obj);
                } catch (err) {
                    return !0;
                }
                try {
                    (0, _util.noop)(obj && obj.__cross_domain_utils_window_check__);
                } catch (err) {
                    return !0;
                }
                return !1;
            };
            var _util = __webpack_require__("./node_modules/cross-domain-utils/src/util.js"), CONSTANTS = {
                MOCK_PROTOCOL: "mock:",
                FILE_PROTOCOL: "file:",
                ABOUT_PROTOCOL: "about:",
                WILDCARD: "*"
            }, IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
            function isAboutProtocol() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window).location.protocol === CONSTANTS.ABOUT_PROTOCOL;
            }
            function getParent(win) {
                if (win) try {
                    if (win.parent && win.parent !== win) return win.parent;
                } catch (err) {}
            }
            function getOpener(win) {
                if (win && !getParent(win)) try {
                    return win.opener;
                } catch (err) {}
            }
            function canReadFromWindow(win) {
                try {
                    (0, _util.noop)(win && win.location && win.location.href);
                    return !0;
                } catch (err) {}
                return !1;
            }
            function getActualDomain(win) {
                var location = win.location;
                if (!location) throw new Error("Can not read window location");
                var protocol = location.protocol;
                if (!protocol) throw new Error("Can not read window protocol");
                if (protocol === CONSTANTS.FILE_PROTOCOL) return CONSTANTS.FILE_PROTOCOL + "//";
                if (protocol === CONSTANTS.ABOUT_PROTOCOL) {
                    var parent = getParent(win);
                    return parent && canReadFromWindow(win) ? getActualDomain(parent) : CONSTANTS.ABOUT_PROTOCOL + "//";
                }
                var host = location.host;
                if (!host) throw new Error("Can not read window host");
                return protocol + "//" + host;
            }
            function getDomain(win) {
                var domain = getActualDomain(win = win || window);
                return domain && win.mockDomain && 0 === win.mockDomain.indexOf(CONSTANTS.MOCK_PROTOCOL) ? win.mockDomain : domain;
            }
            function isActuallySameDomain(win) {
                try {
                    if (win === window) return !0;
                } catch (err) {}
                try {
                    var desc = Object.getOwnPropertyDescriptor(win, "location");
                    if (desc && !1 === desc.enumerable) return !1;
                } catch (err) {}
                try {
                    if (isAboutProtocol(win) && canReadFromWindow(win)) return !0;
                } catch (err) {}
                try {
                    if (getActualDomain(win) === getActualDomain(window)) return !0;
                } catch (err) {}
                return !1;
            }
            function isSameDomain(win) {
                if (!isActuallySameDomain(win)) return !1;
                try {
                    if (win === window) return !0;
                    if (isAboutProtocol(win) && canReadFromWindow(win)) return !0;
                    if (getDomain(window) === getDomain(win)) return !0;
                } catch (err) {}
                return !1;
            }
            function getParents(win) {
                var result = [];
                try {
                    for (;win.parent !== win; ) {
                        result.push(win.parent);
                        win = win.parent;
                    }
                } catch (err) {}
                return result;
            }
            function isAncestorParent(parent, child) {
                if (!parent || !child) return !1;
                var childParent = getParent(child);
                return childParent ? childParent === parent : -1 !== getParents(child).indexOf(parent);
            }
            function getFrames(win) {
                var result = [], frames = void 0;
                try {
                    frames = win.frames;
                } catch (err) {
                    frames = win;
                }
                var len = void 0;
                try {
                    len = frames.length;
                } catch (err) {}
                if (0 === len) return result;
                if (len) {
                    for (var i = 0; i < len; i++) {
                        var frame = void 0;
                        try {
                            frame = frames[i];
                        } catch (err) {
                            continue;
                        }
                        result.push(frame);
                    }
                    return result;
                }
                for (var _i = 0; _i < 100; _i++) {
                    var _frame = void 0;
                    try {
                        _frame = frames[_i];
                    } catch (err) {
                        return result;
                    }
                    if (!_frame) return result;
                    result.push(_frame);
                }
                return result;
            }
            function getAllChildFrames(win) {
                var result = [], _iterator = getFrames(win), _isArray = Array.isArray(_iterator), _i2 = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i2 >= _iterator.length) break;
                        _ref = _iterator[_i2++];
                    } else {
                        if ((_i2 = _iterator.next()).done) break;
                        _ref = _i2.value;
                    }
                    var frame = _ref;
                    result.push(frame);
                    var _iterator2 = getAllChildFrames(frame), _isArray2 = Array.isArray(_iterator2), _i3 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i3 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i3++];
                        } else {
                            if ((_i3 = _iterator2.next()).done) break;
                            _ref2 = _i3.value;
                        }
                        var childFrame = _ref2;
                        result.push(childFrame);
                    }
                }
                return result;
            }
            function getTop(win) {
                if (win) {
                    try {
                        if (win.top) return win.top;
                    } catch (err) {}
                    if (getParent(win) === win) return win;
                    try {
                        if (isAncestorParent(window, win) && window.top) return window.top;
                    } catch (err) {}
                    try {
                        if (isAncestorParent(win, window) && window.top) return window.top;
                    } catch (err) {}
                    var _iterator3 = getAllChildFrames(win), _isArray3 = Array.isArray(_iterator3), _i4 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i4 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i4++];
                        } else {
                            if ((_i4 = _iterator3.next()).done) break;
                            _ref3 = _i4.value;
                        }
                        var frame = _ref3;
                        try {
                            if (frame.top) return frame.top;
                        } catch (err) {}
                        if (getParent(frame) === frame) return frame;
                    }
                }
            }
            function getAllFramesInWindow(win) {
                var top = getTop(win);
                return getAllChildFrames(top).concat(top);
            }
            function isFrameWindowClosed(frame) {
                if (!frame.contentWindow) return !0;
                if (!frame.parentNode) return !0;
                var doc = frame.ownerDocument;
                return !(!doc || !doc.body || doc.body.contains(frame));
            }
            var iframeWindows = [], iframeFrames = [];
            function isWindowClosed(win) {
                var allowMock = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                try {
                    if (win === window) return !1;
                } catch (err) {
                    return !0;
                }
                try {
                    if (!win) return !0;
                } catch (err) {
                    return !0;
                }
                try {
                    if (win.closed) return !0;
                } catch (err) {
                    return !err || err.message !== IE_WIN_ACCESS_ERROR;
                }
                if (allowMock && isSameDomain(win)) try {
                    if (win.mockclosed) return !0;
                } catch (err) {}
                try {
                    if (!win.parent || !win.top) return !0;
                } catch (err) {}
                try {
                    (0, _util.noop)(win == win);
                } catch (err) {
                    return !0;
                }
                var iframeIndex = function(collection, item) {
                    for (var i = 0; i < collection.length; i++) try {
                        if (collection[i] === item) return i;
                    } catch (err) {}
                    return -1;
                }(iframeWindows, win);
                if (-1 !== iframeIndex) {
                    var frame = iframeFrames[iframeIndex];
                    if (frame && isFrameWindowClosed(frame)) return !0;
                }
                return !1;
            }
            function getFrameByName(win, name) {
                var winFrames = getFrames(win), _iterator4 = winFrames, _isArray4 = Array.isArray(_iterator4), _i6 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref4;
                    if (_isArray4) {
                        if (_i6 >= _iterator4.length) break;
                        _ref4 = _iterator4[_i6++];
                    } else {
                        if ((_i6 = _iterator4.next()).done) break;
                        _ref4 = _i6.value;
                    }
                    var childFrame = _ref4;
                    try {
                        if (isSameDomain(childFrame) && childFrame.name === name && -1 !== winFrames.indexOf(childFrame)) return childFrame;
                    } catch (err) {}
                }
                try {
                    if (-1 !== winFrames.indexOf(win.frames[name])) return win.frames[name];
                } catch (err) {}
                try {
                    if (-1 !== winFrames.indexOf(win[name])) return win[name];
                } catch (err) {}
            }
            function findChildFrameByName(win, name) {
                var frame = getFrameByName(win, name);
                if (frame) return frame;
                var _iterator5 = getFrames(win), _isArray5 = Array.isArray(_iterator5), _i7 = 0;
                for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                    var _ref5;
                    if (_isArray5) {
                        if (_i7 >= _iterator5.length) break;
                        _ref5 = _iterator5[_i7++];
                    } else {
                        if ((_i7 = _iterator5.next()).done) break;
                        _ref5 = _i7.value;
                    }
                    var namedFrame = findChildFrameByName(_ref5, name);
                    if (namedFrame) return namedFrame;
                }
            }
            function getAncestor(win) {
                var opener = getOpener(win = win || window);
                if (opener) return opener;
                var parent = getParent(win);
                return parent || void 0;
            }
            function isPopup() {
                return Boolean(getOpener(window));
            }
            function isIframe() {
                return Boolean(getParent(window));
            }
            function anyMatch(collection1, collection2) {
                var _iterator8 = collection1, _isArray8 = Array.isArray(_iterator8), _i10 = 0;
                for (_iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray8) {
                        if (_i10 >= _iterator8.length) break;
                        _ref8 = _iterator8[_i10++];
                    } else {
                        if ((_i10 = _iterator8.next()).done) break;
                        _ref8 = _i10.value;
                    }
                    var item1 = _ref8, _iterator9 = collection2, _isArray9 = Array.isArray(_iterator9), _i11 = 0;
                    for (_iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray9) {
                            if (_i11 >= _iterator9.length) break;
                            _ref9 = _iterator9[_i11++];
                        } else {
                            if ((_i11 = _iterator9.next()).done) break;
                            _ref9 = _i11.value;
                        }
                        if (item1 === _ref9) return !0;
                    }
                }
                return !1;
            }
            function getDistanceFromTop() {
                for (var distance = 0, parent = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window; parent; ) (parent = getParent(parent)) && (distance += 1);
                return distance;
            }
            function getNthParent(win) {
                for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, parent = win, i = 0; i < n; i++) {
                    if (!parent) return;
                    parent = getParent(parent);
                }
                return parent;
            }
        },
        "./node_modules/hi-base32/src/base32.js": function(module, exports, __webpack_require__) {
            "use strict";
            (function(process, global, module) {
                var __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                !function() {
                    var root = "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) ? window : {};
                    !root.HI_BASE32_NO_NODE_JS && "object" === (void 0 === process ? "undefined" : _typeof(process)) && process.versions && process.versions.node && (root = global);
                    var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && "object" === _typeof(module) && module.exports, AMD = __webpack_require__("./node_modules/webpack/buildin/amd-options.js"), BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split(""), BASE32_DECODE_CHAR = {
                        A: 0,
                        B: 1,
                        C: 2,
                        D: 3,
                        E: 4,
                        F: 5,
                        G: 6,
                        H: 7,
                        I: 8,
                        J: 9,
                        K: 10,
                        L: 11,
                        M: 12,
                        N: 13,
                        O: 14,
                        P: 15,
                        Q: 16,
                        R: 17,
                        S: 18,
                        T: 19,
                        U: 20,
                        V: 21,
                        W: 22,
                        X: 23,
                        Y: 24,
                        Z: 25,
                        2: 26,
                        3: 27,
                        4: 28,
                        5: 29,
                        6: 30,
                        7: 31
                    }, blocks = [ 0, 0, 0, 0, 0, 0, 0, 0 ], throwInvalidUtf8 = function(position, partial) {
                        partial.length > 10 && (partial = "..." + partial.substr(-10));
                        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
                        err.position = position;
                        throw err;
                    }, decodeAsBytes = function(base32Str) {
                        if (!/^[A-Z2-7=]+$/.test(base32Str)) throw new Error("Invalid base32 characters");
                        for (var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = (base32Str = base32Str.replace(/=/g, "")).length, i = 0, count = length >> 3 << 3; i < count; ) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                            bytes[index++] = 255 & (v5 << 7 | v6 << 2 | v7 >>> 3);
                            bytes[index++] = 255 & (v7 << 5 | v8);
                        }
                        var remain = length - count;
                        if (2 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                        } else if (4 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                        } else if (5 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                        } else if (7 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            bytes[index++] = 255 & (v1 << 3 | v2 >>> 2);
                            bytes[index++] = 255 & (v2 << 6 | v3 << 1 | v4 >>> 4);
                            bytes[index++] = 255 & (v4 << 4 | v5 >>> 1);
                            bytes[index++] = 255 & (v5 << 7 | v6 << 2 | v7 >>> 3);
                        }
                        return bytes;
                    }, decode = function(base32Str, asciiOnly) {
                        if (!asciiOnly) return function(bytes) {
                            for (var b, c, str = "", length = bytes.length, i = 0, followingChars = 0; i < length; ) if ((b = bytes[i++]) <= 127) str += String.fromCharCode(b); else {
                                if (b > 191 && b <= 223) {
                                    c = 31 & b;
                                    followingChars = 1;
                                } else if (b <= 239) {
                                    c = 15 & b;
                                    followingChars = 2;
                                } else if (b <= 247) {
                                    c = 7 & b;
                                    followingChars = 3;
                                } else throwInvalidUtf8(i, str);
                                for (var j = 0; j < followingChars; ++j) {
                                    ((b = bytes[i++]) < 128 || b > 191) && throwInvalidUtf8(i, str);
                                    c <<= 6;
                                    c += 63 & b;
                                }
                                c >= 55296 && c <= 57343 && throwInvalidUtf8(i, str);
                                c > 1114111 && throwInvalidUtf8(i, str);
                                if (c <= 65535) str += String.fromCharCode(c); else {
                                    c -= 65536;
                                    str += String.fromCharCode(55296 + (c >> 10));
                                    str += String.fromCharCode(56320 + (1023 & c));
                                }
                            }
                            return str;
                        }(decodeAsBytes(base32Str));
                        if (!/^[A-Z2-7=]+$/.test(base32Str)) throw new Error("Invalid base32 characters");
                        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
                        -1 === length && (length = base32Str.length);
                        for (var i = 0, count = length >> 3 << 3; i < count; ) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1)) + String.fromCharCode(255 & (v5 << 7 | v6 << 2 | v7 >>> 3)) + String.fromCharCode(255 & (v7 << 5 | v8));
                        }
                        var remain = length - count;
                        if (2 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2));
                        } else if (4 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4));
                        } else if (5 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1));
                        } else if (7 === remain) {
                            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v2 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i++)];
                            str += String.fromCharCode(255 & (v1 << 3 | v2 >>> 2)) + String.fromCharCode(255 & (v2 << 6 | v3 << 1 | v4 >>> 4)) + String.fromCharCode(255 & (v4 << 4 | v5 >>> 1)) + String.fromCharCode(255 & (v5 << 7 | v6 << 2 | v7 >>> 3));
                        }
                        return str;
                    }, exports = {
                        encode: function(input, asciiOnly) {
                            var notString = "string" != typeof input;
                            notString && input.constructor === ArrayBuffer && (input = new Uint8Array(input));
                            return notString ? function(bytes) {
                                for (var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length, i = 0, count = 5 * parseInt(length / 5); i < count; ) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i++];
                                    v4 = bytes[i++];
                                    v5 = bytes[i++];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                }
                                var remain = length - count;
                                if (1 === remain) {
                                    v1 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
                                } else if (2 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                } else if (3 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                } else if (4 === remain) {
                                    v1 = bytes[i++];
                                    v2 = bytes[i++];
                                    v3 = bytes[i++];
                                    v4 = bytes[i];
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                }
                                return base32Str;
                            }(input) : asciiOnly ? function(str) {
                                for (var v1, v2, v3, v4, v5, base32Str = "", length = str.length, i = 0, count = 5 * parseInt(length / 5); i < count; ) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i++);
                                    v4 = str.charCodeAt(i++);
                                    v5 = str.charCodeAt(i++);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                }
                                var remain = length - count;
                                if (1 === remain) {
                                    v1 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
                                } else if (2 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                } else if (3 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                } else if (4 === remain) {
                                    v1 = str.charCodeAt(i++);
                                    v2 = str.charCodeAt(i++);
                                    v3 = str.charCodeAt(i++);
                                    v4 = str.charCodeAt(i);
                                    base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                }
                                return base32Str;
                            }(input) : function(str) {
                                var v1, v2, v3, v4, v5, code, i, end = !1, base32Str = "", index = 0, start = 0, length = str.length;
                                do {
                                    blocks[0] = blocks[5];
                                    blocks[1] = blocks[6];
                                    blocks[2] = blocks[7];
                                    for (i = start; index < length && i < 5; ++index) if ((code = str.charCodeAt(index)) < 128) blocks[i++] = code; else if (code < 2048) {
                                        blocks[i++] = 192 | code >> 6;
                                        blocks[i++] = 128 | 63 & code;
                                    } else if (code < 55296 || code >= 57344) {
                                        blocks[i++] = 224 | code >> 12;
                                        blocks[i++] = 128 | code >> 6 & 63;
                                        blocks[i++] = 128 | 63 & code;
                                    } else {
                                        code = 65536 + ((1023 & code) << 10 | 1023 & str.charCodeAt(++index));
                                        blocks[i++] = 240 | code >> 18;
                                        blocks[i++] = 128 | code >> 12 & 63;
                                        blocks[i++] = 128 | code >> 6 & 63;
                                        blocks[i++] = 128 | 63 & code;
                                    }
                                    start = i - 5;
                                    index === length && ++index;
                                    index > length && i < 6 && (end = !0);
                                    v1 = blocks[0];
                                    if (i > 4) {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        v4 = blocks[3];
                                        v5 = blocks[4];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[31 & (v4 << 3 | v5 >>> 5)] + BASE32_ENCODE_CHAR[31 & v5];
                                    } else if (1 === i) base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======"; else if (2 === i) {
                                        v2 = blocks[1];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
                                    } else if (3 === i) {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
                                    } else {
                                        v2 = blocks[1];
                                        v3 = blocks[2];
                                        v4 = blocks[3];
                                        base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[31 & (v1 << 2 | v2 >>> 6)] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[31 & (v2 << 4 | v3 >>> 4)] + BASE32_ENCODE_CHAR[31 & (v3 << 1 | v4 >>> 7)] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
                                    }
                                } while (!end);
                                return base32Str;
                            }(input);
                        },
                        decode: decode
                    };
                    decode.asBytes = decodeAsBytes;
                    if (COMMON_JS) module.exports = exports; else {
                        root.base32 = exports;
                        AMD && void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                            return exports;
                        }.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
                    }
                }();
            }).call(exports, __webpack_require__("./node_modules/process/browser.js"), __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/webpack/buildin/module.js")(module));
        },
        "./node_modules/post-robot/src/bridge/bridge.js": function(module, exports, __webpack_require__) {
            "use strict";
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            _global.global.tunnelWindows = _global.global.tunnelWindows || {};
            _global.global.tunnelWindowId = 0;
            function deleteTunnelWindow(id) {
                try {
                    _global.global.tunnelWindows[id] && delete _global.global.tunnelWindows[id].source;
                } catch (err) {}
                delete _global.global.tunnelWindows[id];
            }
            function addTunnelWindow(_ref2) {
                var name = _ref2.name, source = _ref2.source, canary = _ref2.canary, sendMessage = _ref2.sendMessage;
                !function() {
                    var tunnelWindows = _global.global.tunnelWindows, _iterator = Object.keys(tunnelWindows), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref, tunnelWindow = tunnelWindows[key];
                        try {
                            (0, _lib.noop)(tunnelWindow.source);
                        } catch (err) {
                            deleteTunnelWindow(key);
                            continue;
                        }
                        (0, _src.isWindowClosed)(tunnelWindow.source) && deleteTunnelWindow(key);
                    }
                }();
                _global.global.tunnelWindowId += 1;
                _global.global.tunnelWindows[_global.global.tunnelWindowId] = {
                    name: name,
                    source: source,
                    canary: canary,
                    sendMessage: sendMessage
                };
                return _global.global.tunnelWindowId;
            }
            _global.global.openTunnelToParent = function(_ref3) {
                var name = _ref3.name, source = _ref3.source, canary = _ref3.canary, sendMessage = _ref3.sendMessage, parentWindow = (0, 
                _src.getParent)(window);
                if (!parentWindow) throw new Error("No parent window found to open tunnel to");
                var id = addTunnelWindow({
                    name: name,
                    source: source,
                    canary: canary,
                    sendMessage: sendMessage
                });
                return _global.global.send(parentWindow, _conf.CONSTANTS.POST_MESSAGE_NAMES.OPEN_TUNNEL, {
                    name: name,
                    sendMessage: function() {
                        var tunnelWindow = function(id) {
                            return _global.global.tunnelWindows[id];
                        }(id);
                        try {
                            (0, _lib.noop)(tunnelWindow && tunnelWindow.source);
                        } catch (err) {
                            deleteTunnelWindow(id);
                            return;
                        }
                        if (tunnelWindow && tunnelWindow.source && !(0, _src.isWindowClosed)(tunnelWindow.source)) {
                            try {
                                tunnelWindow.canary();
                            } catch (err) {
                                return;
                            }
                            tunnelWindow.sendMessage.apply(this, arguments);
                        }
                    }
                }, {
                    domain: _conf.CONSTANTS.WILDCARD
                });
            };
        },
        "./node_modules/post-robot/src/bridge/child.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.openTunnelToOpener = function() {
                return _src.ZalgoPromise.try(function() {
                    var opener = (0, _src2.getOpener)(window);
                    if (opener && (0, _common.needsBridge)({
                        win: opener
                    })) {
                        (0, _common.registerRemoteWindow)(opener);
                        return awaitRemoteBridgeForWindow(opener).then(function(bridge) {
                            return bridge ? window.name ? bridge[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT].openTunnelToParent({
                                name: window.name,
                                source: window,
                                canary: function() {},
                                sendMessage: function(message) {
                                    try {
                                        (0, _lib.noop)(window);
                                    } catch (err) {
                                        return;
                                    }
                                    if (window && !window.closed) try {
                                        _global.global.receiveMessage({
                                            data: message,
                                            origin: this.origin,
                                            source: this.source
                                        });
                                    } catch (err) {
                                        _src.ZalgoPromise.reject(err);
                                    }
                                }
                            }).then(function(_ref2) {
                                var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                                if (source !== opener) throw new Error("Source does not match opener");
                                (0, _common.registerRemoteSendMessage)(source, origin, data.sendMessage);
                            }).catch(function(err) {
                                (0, _common.rejectRemoteSendMessage)(opener, err);
                                throw err;
                            }) : (0, _common.rejectRemoteSendMessage)(opener, new Error("Can not register with opener: window does not have a name")) : (0, 
                            _common.rejectRemoteSendMessage)(opener, new Error("Can not register with opener: no bridge found in opener"));
                        });
                    }
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js"), awaitRemoteBridgeForWindow = (0, 
            _lib.weakMapMemoize)(function(win) {
                return _src.ZalgoPromise.try(function() {
                    var _iterator = (0, _src2.getFrames)(win), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var _frame = _ref;
                        try {
                            if (_frame && _frame !== window && (0, _src2.isSameDomain)(_frame) && _frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) return _frame;
                        } catch (err) {
                            continue;
                        }
                    }
                    try {
                        var frame = (0, _src2.getFrameByName)(win, (0, _common.getBridgeName)((0, _src2.getDomain)()));
                        if (!frame) return;
                        return (0, _src2.isSameDomain)(frame) && frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] ? frame : new _src.ZalgoPromise(function(resolve) {
                            var interval = void 0, timeout = void 0;
                            interval = setInterval(function() {
                                if (frame && (0, _src2.isSameDomain)(frame) && frame[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) {
                                    clearInterval(interval);
                                    clearTimeout(timeout);
                                    return resolve(frame);
                                }
                            }, 100);
                            timeout = setTimeout(function() {
                                clearInterval(interval);
                                return resolve();
                            }, 2e3);
                        });
                    } catch (err) {}
                });
            });
        },
        "./node_modules/post-robot/src/bridge/common.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.documentBodyReady = void 0;
            exports.needsBridgeForBrowser = needsBridgeForBrowser;
            exports.needsBridgeForWin = needsBridgeForWin;
            exports.needsBridgeForDomain = needsBridgeForDomain;
            exports.needsBridge = function(_ref) {
                var win = _ref.win, domain = _ref.domain;
                if (!needsBridgeForBrowser()) return !1;
                if (domain && !needsBridgeForDomain(domain, win)) return !1;
                if (win && !needsBridgeForWin(win)) return !1;
                return !0;
            };
            exports.getBridgeName = getBridgeName;
            exports.isBridge = function() {
                return Boolean(window.name && window.name === getBridgeName((0, _src3.getDomain)()));
            };
            exports.registerRemoteWindow = function(win) {
                _global.global.remoteWindows.set(win, {
                    sendMessagePromise: new _src2.ZalgoPromise()
                });
            };
            exports.findRemoteWindow = findRemoteWindow;
            exports.registerRemoteSendMessage = function(win, domain, sendMessage) {
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found to register sendMessage to");
                var sendMessageWrapper = function(remoteWin, message, remoteDomain) {
                    if (remoteWin !== win) throw new Error("Remote window does not match window");
                    if (!(0, _src3.matchDomain)(remoteDomain, domain)) throw new Error("Remote domain " + remoteDomain + " does not match domain " + domain);
                    sendMessage(message);
                };
                remoteWindow.sendMessagePromise.resolve(sendMessageWrapper);
                remoteWindow.sendMessagePromise = _src2.ZalgoPromise.resolve(sendMessageWrapper);
            };
            exports.rejectRemoteSendMessage = function(win, err) {
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found on which to reject sendMessage");
                remoteWindow.sendMessagePromise.asyncReject(err);
            };
            exports.sendBridgeMessage = function(win, message, domain) {
                var messagingChild = (0, _src3.isOpener)(window, win), messagingParent = (0, _src3.isOpener)(win, window);
                if (!messagingChild && !messagingParent) throw new Error("Can only send messages to and from parent and popup windows");
                var remoteWindow = findRemoteWindow(win);
                if (!remoteWindow) throw new Error("Window not found to send message to");
                return remoteWindow.sendMessagePromise.then(function(sendMessage) {
                    return sendMessage(win, message, domain);
                });
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            function needsBridgeForBrowser() {
                return !!(0, _src3.getUserAgent)(window).match(/MSIE|trident|edge\/12|edge\/13/i) || !_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP;
            }
            function needsBridgeForWin(win) {
                return !(0, _src3.isSameTopWindow)(window, win);
            }
            function needsBridgeForDomain(domain, win) {
                if (domain) {
                    if ((0, _src3.getDomain)() !== (0, _src3.getDomainFromUrl)(domain)) return !0;
                } else if (win && !(0, _src3.isSameDomain)(win)) return !0;
                return !1;
            }
            function getBridgeName(domain) {
                var sanitizedDomain = (domain = domain || (0, _src3.getDomainFromUrl)(domain)).replace(/[^a-zA-Z0-9]+/g, "_");
                return _conf.CONSTANTS.BRIDGE_NAME_PREFIX + "_" + sanitizedDomain;
            }
            exports.documentBodyReady = new _src2.ZalgoPromise(function(resolve) {
                if (window.document && window.document.body) return resolve(window.document.body);
                var interval = setInterval(function() {
                    if (window.document && window.document.body) {
                        clearInterval(interval);
                        return resolve(window.document.body);
                    }
                }, 10);
            });
            _global.global.remoteWindows = _global.global.remoteWindows || new _src.WeakMap();
            function findRemoteWindow(win) {
                return _global.global.remoteWindows.get(win);
            }
        },
        "./node_modules/post-robot/src/bridge/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _child = __webpack_require__("./node_modules/post-robot/src/bridge/child.js");
            Object.keys(_child).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _child[key];
                    }
                });
            });
            var _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js");
            Object.keys(_common).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _common[key];
                    }
                });
            });
            var _parent = __webpack_require__("./node_modules/post-robot/src/bridge/parent.js");
            Object.keys(_parent).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _parent[key];
                    }
                });
            });
            __webpack_require__("./node_modules/post-robot/src/bridge/bridge.js");
        },
        "./node_modules/post-robot/src/bridge/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _index = __webpack_require__("./node_modules/post-robot/src/bridge/index.js");
            Object.defineProperty(exports, "openBridge", {
                enumerable: !0,
                get: function() {
                    return _index.openBridge;
                }
            });
            Object.defineProperty(exports, "linkUrl", {
                enumerable: !0,
                get: function() {
                    return _index.linkUrl;
                }
            });
            Object.defineProperty(exports, "isBridge", {
                enumerable: !0,
                get: function() {
                    return _index.isBridge;
                }
            });
            Object.defineProperty(exports, "needsBridge", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridge;
                }
            });
            Object.defineProperty(exports, "needsBridgeForBrowser", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForBrowser;
                }
            });
            Object.defineProperty(exports, "hasBridge", {
                enumerable: !0,
                get: function() {
                    return _index.hasBridge;
                }
            });
            Object.defineProperty(exports, "needsBridgeForWin", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForWin;
                }
            });
            Object.defineProperty(exports, "needsBridgeForDomain", {
                enumerable: !0,
                get: function() {
                    return _index.needsBridgeForDomain;
                }
            });
            Object.defineProperty(exports, "openTunnelToOpener", {
                enumerable: !0,
                get: function() {
                    return _index.openTunnelToOpener;
                }
            });
            Object.defineProperty(exports, "destroyBridges", {
                enumerable: !0,
                get: function() {
                    return _index.destroyBridges;
                }
            });
        },
        "./node_modules/post-robot/src/bridge/parent.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.hasBridge = function(url, domain) {
                domain = domain || (0, _src3.getDomainFromUrl)(url);
                return Boolean(_global.global.bridges[domain]);
            };
            exports.openBridge = function(url, domain) {
                domain = domain || (0, _src3.getDomainFromUrl)(url);
                if (_global.global.bridges[domain]) return _global.global.bridges[domain];
                _global.global.bridges[domain] = _src2.ZalgoPromise.try(function() {
                    if ((0, _src3.getDomain)() === domain) throw new Error("Can not open bridge on the same domain as current domain: " + domain);
                    var name = (0, _common.getBridgeName)(domain), frame = (0, _src3.getFrameByName)(window, name);
                    if (frame) throw new Error("Frame with name " + name + " already exists on page");
                    var iframe = function(name, url) {
                        _lib.log.debug("Opening bridge:", name, url);
                        var iframe = document.createElement("iframe");
                        iframe.setAttribute("name", name);
                        iframe.setAttribute("id", name);
                        iframe.setAttribute("style", "display: none; margin: 0; padding: 0; border: 0px none; overflow: hidden;");
                        iframe.setAttribute("frameborder", "0");
                        iframe.setAttribute("border", "0");
                        iframe.setAttribute("scrolling", "no");
                        iframe.setAttribute("allowTransparency", "true");
                        iframe.setAttribute("tabindex", "-1");
                        iframe.setAttribute("hidden", "true");
                        iframe.setAttribute("title", "");
                        iframe.setAttribute("role", "presentation");
                        iframe.src = url;
                        return iframe;
                    }(name, url);
                    _global.global.bridgeFrames[domain] = iframe;
                    return _common.documentBodyReady.then(function(body) {
                        body.appendChild(iframe);
                        var bridge = iframe.contentWindow;
                        !function(source, domain) {
                            _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.OPEN_TUNNEL, {
                                window: source,
                                domain: domain
                            }, function(_ref) {
                                var origin = _ref.origin, data = _ref.data;
                                if (origin !== domain) throw new Error("Domain " + domain + " does not match origin " + origin);
                                if (!data.name) throw new Error("Register window expected to be passed window name");
                                if (!data.sendMessage) throw new Error("Register window expected to be passed sendMessage method");
                                if (!_global.global.popupWindowsByName[data.name]) throw new Error("Window with name " + data.name + " does not exist, or was not opened by this window");
                                if (!_global.global.popupWindowsByName[data.name].domain) throw new Error("We do not have a registered domain for window " + data.name);
                                if (_global.global.popupWindowsByName[data.name].domain !== origin) throw new Error("Message origin " + origin + " does not matched registered window origin " + _global.global.popupWindowsByName[data.name].domain);
                                (0, _common.registerRemoteSendMessage)(_global.global.popupWindowsByName[data.name].win, domain, data.sendMessage);
                                return {
                                    sendMessage: function(message) {
                                        if (window && !window.closed) {
                                            var winDetails = _global.global.popupWindowsByName[data.name];
                                            if (winDetails) try {
                                                _global.global.receiveMessage({
                                                    data: message,
                                                    origin: winDetails.domain,
                                                    source: winDetails.win
                                                });
                                            } catch (err) {
                                                _src2.ZalgoPromise.reject(err);
                                            }
                                        }
                                    }
                                };
                            });
                        }(bridge, domain);
                        return new _src2.ZalgoPromise(function(resolve, reject) {
                            iframe.onload = resolve;
                            iframe.onerror = reject;
                        }).then(function() {
                            return (0, _lib.onChildWindowReady)(bridge, _conf.CONFIG.BRIDGE_TIMEOUT, "Bridge " + url);
                        }).then(function() {
                            return bridge;
                        });
                    });
                });
                return _global.global.bridges[domain];
            };
            exports.linkUrl = function(win, url) {
                var winOptions = _global.global.popupWindowsByWin.get(win);
                if (winOptions) {
                    winOptions.domain = (0, _src3.getDomainFromUrl)(url);
                    (0, _common.registerRemoteWindow)(win);
                }
            };
            exports.destroyBridges = function() {
                for (var _iterator2 = Object.keys(_global.global.bridgeFrames), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref3 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref3 = _i2.value;
                    }
                    var domain = _ref3, frame = _global.global.bridgeFrames[domain];
                    frame.parentNode && frame.parentNode.removeChild(frame);
                }
                _global.global.bridgeFrames = {};
                _global.global.bridges = {};
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _common = __webpack_require__("./node_modules/post-robot/src/bridge/common.js");
            _global.global.bridges = _global.global.bridges || {};
            _global.global.bridgeFrames = _global.global.bridgeFrames || {};
            _global.global.popupWindowsByWin = _global.global.popupWindowsByWin || new _src.WeakMap();
            _global.global.popupWindowsByName = _global.global.popupWindowsByName || {};
            var windowOpen = window.open;
            window.open = function(url, name, options, last) {
                var domain = url;
                if (url && 0 === url.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL)) {
                    var _url$split = url.split("|");
                    domain = _url$split[0];
                    url = _url$split[1];
                }
                domain && (domain = (0, _src3.getDomainFromUrl)(domain));
                var win = windowOpen.call(this, url, name, options, last);
                if (!win) return win;
                url && (0, _common.registerRemoteWindow)(win);
                var _iterator = Object.keys(_global.global.popupWindowsByName), _isArray = Array.isArray(_iterator), _i = 0;
                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref2 = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref2 = _i.value;
                    }
                    var winName = _ref2;
                    (0, _src3.isWindowClosed)(_global.global.popupWindowsByName[winName].win) && delete _global.global.popupWindowsByName[winName];
                }
                if (name && win) {
                    var winOptions = _global.global.popupWindowsByWin.get(win) || _global.global.popupWindowsByName[name] || {};
                    winOptions.name = winOptions.name || name;
                    winOptions.win = winOptions.win || win;
                    winOptions.domain = winOptions.domain || domain;
                    _global.global.popupWindowsByWin.set(win, winOptions);
                    _global.global.popupWindowsByName[name] = winOptions;
                }
                return win;
            };
        },
        "./node_modules/post-robot/src/clean.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.cleanUpWindow = function(win) {
                var requestPromises = _global.global.requestPromises.get(win);
                if (requestPromises) for (var _iterator = requestPromises, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var promise = _ref;
                    promise.reject(new Error("No response from window - cleaned up"));
                }
                _global.global.popupWindowsByWin && _global.global.popupWindowsByWin.delete(win);
                _global.global.remoteWindows && _global.global.remoteWindows.delete(win);
                _global.global.requestPromises.delete(win);
                _global.global.methods.delete(win);
                _global.global.readyPromises.delete(win);
            };
            __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            var _global = __webpack_require__("./node_modules/post-robot/src/global.js");
        },
        "./node_modules/post-robot/src/compat/ie.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.emulateIERestrictions = function(sourceWindow, targetWindow) {
                if (!_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP && !1 === (0, _src.isSameTopWindow)(sourceWindow, targetWindow)) throw new Error("Can not send and receive post messages between two different windows (disabled to emulate IE)");
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
        },
        "./node_modules/post-robot/src/compat/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _ie = __webpack_require__("./node_modules/post-robot/src/compat/ie.js");
            Object.keys(_ie).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ie[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/conf/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONFIG = void 0;
            var _ALLOWED_POST_MESSAGE, _constants = __webpack_require__("./node_modules/post-robot/src/conf/constants.js"), CONFIG = exports.CONFIG = {
                ALLOW_POSTMESSAGE_POPUP: !("__ALLOW_POSTMESSAGE_POPUP__" in window) || window.__ALLOW_POSTMESSAGE_POPUP__,
                LOG_LEVEL: "info",
                BRIDGE_TIMEOUT: 5e3,
                CHILD_WINDOW_TIMEOUT: 5e3,
                ACK_TIMEOUT: -1 !== window.navigator.userAgent.match(/MSIE/i) ? 2e3 : 1e3,
                RES_TIMEOUT: -1,
                LOG_TO_PAGE: !1,
                ALLOWED_POST_MESSAGE_METHODS: (_ALLOWED_POST_MESSAGE = {}, _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = !0, 
                _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.BRIDGE] = !0, _ALLOWED_POST_MESSAGE[_constants.CONSTANTS.SEND_STRATEGIES.GLOBAL] = !0, 
                _ALLOWED_POST_MESSAGE),
                ALLOW_SAME_ORIGIN: !1
            };
            0 === window.location.href.indexOf(_constants.CONSTANTS.FILE_PROTOCOL) && (CONFIG.ALLOW_POSTMESSAGE_POPUP = !0);
        },
        "./node_modules/post-robot/src/conf/constants.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = {
                POST_MESSAGE_TYPE: {
                    REQUEST: "postrobot_message_request",
                    RESPONSE: "postrobot_message_response",
                    ACK: "postrobot_message_ack"
                },
                POST_MESSAGE_ACK: {
                    SUCCESS: "success",
                    ERROR: "error"
                },
                POST_MESSAGE_NAMES: {
                    METHOD: "postrobot_method",
                    HELLO: "postrobot_ready",
                    OPEN_TUNNEL: "postrobot_open_tunnel"
                },
                WINDOW_TYPES: {
                    FULLPAGE: "fullpage",
                    POPUP: "popup",
                    IFRAME: "iframe"
                },
                WINDOW_PROPS: {
                    POSTROBOT: "__postRobot__"
                },
                SERIALIZATION_TYPES: {
                    METHOD: "postrobot_method",
                    ERROR: "postrobot_error",
                    PROMISE: "postrobot_promise",
                    ZALGO_PROMISE: "postrobot_zalgo_promise",
                    REGEX: "regex"
                },
                SEND_STRATEGIES: {
                    POST_MESSAGE: "postrobot_post_message",
                    BRIDGE: "postrobot_bridge",
                    GLOBAL: "postrobot_global"
                },
                MOCK_PROTOCOL: "mock:",
                FILE_PROTOCOL: "file:",
                BRIDGE_NAME_PREFIX: "__postrobot_bridge__",
                POSTROBOT_PROXY: "__postrobot_proxy__",
                WILDCARD: "*"
            };
            var POST_MESSAGE_NAMES = exports.POST_MESSAGE_NAMES = {
                METHOD: "postrobot_method",
                HELLO: "postrobot_hello",
                OPEN_TUNNEL: "postrobot_open_tunnel"
            };
            exports.POST_MESSAGE_NAMES_LIST = Object.keys(POST_MESSAGE_NAMES).map(function(key) {
                return POST_MESSAGE_NAMES[key];
            });
        },
        "./node_modules/post-robot/src/conf/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _config = __webpack_require__("./node_modules/post-robot/src/conf/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
            var _constants = __webpack_require__("./node_modules/post-robot/src/conf/constants.js");
            Object.keys(_constants).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _constants[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/drivers/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _receive = __webpack_require__("./node_modules/post-robot/src/drivers/receive/index.js");
            Object.keys(_receive).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _receive[key];
                    }
                });
            });
            var _send = __webpack_require__("./node_modules/post-robot/src/drivers/send/index.js");
            Object.keys(_send).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _send[key];
                    }
                });
            });
            var _listeners = __webpack_require__("./node_modules/post-robot/src/drivers/listeners.js");
            Object.keys(_listeners).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _listeners[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/drivers/listeners.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.resetListeners = function() {
                _global.global.responseListeners = {};
                _global.global.requestListeners = {};
            };
            exports.addResponseListener = function(hash, listener) {
                _global.global.responseListeners[hash] = listener;
            };
            exports.getResponseListener = function(hash) {
                return _global.global.responseListeners[hash];
            };
            exports.deleteResponseListener = function(hash) {
                delete _global.global.responseListeners[hash];
            };
            exports.markResponseListenerErrored = function(hash) {
                _global.global.erroredResponseListeners[hash] = !0;
            };
            exports.isResponseListenerErrored = function(hash) {
                return Boolean(_global.global.erroredResponseListeners[hash]);
            };
            exports.getRequestListener = getRequestListener;
            exports.addRequestListener = function addRequestListener(_ref5, listener) {
                var name = _ref5.name, win = _ref5.win, domain = _ref5.domain;
                if (!name || "string" != typeof name) throw new Error("Name required to add request listener");
                if (Array.isArray(win)) {
                    for (var listenersCollection = [], _iterator2 = win, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref6;
                        if (_isArray2) {
                            if (_i3 >= _iterator2.length) break;
                            _ref6 = _iterator2[_i3++];
                        } else {
                            if ((_i3 = _iterator2.next()).done) break;
                            _ref6 = _i3.value;
                        }
                        var item = _ref6;
                        listenersCollection.push(addRequestListener({
                            name: name,
                            domain: domain,
                            win: item
                        }, listener));
                    }
                    return {
                        cancel: function() {
                            for (var _iterator3 = listenersCollection, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref7;
                                if (_isArray3) {
                                    if (_i4 >= _iterator3.length) break;
                                    _ref7 = _iterator3[_i4++];
                                } else {
                                    if ((_i4 = _iterator3.next()).done) break;
                                    _ref7 = _i4.value;
                                }
                                var cancelListener = _ref7;
                                cancelListener.cancel();
                            }
                        }
                    };
                }
                if (Array.isArray(domain)) {
                    for (var _listenersCollection = [], _iterator4 = domain, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray4) {
                            if (_i5 >= _iterator4.length) break;
                            _ref8 = _iterator4[_i5++];
                        } else {
                            if ((_i5 = _iterator4.next()).done) break;
                            _ref8 = _i5.value;
                        }
                        var _item = _ref8;
                        _listenersCollection.push(addRequestListener({
                            name: name,
                            win: win,
                            domain: _item
                        }, listener));
                    }
                    return {
                        cancel: function() {
                            for (var _iterator5 = _listenersCollection, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                                var _ref9;
                                if (_isArray5) {
                                    if (_i6 >= _iterator5.length) break;
                                    _ref9 = _iterator5[_i6++];
                                } else {
                                    if ((_i6 = _iterator5.next()).done) break;
                                    _ref9 = _i6.value;
                                }
                                var cancelListener = _ref9;
                                cancelListener.cancel();
                            }
                        }
                    };
                }
                var existingListener = getRequestListener({
                    name: name,
                    win: win,
                    domain: domain
                });
                win && win !== _conf.CONSTANTS.WILDCARD || (win = _global.global.WINDOW_WILDCARD);
                domain = domain || _conf.CONSTANTS.WILDCARD;
                if (existingListener) throw win && domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString() + " for " + (win === _global.global.WINDOW_WILDCARD ? "wildcard" : "specified") + " window") : win ? new Error("Request listener already exists for " + name + " for " + (win === _global.global.WINDOW_WILDCARD ? "wildcard" : "specified") + " window") : domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString()) : new Error("Request listener already exists for " + name);
                var requestListeners = _global.global.requestListeners;
                var nameListeners = requestListeners[name];
                if (!nameListeners) {
                    nameListeners = new _src.WeakMap();
                    requestListeners[name] = nameListeners;
                }
                var winListeners = nameListeners.get(win);
                if (!winListeners) {
                    winListeners = {};
                    nameListeners.set(win, winListeners);
                }
                var strDomain = domain.toString();
                var regexListeners = winListeners[__DOMAIN_REGEX__];
                var regexListener = void 0;
                if ((0, _lib.isRegex)(domain)) {
                    if (!regexListeners) {
                        regexListeners = [];
                        winListeners[__DOMAIN_REGEX__] = regexListeners;
                    }
                    regexListener = {
                        regex: domain,
                        listener: listener
                    };
                    regexListeners.push(regexListener);
                } else winListeners[strDomain] = listener;
                return {
                    cancel: function() {
                        if (winListeners) {
                            delete winListeners[strDomain];
                            win && 0 === Object.keys(winListeners).length && nameListeners.delete(win);
                            regexListener && regexListeners.splice(regexListeners.indexOf(regexListener, 1));
                        }
                    }
                };
            };
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            _global.global.responseListeners = _global.global.responseListeners || {};
            _global.global.requestListeners = _global.global.requestListeners || {};
            _global.global.WINDOW_WILDCARD = _global.global.WINDOW_WILDCARD || new function() {}();
            _global.global.erroredResponseListeners = _global.global.erroredResponseListeners || {};
            var __DOMAIN_REGEX__ = "__domain_regex__";
            function getRequestListener(_ref) {
                var name = _ref.name, win = _ref.win, domain = _ref.domain;
                win === _conf.CONSTANTS.WILDCARD && (win = null);
                domain === _conf.CONSTANTS.WILDCARD && (domain = null);
                if (!name) throw new Error("Name required to get request listener");
                var nameListeners = _global.global.requestListeners[name];
                if (nameListeners) for (var _arr = [ win, _global.global.WINDOW_WILDCARD ], _i = 0; _i < _arr.length; _i++) {
                    var winQualifier = _arr[_i], winListeners = winQualifier && nameListeners.get(winQualifier);
                    if (winListeners) {
                        if (domain && "string" == typeof domain) {
                            if (winListeners[domain]) return winListeners[domain];
                            if (winListeners[__DOMAIN_REGEX__]) {
                                var _iterator = winListeners[__DOMAIN_REGEX__], _isArray = Array.isArray(_iterator), _i2 = 0;
                                for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                    var _ref3;
                                    if (_isArray) {
                                        if (_i2 >= _iterator.length) break;
                                        _ref3 = _iterator[_i2++];
                                    } else {
                                        if ((_i2 = _iterator.next()).done) break;
                                        _ref3 = _i2.value;
                                    }
                                    var _ref4 = _ref3, regex = _ref4.regex, listener = _ref4.listener;
                                    if ((0, _src2.matchDomain)(regex, domain)) return listener;
                                }
                            }
                        }
                        if (winListeners[_conf.CONSTANTS.WILDCARD]) return winListeners[_conf.CONSTANTS.WILDCARD];
                    }
                }
            }
        },
        "./node_modules/post-robot/src/drivers/receive/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.receiveMessage = receiveMessage;
            exports.messageListener = messageListener;
            exports.listenForMessages = function() {
                (0, _lib.addEventListener)(window, "message", messageListener);
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _types = __webpack_require__("./node_modules/post-robot/src/drivers/receive/types.js");
            _global.global.receivedMessages = _global.global.receivedMessages || [];
            function receiveMessage(event) {
                if (!window || window.closed) throw new Error("Message recieved in closed window");
                try {
                    if (!event.source) return;
                } catch (err) {
                    return;
                }
                var source = event.source, origin = event.origin, message = function(message) {
                    var parsedMessage = void 0;
                    try {
                        parsedMessage = (0, _lib.jsonParse)(message);
                    } catch (err) {
                        return;
                    }
                    if (parsedMessage && "object" === (void 0 === parsedMessage ? "undefined" : _typeof(parsedMessage)) && null !== parsedMessage && (parsedMessage = parsedMessage[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT]) && "object" === (void 0 === parsedMessage ? "undefined" : _typeof(parsedMessage)) && null !== parsedMessage && parsedMessage.type && "string" == typeof parsedMessage.type && _types.RECEIVE_MESSAGE_TYPES[parsedMessage.type]) return parsedMessage;
                }(event.data);
                if (message) {
                    if (!message.sourceDomain || "string" != typeof message.sourceDomain) throw new Error("Expected message to have sourceDomain");
                    0 !== message.sourceDomain.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL) && 0 !== message.sourceDomain.indexOf(_conf.CONSTANTS.FILE_PROTOCOL) || (origin = message.sourceDomain);
                    if (-1 === _global.global.receivedMessages.indexOf(message.id)) {
                        _global.global.receivedMessages.push(message.id);
                        var level = void 0;
                        level = -1 !== _conf.POST_MESSAGE_NAMES_LIST.indexOf(message.name) || message.type === _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK ? "debug" : "error" === message.ack ? "error" : "info";
                        _lib.log.logLevel(level, [ "\n\n\t", "#receive", message.type.replace(/^postrobot_message_/, ""), "::", message.name, "::", origin, "\n\n", message ]);
                        if (!(0, _src.isWindowClosed)(source) || message.fireAndForget) {
                            message.data && (message.data = (0, _lib.deserializeMethods)(source, origin, message.data));
                            _types.RECEIVE_MESSAGE_TYPES[message.type](source, origin, message);
                        } else _lib.log.debug("Source window is closed - can not send " + message.type + " " + message.name);
                    }
                }
            }
            function messageListener(event) {
                try {
                    (0, _lib.noop)(event.source);
                } catch (err) {
                    return;
                }
                var messageEvent = {
                    source: event.source || event.sourceElement,
                    origin: event.origin || event.originalEvent && event.originalEvent.origin,
                    data: event.data
                };
                try {
                    __webpack_require__("./node_modules/post-robot/src/compat/index.js").emulateIERestrictions(messageEvent.source, window);
                } catch (err) {
                    return;
                }
                receiveMessage(messageEvent);
            }
            _global.global.receiveMessage = receiveMessage;
        },
        "./node_modules/post-robot/src/drivers/receive/types.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.RECEIVE_MESSAGE_TYPES = void 0;
            var _RECEIVE_MESSAGE_TYPE, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _send = __webpack_require__("./node_modules/post-robot/src/drivers/send/index.js"), _listeners = __webpack_require__("./node_modules/post-robot/src/drivers/listeners.js");
            exports.RECEIVE_MESSAGE_TYPES = ((_RECEIVE_MESSAGE_TYPE = {})[_conf.CONSTANTS.POST_MESSAGE_TYPE.ACK] = function(source, origin, message) {
                if (!(0, _listeners.isResponseListenerErrored)(message.hash)) {
                    var options = (0, _listeners.getResponseListener)(message.hash);
                    if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
                    options.ack = !0;
                }
            }, _RECEIVE_MESSAGE_TYPE[_conf.CONSTANTS.POST_MESSAGE_TYPE.REQUEST] = function(source, origin, message) {
                var options = (0, _listeners.getRequestListener)({
                    name: message.name,
                    win: source,
                    domain: origin
                });
                function respond(data) {
                    return message.fireAndForget || (0, _src2.isWindowClosed)(source) ? _src.ZalgoPromise.resolve() : (0, 
                    _send.sendMessage)(source, _extends({
                        target: message.originalSource,
                        hash: message.hash,
                        name: message.name
                    }, data), origin);
                }
                return _src.ZalgoPromise.all([ respond({
                    type: _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK
                }), _src.ZalgoPromise.try(function() {
                    if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Request origin " + origin + " does not match domain " + options.domain.toString());
                    var data = message.data;
                    return options.handler({
                        source: source,
                        origin: origin,
                        data: data
                    });
                }).then(function(data) {
                    return respond({
                        type: _conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,
                        ack: _conf.CONSTANTS.POST_MESSAGE_ACK.SUCCESS,
                        data: data
                    });
                }, function(err) {
                    var error = (0, _lib.stringifyError)(err).replace(/^Error: /, ""), code = err.code;
                    return respond({
                        type: _conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE,
                        ack: _conf.CONSTANTS.POST_MESSAGE_ACK.ERROR,
                        error: error,
                        code: code
                    });
                }) ]).then(_lib.noop).catch(function(err) {
                    if (options && options.handleError) return options.handleError(err);
                    _lib.log.error((0, _lib.stringifyError)(err));
                });
            }, _RECEIVE_MESSAGE_TYPE[_conf.CONSTANTS.POST_MESSAGE_TYPE.RESPONSE] = function(source, origin, message) {
                if (!(0, _listeners.isResponseListenerErrored)(message.hash)) {
                    var options = (0, _listeners.getResponseListener)(message.hash);
                    if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                    if (!(0, _src2.matchDomain)(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + (0, 
                    _src2.stringifyDomainPattern)(options.domain));
                    (0, _listeners.deleteResponseListener)(message.hash);
                    if (message.ack === _conf.CONSTANTS.POST_MESSAGE_ACK.ERROR) {
                        var err = new Error(message.error);
                        message.code && (err.code = message.code);
                        return options.respond(err, null);
                    }
                    if (message.ack === _conf.CONSTANTS.POST_MESSAGE_ACK.SUCCESS) {
                        var data = message.data || message.response;
                        return options.respond(null, {
                            source: source,
                            origin: origin,
                            data: data
                        });
                    }
                }
            }, _RECEIVE_MESSAGE_TYPE);
        },
        "./node_modules/post-robot/src/drivers/send/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            };
            exports.sendMessage = function(win, message, domain) {
                return _src2.ZalgoPromise.try(function() {
                    var _jsonStringify;
                    message = function(win, message) {
                        var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, id = (0, 
                        _lib.uniqueID)(), type = (0, _lib.getWindowType)(), sourceDomain = (0, _src.getDomain)(window);
                        return _extends({}, message, options, {
                            sourceDomain: sourceDomain,
                            id: message.id || id,
                            windowType: type
                        });
                    }(win, message, {
                        data: (0, _lib.serializeMethods)(win, domain, message.data),
                        domain: domain
                    });
                    var level = void 0;
                    level = -1 !== _conf.POST_MESSAGE_NAMES_LIST.indexOf(message.name) || message.type === _conf.CONSTANTS.POST_MESSAGE_TYPE.ACK ? "debug" : "error" === message.ack ? "error" : "info";
                    _lib.log.logLevel(level, [ "\n\n\t", "#send", message.type.replace(/^postrobot_message_/, ""), "::", message.name, "::", domain || _conf.CONSTANTS.WILDCARD, "\n\n", message ]);
                    if (win === window && !_conf.CONFIG.ALLOW_SAME_ORIGIN) throw new Error("Attemping to send message to self");
                    if ((0, _src.isWindowClosed)(win)) throw new Error("Window is closed");
                    _lib.log.debug("Running send message strategies", message);
                    var messages = [], serializedMessage = (0, _lib.jsonStringify)(((_jsonStringify = {})[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] = message, 
                    _jsonStringify), null, 2);
                    return _src2.ZalgoPromise.map(Object.keys(_strategies.SEND_MESSAGE_STRATEGIES), function(strategyName) {
                        return _src2.ZalgoPromise.try(function() {
                            if (!_conf.CONFIG.ALLOWED_POST_MESSAGE_METHODS[strategyName]) throw new Error("Strategy disallowed: " + strategyName);
                            return _strategies.SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
                        }).then(function() {
                            messages.push(strategyName + ": success");
                            return !0;
                        }, function(err) {
                            messages.push(strategyName + ": " + (0, _lib.stringifyError)(err) + "\n");
                            return !1;
                        });
                    }).then(function(results) {
                        var success = results.some(Boolean), status = message.type + " " + message.name + " " + (success ? "success" : "error") + ":\n  - " + messages.join("\n  - ") + "\n";
                        _lib.log.debug(status);
                        if (!success) throw new Error(status);
                    });
                });
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _strategies = __webpack_require__("./node_modules/post-robot/src/drivers/send/strategies.js");
        },
        "./node_modules/post-robot/src/drivers/send/strategies.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.SEND_MESSAGE_STRATEGIES = void 0;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), SEND_MESSAGE_STRATEGIES = exports.SEND_MESSAGE_STRATEGIES = {};
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.POST_MESSAGE] = function(win, serializedMessage, domain) {
                try {
                    __webpack_require__("./node_modules/post-robot/src/compat/index.js").emulateIERestrictions(window, win);
                } catch (err) {
                    return;
                }
                (Array.isArray(domain) ? domain : "string" == typeof domain ? [ domain ] : [ _conf.CONSTANTS.WILDCARD ]).map(function(dom) {
                    if (0 === dom.indexOf(_conf.CONSTANTS.MOCK_PROTOCOL)) {
                        if (window.location.protocol === _conf.CONSTANTS.FILE_PROTOCOL) return _conf.CONSTANTS.WILDCARD;
                        if (!(0, _src.isActuallySameDomain)(win)) throw new Error("Attempting to send messsage to mock domain " + dom + ", but window is actually cross-domain");
                        return (0, _src.getActualDomain)(win);
                    }
                    return 0 === dom.indexOf(_conf.CONSTANTS.FILE_PROTOCOL) ? _conf.CONSTANTS.WILDCARD : dom;
                }).forEach(function(dom) {
                    return win.postMessage(serializedMessage, dom);
                });
            };
            var _require = __webpack_require__("./node_modules/post-robot/src/bridge/index.js"), sendBridgeMessage = _require.sendBridgeMessage, needsBridgeForBrowser = _require.needsBridgeForBrowser, isBridge = _require.isBridge;
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.BRIDGE] = function(win, serializedMessage, domain) {
                if (needsBridgeForBrowser() || isBridge()) {
                    if ((0, _src.isSameDomain)(win)) throw new Error("Post message through bridge disabled between same domain windows");
                    if (!1 !== (0, _src.isSameTopWindow)(window, win)) throw new Error("Can only use bridge to communicate between two different windows, not between frames");
                    return sendBridgeMessage(win, serializedMessage, domain);
                }
            };
            SEND_MESSAGE_STRATEGIES[_conf.CONSTANTS.SEND_STRATEGIES.GLOBAL] = function(win, serializedMessage) {
                if ((0, _lib.needsGlobalMessagingForBrowser)()) {
                    if (!(0, _src.isSameDomain)(win)) throw new Error("Post message through global disabled between different domain windows");
                    if (!1 !== (0, _src.isSameTopWindow)(window, win)) throw new Error("Can only use global to communicate between two different windows, not between frames");
                    var foreignGlobal = win[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT];
                    if (!foreignGlobal) throw new Error("Can not find postRobot global on foreign window");
                    return foreignGlobal.receiveMessage({
                        source: window,
                        origin: (0, _src.getDomain)(),
                        data: serializedMessage
                    });
                }
            };
        },
        "./node_modules/post-robot/src/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.global = void 0;
            var _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            (exports.global = window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] = window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT] || {}).registerSelf = function() {};
        },
        "./node_modules/post-robot/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./node_modules/post-robot/src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./node_modules/post-robot/src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.bridge = exports.Promise = exports.cleanUpWindow = void 0;
            var _public = __webpack_require__("./node_modules/post-robot/src/public/index.js");
            Object.keys(_public).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _public[key];
                    }
                });
            });
            var _clean = __webpack_require__("./node_modules/post-robot/src/clean.js");
            Object.defineProperty(exports, "cleanUpWindow", {
                enumerable: !0,
                get: function() {
                    return _clean.cleanUpWindow;
                }
            });
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            Object.defineProperty(exports, "Promise", {
                enumerable: !0,
                get: function() {
                    return _src.ZalgoPromise;
                }
            });
            exports.init = init;
            var _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            exports.bridge = __webpack_require__("./node_modules/post-robot/src/bridge/interface.js");
            function init() {
                if (!_global.global.initialized) {
                    (0, _drivers.listenForMessages)();
                    __webpack_require__("./node_modules/post-robot/src/bridge/index.js").openTunnelToOpener();
                    (0, _lib.initOnReady)();
                    (0, _lib.listenForMethods)({
                        on: _public.on,
                        send: _public.send
                    });
                }
                _global.global.initialized = !0;
            }
            init();
        },
        "./node_modules/post-robot/src/lib/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js");
            Object.keys(_util).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _util[key];
                    }
                });
            });
            var _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js");
            Object.keys(_log).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _log[key];
                    }
                });
            });
            var _serialize = __webpack_require__("./node_modules/post-robot/src/lib/serialize.js");
            Object.keys(_serialize).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _serialize[key];
                    }
                });
            });
            var _ready = __webpack_require__("./node_modules/post-robot/src/lib/ready.js");
            Object.keys(_ready).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ready[key];
                    }
                });
            });
        },
        "./node_modules/post-robot/src/lib/log.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.log = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js"), LOG_LEVELS = [ "debug", "info", "warn", "error" ];
            Function.prototype.bind && window.console && "object" === _typeof(console.log) && [ "log", "info", "warn", "error" ].forEach(function(method) {
                console[method] = this.bind(console[method], console);
            }, Function.prototype.call);
            var log = exports.log = {
                clearLogs: function() {
                    window.console && window.console.clear && window.console.clear();
                    if (_conf.CONFIG.LOG_TO_PAGE) {
                        var container = document.getElementById("postRobotLogs");
                        container && container.parentNode && container.parentNode.removeChild(container);
                    }
                },
                writeToPage: function(level, args) {
                    setTimeout(function() {
                        var container = document.getElementById("postRobotLogs");
                        if (!container) {
                            (container = document.createElement("div")).id = "postRobotLogs";
                            container.style.cssText = "width: 800px; font-family: monospace; white-space: pre-wrap;";
                            document.body && document.body.appendChild(container);
                        }
                        var el = document.createElement("div"), date = new Date().toString().split(" ")[4], payload = Array.prototype.slice.call(args).map(function(item) {
                            if ("string" == typeof item) return item;
                            if (!item) return Object.prototype.toString.call(item);
                            var json = void 0;
                            try {
                                json = (0, _util.jsonStringify)(item, null, 2);
                            } catch (err) {
                                json = "[object]";
                            }
                            return "\n\n" + json + "\n\n";
                        }).join(" "), msg = date + " " + level + " " + payload;
                        el.innerHTML = msg;
                        var color = {
                            log: "#ddd",
                            warn: "orange",
                            error: "red",
                            info: "blue",
                            debug: "#aaa"
                        }[level];
                        el.style.cssText = "margin-top: 10px; color: " + color + ";";
                        container.childNodes.length ? container.insertBefore(el, container.childNodes[0]) : container.appendChild(el);
                    });
                },
                logLevel: function(level, args) {
                    setTimeout(function() {
                        try {
                            var logLevel = window.LOG_LEVEL || _conf.CONFIG.LOG_LEVEL;
                            if ("disabled" === logLevel || LOG_LEVELS.indexOf(level) < LOG_LEVELS.indexOf(logLevel)) return;
                            (args = Array.prototype.slice.call(args)).unshift("" + window.location.host + window.location.pathname);
                            args.unshift("::");
                            args.unshift("" + (0, _util.getWindowType)().toLowerCase());
                            args.unshift("[post-robot]");
                            _conf.CONFIG.LOG_TO_PAGE && log.writeToPage(level, args);
                            if (!window.console) return;
                            window.console[level] || (level = "log");
                            if (!window.console[level]) return;
                            window.console[level].apply(window.console, args);
                        } catch (err) {}
                    }, 1);
                },
                debug: function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    log.logLevel("debug", args);
                },
                info: function() {
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    log.logLevel("info", args);
                },
                warn: function() {
                    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    log.logLevel("warn", args);
                },
                error: function() {
                    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                    log.logLevel("error", args);
                }
            };
        },
        "./node_modules/post-robot/src/lib/ready.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.onHello = onHello;
            exports.sayHello = sayHello;
            exports.initOnReady = function() {
                onHello(function(_ref3) {
                    var source = _ref3.source, origin = _ref3.origin, promise = _global.global.readyPromises.get(source) || new _src3.ZalgoPromise();
                    promise.resolve({
                        origin: origin
                    });
                    _global.global.readyPromises.set(source, promise);
                });
                var parent = (0, _src2.getAncestor)();
                parent && sayHello(parent).catch(function(err) {
                    _log.log.debug((0, _util.stringifyError)(err));
                });
            };
            exports.onChildWindowReady = function(win) {
                var timeout = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3, name = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Window", promise = _global.global.readyPromises.get(win);
                if (promise) return promise;
                promise = new _src3.ZalgoPromise();
                _global.global.readyPromises.set(win, promise);
                -1 !== timeout && setTimeout(function() {
                    return promise.reject(new Error(name + " did not load after " + timeout + "ms"));
                }, timeout);
                return promise;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js");
            _global.global.readyPromises = _global.global.readyPromises || new _src.WeakMap();
            function onHello(handler) {
                _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.HELLO, {
                    domain: _conf.CONSTANTS.WILDCARD
                }, function(_ref) {
                    var source = _ref.source, origin = _ref.origin;
                    return handler({
                        source: source,
                        origin: origin
                    });
                });
            }
            function sayHello(win) {
                return _global.global.send(win, _conf.CONSTANTS.POST_MESSAGE_NAMES.HELLO, {}, {
                    domain: _conf.CONSTANTS.WILDCARD,
                    timeout: -1
                }).then(function(_ref2) {
                    return {
                        origin: _ref2.origin
                    };
                });
            }
        },
        "./node_modules/post-robot/src/lib/serialize.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.listenForMethods = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.serializeMethod = serializeMethod;
            exports.serializeMethods = function(destination, domain, obj) {
                return (0, _util.replaceObject)({
                    obj: obj
                }, function(item, key) {
                    return "function" == typeof item ? serializeMethod(destination, domain, item, key.toString()) : item instanceof Error ? (err = item, 
                    {
                        __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.ERROR,
                        __message__: (0, _util.stringifyError)(err),
                        __code__: err.code
                    }) : window.Promise && item instanceof window.Promise ? function(destination, domain, promise, name) {
                        return {
                            __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.PROMISE,
                            __then__: serializeMethod(destination, domain, function(resolve, reject) {
                                return promise.then(resolve, reject);
                            }, name + ".then")
                        };
                    }(destination, domain, item, key.toString()) : _src3.ZalgoPromise.isPromise(item) ? function(destination, domain, promise, name) {
                        return {
                            __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE,
                            __then__: serializeMethod(destination, domain, function(resolve, reject) {
                                return promise.then(resolve, reject);
                            }, name + ".then")
                        };
                    }(destination, domain, item, key.toString()) : (0, _util.isRegex)(item) ? (regex = item, 
                    {
                        __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.REGEX,
                        __source__: regex.source
                    }) : void 0;
                    var err, regex;
                }).obj;
            };
            exports.deserializeMethod = deserializeMethod;
            exports.deserializeError = deserializeError;
            exports.deserializeZalgoPromise = deserializeZalgoPromise;
            exports.deserializePromise = deserializePromise;
            exports.deserializeRegex = deserializeRegex;
            exports.deserializeMethods = function(source, origin, obj) {
                return (0, _util.replaceObject)({
                    obj: obj
                }, function(item) {
                    if ("object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item) return isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.METHOD) ? deserializeMethod(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.ERROR) ? deserializeError(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.PROMISE) ? deserializePromise(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.ZALGO_PROMISE) ? deserializeZalgoPromise(source, origin, item) : isSerialized(item, _conf.CONSTANTS.SERIALIZATION_TYPES.REGEX) ? deserializeRegex(source, origin, item) : void 0;
                }).obj;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js"), _util = __webpack_require__("./node_modules/post-robot/src/lib/util.js"), _log = __webpack_require__("./node_modules/post-robot/src/lib/log.js");
            _global.global.methods = _global.global.methods || new _src.WeakMap();
            exports.listenForMethods = (0, _util.once)(function() {
                _global.global.on(_conf.CONSTANTS.POST_MESSAGE_NAMES.METHOD, {
                    origin: _conf.CONSTANTS.WILDCARD
                }, function(_ref) {
                    var source = _ref.source, origin = _ref.origin, data = _ref.data, methods = _global.global.methods.get(source);
                    if (!methods) throw new Error("Could not find any methods this window has privileges to call");
                    var meth = methods[data.id];
                    if (!meth) throw new Error("Could not find method with id: " + data.id);
                    if (!(0, _src2.matchDomain)(meth.domain, origin)) throw new Error("Method domain " + meth.domain + " does not match origin " + origin);
                    _log.log.debug("Call local method", data.name, data.args);
                    return _src3.ZalgoPromise.try(function() {
                        return meth.method.apply({
                            source: source,
                            origin: origin,
                            data: data
                        }, data.args);
                    }).then(function(result) {
                        return {
                            result: result,
                            id: data.id,
                            name: data.name
                        };
                    });
                });
            });
            function isSerialized(item, type) {
                return "object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item && item.__type__ === type;
            }
            function serializeMethod(destination, domain, method, name) {
                var id = (0, _util.uniqueID)(), methods = _global.global.methods.get(destination);
                if (!methods) {
                    methods = {};
                    _global.global.methods.set(destination, methods);
                }
                methods[id] = {
                    domain: domain,
                    method: method
                };
                return {
                    __type__: _conf.CONSTANTS.SERIALIZATION_TYPES.METHOD,
                    __id__: id,
                    __name__: name
                };
            }
            function deserializeMethod(source, origin, obj) {
                function wrapper() {
                    var args = Array.prototype.slice.call(arguments);
                    _log.log.debug("Call foreign method", obj.__name__, args);
                    return _global.global.send(source, _conf.CONSTANTS.POST_MESSAGE_NAMES.METHOD, {
                        id: obj.__id__,
                        name: obj.__name__,
                        args: args
                    }, {
                        domain: origin,
                        timeout: -1
                    }).then(function(_ref2) {
                        var data = _ref2.data;
                        _log.log.debug("Got foreign method result", obj.__name__, data.result);
                        return data.result;
                    }, function(err) {
                        _log.log.debug("Got foreign method error", (0, _util.stringifyError)(err));
                        throw err;
                    });
                }
                wrapper.__name__ = obj.__name__;
                wrapper.__xdomain__ = !0;
                wrapper.source = source;
                wrapper.origin = origin;
                return wrapper;
            }
            function deserializeError(source, origin, obj) {
                var err = new Error(obj.__message__);
                obj.__code__ && (err.code = obj.__code__);
                return err;
            }
            function deserializeZalgoPromise(source, origin, prom) {
                return new _src3.ZalgoPromise(function(resolve, reject) {
                    return deserializeMethod(source, origin, prom.__then__)(resolve, reject);
                });
            }
            function deserializePromise(source, origin, prom) {
                return window.Promise ? new window.Promise(function(resolve, reject) {
                    return deserializeMethod(source, origin, prom.__then__)(resolve, reject);
                }) : deserializeZalgoPromise(source, origin, prom);
            }
            function deserializeRegex(source, origin, item) {
                return new RegExp(item.__source__);
            }
        },
        "./node_modules/post-robot/src/lib/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.weakMapMemoize = exports.once = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.stringifyError = function stringifyError(err) {
                var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                if (level >= 3) return "stringifyError stack overflow";
                try {
                    if (!err) return "<unknown error: " + Object.prototype.toString.call(err) + ">";
                    if ("string" == typeof err) return err;
                    if (err instanceof Error) {
                        var stack = err && err.stack, message = err && err.message;
                        if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                        if (stack) return stack;
                        if (message) return message;
                    }
                    return "function" == typeof err.toString ? err.toString() : Object.prototype.toString.call(err);
                } catch (newErr) {
                    return "Error while stringifying error: " + stringifyError(newErr, level + 1);
                }
            };
            exports.noop = function() {};
            exports.addEventListener = function(obj, event, handler) {
                obj.addEventListener ? obj.addEventListener(event, handler) : obj.attachEvent("on" + event, handler);
                return {
                    cancel: function() {
                        obj.removeEventListener ? obj.removeEventListener(event, handler) : obj.detachEvent("on" + event, handler);
                    }
                };
            };
            exports.uniqueID = function() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            };
            exports.eachArray = eachArray;
            exports.eachObject = eachObject;
            exports.each = each;
            exports.replaceObject = function replaceObject(item, callback) {
                var depth = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                if (depth >= 100) throw new Error("Self-referential object passed, or object contained too many layers");
                var newobj = void 0;
                if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item || Array.isArray(item)) {
                    if (!Array.isArray(item)) throw new TypeError("Invalid type: " + (void 0 === item ? "undefined" : _typeof(item)));
                    newobj = [];
                } else newobj = {};
                each(item, function(childItem, key) {
                    var result = callback(childItem, key);
                    void 0 !== result ? newobj[key] = result : "object" === (void 0 === childItem ? "undefined" : _typeof(childItem)) && null !== childItem ? newobj[key] = replaceObject(childItem, callback, depth + 1) : newobj[key] = childItem;
                });
                return newobj;
            };
            exports.safeInterval = function(method, time) {
                var timeout = void 0;
                timeout = setTimeout(function runInterval() {
                    timeout = setTimeout(runInterval, time);
                    method.call();
                }, time);
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            };
            exports.isRegex = function(item) {
                return "[object RegExp]" === Object.prototype.toString.call(item);
            };
            exports.getWindowType = function() {
                if ((0, _src2.isPopup)()) return _conf.CONSTANTS.WINDOW_TYPES.POPUP;
                if ((0, _src2.isIframe)()) return _conf.CONSTANTS.WINDOW_TYPES.IFRAME;
                return _conf.CONSTANTS.WINDOW_TYPES.FULLPAGE;
            };
            exports.jsonStringify = function(obj, replacer, indent) {
                var objectToJSON = void 0, arrayToJSON = void 0;
                try {
                    if ("{}" !== JSON.stringify({})) {
                        objectToJSON = Object.prototype.toJSON;
                        delete Object.prototype.toJSON;
                    }
                    if ("{}" !== JSON.stringify({})) throw new Error("Can not correctly serialize JSON objects");
                    if ("[]" !== JSON.stringify([])) {
                        arrayToJSON = Array.prototype.toJSON;
                        delete Array.prototype.toJSON;
                    }
                    if ("[]" !== JSON.stringify([])) throw new Error("Can not correctly serialize JSON objects");
                } catch (err) {
                    throw new Error("Can not repair JSON.stringify: " + err.message);
                }
                var result = JSON.stringify.call(this, obj, replacer, indent);
                try {
                    objectToJSON && (Object.prototype.toJSON = objectToJSON);
                    arrayToJSON && (Array.prototype.toJSON = arrayToJSON);
                } catch (err) {
                    throw new Error("Can not repair JSON.stringify: " + err.message);
                }
                return result;
            };
            exports.jsonParse = function(item) {
                return JSON.parse(item);
            };
            exports.needsGlobalMessagingForBrowser = function() {
                if ((0, _src2.getUserAgent)(window).match(/MSIE|trident|edge\/12|edge\/13/i)) return !0;
                if (!_conf.CONFIG.ALLOW_POSTMESSAGE_POPUP) return !0;
                return !1;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            exports.once = function(method) {
                if (!method) return method;
                var called = !1;
                return function() {
                    if (!called) {
                        called = !0;
                        return method.apply(this, arguments);
                    }
                };
            };
            function eachArray(item, callback) {
                for (var i = 0; i < item.length; i++) callback(item[i], i);
            }
            function eachObject(item, callback) {
                for (var _key in item) item.hasOwnProperty(_key) && callback(item[_key], _key);
            }
            function each(item, callback) {
                Array.isArray(item) ? eachArray(item, callback) : "object" === (void 0 === item ? "undefined" : _typeof(item)) && null !== item && eachObject(item, callback);
            }
            exports.weakMapMemoize = function(method) {
                var weakmap = new _src.WeakMap();
                return function(arg) {
                    var result = weakmap.get(arg);
                    if (void 0 !== result) return result;
                    void 0 !== (result = method.call(this, arg)) && weakmap.set(arg, result);
                    return result;
                };
            };
        },
        "./node_modules/post-robot/src/public/client.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.send = void 0;
            exports.request = request;
            exports.sendToParent = function(name, data, options) {
                var win = (0, _src3.getAncestor)();
                if (!win) return new _src2.ZalgoPromise(function(resolve, reject) {
                    return reject(new Error("Window does not have a parent"));
                });
                return _send(win, name, data, options);
            };
            exports.client = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                if (!options.window) throw new Error("Expected options.window");
                var win = options.window;
                return {
                    send: function(name, data) {
                        return _send(win, name, data, options);
                    }
                };
            };
            var _src = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            _global.global.requestPromises = _global.global.requestPromises || new _src.WeakMap();
            function request(options) {
                return _src2.ZalgoPromise.try(function() {
                    if (!options.name) throw new Error("Expected options.name");
                    var name = options.name, targetWindow = void 0, domain = void 0;
                    if ("string" == typeof options.window) {
                        var el = document.getElementById(options.window);
                        if (!el) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be a valid element id");
                        if ("iframe" !== el.tagName.toLowerCase()) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be an iframe");
                        if (!el.contentWindow) throw new Error("Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.");
                        targetWindow = el.contentWindow;
                    } else if (options.window instanceof HTMLIFrameElement) {
                        if ("iframe" !== options.window.tagName.toLowerCase()) throw new Error("Expected options.window " + Object.prototype.toString.call(options.window) + " to be an iframe");
                        if (options.window && !options.window.contentWindow) throw new Error("Iframe must have contentWindow.  Make sure it has a src attribute and is in the DOM.");
                        options.window && options.window.contentWindow && (targetWindow = options.window.contentWindow);
                    } else targetWindow = options.window;
                    if (!targetWindow) throw new Error("Expected options.window to be a window object, iframe, or iframe element id.");
                    var win = targetWindow;
                    domain = options.domain || _conf.CONSTANTS.WILDCARD;
                    var hash = options.name + "_" + (0, _lib.uniqueID)();
                    if ((0, _src3.isWindowClosed)(win)) throw new Error("Target window is closed");
                    var hasResult = !1, requestPromises = _global.global.requestPromises.get(win);
                    if (!requestPromises) {
                        requestPromises = [];
                        _global.global.requestPromises.set(win, requestPromises);
                    }
                    var requestPromise = _src2.ZalgoPromise.try(function() {
                        if ((0, _src3.isAncestor)(window, win)) return (0, _lib.onChildWindowReady)(win, options.timeout || _conf.CONFIG.CHILD_WINDOW_TIMEOUT);
                    }).then(function() {
                        var origin = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).origin;
                        if ((0, _lib.isRegex)(domain) && !origin) return (0, _lib.sayHello)(win);
                    }).then(function() {
                        var origin = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).origin;
                        if ((0, _lib.isRegex)(domain)) {
                            if (!(0, _src3.matchDomain)(domain, origin)) throw new Error("Remote window domain " + origin + " does not match regex: " + domain.toString());
                            domain = origin;
                        }
                        if ("string" != typeof domain && !Array.isArray(domain)) throw new TypeError("Expected domain to be a string or array");
                        var actualDomain = domain;
                        return new _src2.ZalgoPromise(function(resolve, reject) {
                            var responseListener = void 0;
                            if (!options.fireAndForget) {
                                responseListener = {
                                    name: name,
                                    window: win,
                                    domain: actualDomain,
                                    respond: function(err, result) {
                                        if (!err) {
                                            hasResult = !0;
                                            requestPromises.splice(requestPromises.indexOf(requestPromise, 1));
                                        }
                                        err ? reject(err) : resolve(result);
                                    }
                                };
                                (0, _drivers.addResponseListener)(hash, responseListener);
                            }
                            (0, _drivers.sendMessage)(win, {
                                type: _conf.CONSTANTS.POST_MESSAGE_TYPE.REQUEST,
                                hash: hash,
                                name: name,
                                data: options.data,
                                fireAndForget: options.fireAndForget
                            }, actualDomain).catch(reject);
                            if (options.fireAndForget) return resolve();
                            var ackTimeout = _conf.CONFIG.ACK_TIMEOUT, resTimeout = options.timeout || _conf.CONFIG.RES_TIMEOUT, cycleTime = 100;
                            setTimeout(function cycle() {
                                if (!hasResult) {
                                    if ((0, _src3.isWindowClosed)(win)) return responseListener.ack ? reject(new Error("Window closed for " + name + " before response")) : reject(new Error("Window closed for " + name + " before ack"));
                                    ackTimeout = Math.max(ackTimeout - cycleTime, 0);
                                    -1 !== resTimeout && (resTimeout = Math.max(resTimeout - cycleTime, 0));
                                    if (responseListener.ack) {
                                        if (-1 === resTimeout) return;
                                        cycleTime = Math.min(resTimeout, 2e3);
                                    } else {
                                        if (0 === ackTimeout) return reject(new Error("No ack for postMessage " + name + " in " + (0, 
                                        _src3.getDomain)() + " in " + _conf.CONFIG.ACK_TIMEOUT + "ms"));
                                        if (0 === resTimeout) return reject(new Error("No response for postMessage " + name + " in " + (0, 
                                        _src3.getDomain)() + " in " + (options.timeout || _conf.CONFIG.RES_TIMEOUT) + "ms"));
                                    }
                                    setTimeout(cycle, cycleTime);
                                }
                            }, cycleTime);
                        });
                    });
                    requestPromise.catch(function() {
                        (0, _drivers.markResponseListenerErrored)(hash);
                        (0, _drivers.deleteResponseListener)(hash);
                    });
                    requestPromises.push(requestPromise);
                    return requestPromise;
                });
            }
            function _send(window, name, data, options) {
                (options = options || {}).window = window;
                options.name = name;
                options.data = data;
                return request(options);
            }
            exports.send = _send;
            _global.global.send = _send;
        },
        "./node_modules/post-robot/src/public/config.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = exports.CONFIG = void 0;
            var _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js");
            Object.defineProperty(exports, "CONFIG", {
                enumerable: !0,
                get: function() {
                    return _conf.CONFIG;
                }
            });
            Object.defineProperty(exports, "CONSTANTS", {
                enumerable: !0,
                get: function() {
                    return _conf.CONSTANTS;
                }
            });
            exports.disable = function() {
                delete window[_conf.CONSTANTS.WINDOW_PROPS.POSTROBOT];
                window.removeEventListener("message", _drivers.messageListener);
            };
            var _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js");
        },
        "./node_modules/post-robot/src/public/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.parent = void 0;
            var _client = __webpack_require__("./node_modules/post-robot/src/public/client.js");
            Object.keys(_client).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _client[key];
                    }
                });
            });
            var _server = __webpack_require__("./node_modules/post-robot/src/public/server.js");
            Object.keys(_server).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _server[key];
                    }
                });
            });
            var _config = __webpack_require__("./node_modules/post-robot/src/public/config.js");
            Object.keys(_config).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _config[key];
                    }
                });
            });
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            exports.parent = (0, _src.getAncestor)();
        },
        "./node_modules/post-robot/src/public/server.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.on = void 0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.listen = listen;
            exports.once = function(name) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, handler = arguments[2];
                if ("function" == typeof options) {
                    handler = options;
                    options = {};
                }
                options = options || {};
                handler = handler || options.handler;
                var errorHandler = options.errorHandler, promise = new _src2.ZalgoPromise(function(resolve, reject) {
                    (options = options || {}).name = name;
                    options.once = !0;
                    options.handler = function(event) {
                        resolve(event);
                        if (handler) return handler(event);
                    };
                    options.errorHandler = function(err) {
                        reject(err);
                        if (errorHandler) return errorHandler(err);
                    };
                }), onceListener = listen(options);
                promise.cancel = onceListener.cancel;
                return promise;
            };
            exports.listener = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return {
                    on: function(name, handler) {
                        return _on(name, options, handler);
                    }
                };
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _lib = __webpack_require__("./node_modules/post-robot/src/lib/index.js"), _drivers = __webpack_require__("./node_modules/post-robot/src/drivers/index.js"), _conf = __webpack_require__("./node_modules/post-robot/src/conf/index.js"), _global = __webpack_require__("./node_modules/post-robot/src/global.js");
            function listen(options) {
                if (!options.name) throw new Error("Expected options.name");
                if (!options.handler) throw new Error("Expected options.handler");
                var name = options.name, win = options.window, domain = options.domain, listenerOptions = {
                    handler: options.handler,
                    handleError: options.errorHandler || function(err) {
                        throw err;
                    },
                    window: win,
                    domain: domain || _conf.CONSTANTS.WILDCARD,
                    name: name
                }, requestListener = (0, _drivers.addRequestListener)({
                    name: name,
                    win: win,
                    domain: domain
                }, listenerOptions);
                if (options.once) {
                    var _handler = listenerOptions.handler;
                    listenerOptions.handler = (0, _lib.once)(function() {
                        requestListener.cancel();
                        return _handler.apply(this, arguments);
                    });
                }
                if (listenerOptions.window && options.errorOnClose) var interval = (0, _lib.safeInterval)(function() {
                    if (win && "object" === (void 0 === win ? "undefined" : _typeof(win)) && (0, _src.isWindowClosed)(win)) {
                        interval.cancel();
                        listenerOptions.handleError(new Error("Post message target window is closed"));
                    }
                }, 50);
                return {
                    cancel: function() {
                        requestListener.cancel();
                    }
                };
            }
            function _on(name, options, handler) {
                if ("function" == typeof options) {
                    handler = options;
                    options = {};
                }
                (options = options || {}).name = name;
                options.handler = handler || options.handler;
                return listen(options);
            }
            exports.on = _on;
            _global.global.on = _on;
        },
        "./node_modules/process/browser.js": function(module, exports, __webpack_require__) {
            "use strict";
            var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            !function() {
                try {
                    cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }();
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                    cachedSetTimeout = setTimeout;
                    return setTimeout(fun, 0);
                }
                try {
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            var currentQueue, queue = [], draining = !1, queueIndex = -1;
            function cleanUpNextTick() {
                if (draining && currentQueue) {
                    draining = !1;
                    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1;
                    queue.length && drainQueue();
                }
            }
            function drainQueue() {
                if (!draining) {
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = !0;
                    for (var len = queue.length; len; ) {
                        currentQueue = queue;
                        queue = [];
                        for (;++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = !1;
                    !function(marker) {
                        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                            cachedClearTimeout = clearTimeout;
                            return clearTimeout(marker);
                        }
                        try {
                            cachedClearTimeout(marker);
                        } catch (e) {
                            try {
                                return cachedClearTimeout.call(null, marker);
                            } catch (e) {
                                return cachedClearTimeout.call(this, marker);
                            }
                        }
                    }(timeout);
                }
            }
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
                queue.push(new Item(fun, args));
                1 !== queue.length || draining || runTimeout(drainQueue);
            };
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            };
            process.title = "browser";
            process.browser = !0;
            process.env = {};
            process.argv = [];
            process.version = "";
            process.versions = {};
            function noop() {}
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function(name) {
                return [];
            };
            process.binding = function(name) {
                throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
                return "/";
            };
            process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            };
            process.umask = function() {
                return 0;
            };
        },
        "./node_modules/webpack/buildin/amd-options.js": function(module, exports) {
            (function(__webpack_amd_options__) {
                module.exports = __webpack_amd_options__;
            }).call(exports, {});
        },
        "./node_modules/webpack/buildin/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            var g, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            g = function() {
                return this;
            }();
            try {
                g = g || Function("return this")() || (0, eval)("this");
            } catch (e) {
                "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && (g = window);
            }
            module.exports = g;
        },
        "./node_modules/webpack/buildin/module.js": function(module, exports, __webpack_require__) {
            "use strict";
            module.exports = function(module) {
                if (!module.webpackPolyfill) {
                    module.deprecate = function() {};
                    module.paths = [];
                    module.children || (module.children = []);
                    Object.defineProperty(module, "loaded", {
                        enumerable: !0,
                        get: function() {
                            return module.l;
                        }
                    });
                    Object.defineProperty(module, "id", {
                        enumerable: !0,
                        get: function() {
                            return module.i;
                        }
                    });
                    module.webpackPolyfill = 1;
                }
                return module;
            };
        },
        "./node_modules/zalgo-promise/src/exceptions.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.dispatchPossiblyUnhandledError = function(err) {
                if (-1 !== (0, _global.getGlobal)().dispatchedErrors.indexOf(err)) return;
                (0, _global.getGlobal)().dispatchedErrors.push(err);
                setTimeout(function() {
                    throw err;
                }, 1);
                for (var j = 0; j < (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.length; j++) (0, 
                _global.getGlobal)().possiblyUnhandledPromiseHandlers[j](err);
            };
            exports.onPossiblyUnhandledException = function(handler) {
                (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.push(handler);
                return {
                    cancel: function() {
                        (0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.splice((0, _global.getGlobal)().possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                    }
                };
            };
            var _global = __webpack_require__("./node_modules/zalgo-promise/src/global.js");
        },
        "./node_modules/zalgo-promise/src/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            (function(global) {
                exports.__esModule = !0;
                exports.getGlobal = function() {
                    var glob = void 0;
                    if ("undefined" != typeof window) glob = window; else {
                        if (void 0 === global) throw new TypeError("Can not find global");
                        glob = global;
                    }
                    var zalgoGlobal = glob.__zalgopromise__ = glob.__zalgopromise__ || {};
                    zalgoGlobal.flushPromises = zalgoGlobal.flushPromises || [];
                    zalgoGlobal.activeCount = zalgoGlobal.activeCount || 0;
                    zalgoGlobal.possiblyUnhandledPromiseHandlers = zalgoGlobal.possiblyUnhandledPromiseHandlers || [];
                    zalgoGlobal.dispatchedErrors = zalgoGlobal.dispatchedErrors || [];
                    return zalgoGlobal;
                };
            }).call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"));
        },
        "./node_modules/zalgo-promise/src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _promise = __webpack_require__("./node_modules/zalgo-promise/src/promise.js");
            Object.defineProperty(exports, "ZalgoPromise", {
                enumerable: !0,
                get: function() {
                    return _promise.ZalgoPromise;
                }
            });
        },
        "./node_modules/zalgo-promise/src/promise.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ZalgoPromise = void 0;
            var _utils = __webpack_require__("./node_modules/zalgo-promise/src/utils.js"), _exceptions = __webpack_require__("./node_modules/zalgo-promise/src/exceptions.js"), _global = __webpack_require__("./node_modules/zalgo-promise/src/global.js");
            var ZalgoPromise = function() {
                function ZalgoPromise(handler) {
                    var _this = this;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ZalgoPromise);
                    this.resolved = !1;
                    this.rejected = !1;
                    this.errorHandled = !1;
                    this.handlers = [];
                    if (handler) {
                        var _result = void 0, _error = void 0, resolved = !1, rejected = !1, isAsync = !1;
                        try {
                            handler(function(res) {
                                if (isAsync) _this.resolve(res); else {
                                    resolved = !0;
                                    _result = res;
                                }
                            }, function(err) {
                                if (isAsync) _this.reject(err); else {
                                    rejected = !0;
                                    _error = err;
                                }
                            });
                        } catch (err) {
                            this.reject(err);
                            return;
                        }
                        isAsync = !0;
                        resolved ? this.resolve(_result) : rejected && this.reject(_error);
                    }
                }
                ZalgoPromise.prototype.resolve = function(result) {
                    if (this.resolved || this.rejected) return this;
                    if ((0, _utils.isPromise)(result)) throw new Error("Can not resolve promise with another promise");
                    this.resolved = !0;
                    this.value = result;
                    this.dispatch();
                    return this;
                };
                ZalgoPromise.prototype.reject = function(error) {
                    var _this2 = this;
                    if (this.resolved || this.rejected) return this;
                    if ((0, _utils.isPromise)(error)) throw new Error("Can not reject promise with another promise");
                    if (!error) {
                        var _err = error && "function" == typeof error.toString ? error.toString() : Object.prototype.toString.call(error);
                        error = new Error("Expected reject to be called with Error, got " + _err);
                    }
                    this.rejected = !0;
                    this.error = error;
                    this.errorHandled || setTimeout(function() {
                        _this2.errorHandled || (0, _exceptions.dispatchPossiblyUnhandledError)(error);
                    }, 1);
                    this.dispatch();
                    return this;
                };
                ZalgoPromise.prototype.asyncReject = function(error) {
                    this.errorHandled = !0;
                    this.reject(error);
                };
                ZalgoPromise.prototype.dispatch = function() {
                    var _this3 = this, dispatching = this.dispatching, resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                    if (!dispatching && (resolved || rejected)) {
                        this.dispatching = !0;
                        (0, _global.getGlobal)().activeCount += 1;
                        for (var _loop = function(i) {
                            var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise, result = void 0;
                            if (resolved) try {
                                result = onSuccess ? onSuccess(_this3.value) : _this3.value;
                            } catch (err) {
                                promise.reject(err);
                                return "continue";
                            } else if (rejected) {
                                if (!onError) {
                                    promise.reject(_this3.error);
                                    return "continue";
                                }
                                try {
                                    result = onError(_this3.error);
                                } catch (err) {
                                    promise.reject(err);
                                    return "continue";
                                }
                            }
                            if (result instanceof ZalgoPromise && (result.resolved || result.rejected)) {
                                result.resolved ? promise.resolve(result.value) : promise.reject(result.error);
                                result.errorHandled = !0;
                            } else (0, _utils.isPromise)(result) ? result instanceof ZalgoPromise && (result.resolved || result.rejected) ? result.resolved ? promise.resolve(result.value) : promise.reject(result.error) : result.then(function(res) {
                                promise.resolve(res);
                            }, function(err) {
                                promise.reject(err);
                            }) : promise.resolve(result);
                        }, i = 0; i < handlers.length; i++) _loop(i);
                        handlers.length = 0;
                        this.dispatching = !1;
                        (0, _global.getGlobal)().activeCount -= 1;
                        0 === (0, _global.getGlobal)().activeCount && ZalgoPromise.flushQueue();
                    }
                };
                ZalgoPromise.prototype.then = function(onSuccess, onError) {
                    if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                    if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                    var promise = new ZalgoPromise();
                    this.handlers.push({
                        promise: promise,
                        onSuccess: onSuccess,
                        onError: onError
                    });
                    this.errorHandled = !0;
                    this.dispatch();
                    return promise;
                };
                ZalgoPromise.prototype.catch = function(onError) {
                    return this.then(void 0, onError);
                };
                ZalgoPromise.prototype.finally = function(handler) {
                    return this.then(function(result) {
                        return ZalgoPromise.try(handler).then(function() {
                            return result;
                        });
                    }, function(err) {
                        return ZalgoPromise.try(handler).then(function() {
                            throw err;
                        });
                    });
                };
                ZalgoPromise.prototype.timeout = function(time, err) {
                    var _this4 = this;
                    if (this.resolved || this.rejected) return this;
                    var timeout = setTimeout(function() {
                        _this4.resolved || _this4.rejected || _this4.reject(err || new Error("Promise timed out after " + time + "ms"));
                    }, time);
                    return this.then(function(result) {
                        clearTimeout(timeout);
                        return result;
                    });
                };
                ZalgoPromise.prototype.toPromise = function() {
                    if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                    return Promise.resolve(this);
                };
                ZalgoPromise.resolve = function(value) {
                    return value instanceof ZalgoPromise ? value : (0, _utils.isPromise)(value) ? new ZalgoPromise(function(resolve, reject) {
                        return value.then(resolve, reject);
                    }) : new ZalgoPromise().resolve(value);
                };
                ZalgoPromise.reject = function(error) {
                    return new ZalgoPromise().reject(error);
                };
                ZalgoPromise.all = function(promises) {
                    var promise = new ZalgoPromise(), count = promises.length, results = [];
                    if (!count) {
                        promise.resolve(results);
                        return promise;
                    }
                    for (var _loop2 = function(i) {
                        var prom = promises[i];
                        if (prom instanceof ZalgoPromise) {
                            if (prom.resolved) {
                                results[i] = prom.value;
                                count -= 1;
                                return "continue";
                            }
                        } else if (!(0, _utils.isPromise)(prom)) {
                            results[i] = prom;
                            count -= 1;
                            return "continue";
                        }
                        ZalgoPromise.resolve(prom).then(function(result) {
                            results[i] = result;
                            0 === (count -= 1) && promise.resolve(results);
                        }, function(err) {
                            promise.reject(err);
                        });
                    }, i = 0; i < promises.length; i++) _loop2(i);
                    0 === count && promise.resolve(results);
                    return promise;
                };
                ZalgoPromise.hash = function(promises) {
                    var result = {};
                    return ZalgoPromise.all(Object.keys(promises).map(function(key) {
                        return ZalgoPromise.resolve(promises[key]).then(function(value) {
                            result[key] = value;
                        });
                    })).then(function() {
                        return result;
                    });
                };
                ZalgoPromise.map = function(items, method) {
                    return ZalgoPromise.all(items.map(method));
                };
                ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                    return (0, _exceptions.onPossiblyUnhandledException)(handler);
                };
                ZalgoPromise.try = function(method, context, args) {
                    var result = void 0;
                    try {
                        result = method.apply(context, args || []);
                    } catch (err) {
                        return ZalgoPromise.reject(err);
                    }
                    return ZalgoPromise.resolve(result);
                };
                ZalgoPromise.delay = function(_delay) {
                    return new ZalgoPromise(function(resolve) {
                        setTimeout(resolve, _delay);
                    });
                };
                ZalgoPromise.isPromise = function(value) {
                    return !!(value && value instanceof ZalgoPromise) || (0, _utils.isPromise)(value);
                };
                ZalgoPromise.flush = function() {
                    var promise = new ZalgoPromise();
                    (0, _global.getGlobal)().flushPromises.push(promise);
                    0 === (0, _global.getGlobal)().activeCount && ZalgoPromise.flushQueue();
                    return promise;
                };
                ZalgoPromise.flushQueue = function() {
                    var promisesToFlush = (0, _global.getGlobal)().flushPromises;
                    (0, _global.getGlobal)().flushPromises = [];
                    var _iterator = promisesToFlush, _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        _ref.resolve();
                    }
                };
                return ZalgoPromise;
            }();
            exports.ZalgoPromise = ZalgoPromise;
        },
        "./node_modules/zalgo-promise/src/utils.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isPromise = function(item) {
                try {
                    if (!item) return !1;
                    if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                    if ("undefined" != typeof window && window.Window && item instanceof window.Window) return !1;
                    if ("undefined" != typeof window && window.constructor && item instanceof window.constructor) return !1;
                    var _toString = {}.toString;
                    if (_toString) {
                        var name = _toString.call(item);
                        if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                    }
                    if ("function" == typeof item.then) return !0;
                } catch (err) {
                    return !1;
                }
                return !1;
            };
        },
        "./src/component/base.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.BaseComponent = void 0;
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js");
            __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.BaseComponent = function() {
                function BaseComponent() {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, BaseComponent);
                    this.clean = (obj = this, tasks = [], cleaned = !1, {
                        set: function(name, item) {
                            if (cleaned) return item;
                            obj[name] = item;
                            this.register(function() {
                                delete obj[name];
                            });
                            return item;
                        },
                        register: function(name, method) {
                            if ("function" == typeof name) {
                                method = name;
                                name = "<anonymous-cleanup-handler>";
                            }
                            if ("function" != typeof method) throw new TypeError("Expected to be passed function to clean.register");
                            cleaned ? method() : tasks.push({
                                complete: !1,
                                name: name,
                                run: function() {
                                    if (!this.complete) {
                                        this.complete = !0;
                                        method && method();
                                    }
                                }
                            });
                        },
                        hasTasks: function() {
                            return Boolean(tasks.filter(function(item) {
                                return !item.complete;
                            }).length);
                        },
                        all: function() {
                            var results = [];
                            cleaned = !0;
                            for (;tasks.length; ) results.push(tasks.pop().run());
                            return _src.ZalgoPromise.all(results).then(function() {});
                        },
                        run: function(name) {
                            var results = [], _iterator = tasks, _isArray = Array.isArray(_iterator), _i = 0;
                            for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                                var _ref;
                                if (_isArray) {
                                    if (_i >= _iterator.length) break;
                                    _ref = _iterator[_i++];
                                } else {
                                    if ((_i = _iterator.next()).done) break;
                                    _ref = _i.value;
                                }
                                var item = _ref;
                                item.name === name && results.push(item.run());
                            }
                            return _src.ZalgoPromise.all(results).then(_lib.noop);
                        }
                    });
                    var obj, tasks, cleaned;
                    this.event = (0, _lib.eventEmitter)();
                }
                BaseComponent.prototype.addProp = function(options, name, def) {
                    (0, _lib.copyProp)(options, this, name, def);
                };
                BaseComponent.prototype.on = function(eventName, handler) {
                    return this.event.on(eventName, handler);
                };
                BaseComponent.prototype.listeners = function() {
                    throw new Error("Expected listeners to be implemented");
                };
                BaseComponent.prototype.error = function(err) {
                    throw new Error("Expected error to be implemented - got " + (0, _lib.stringifyError)(err));
                };
                BaseComponent.prototype.listen = function(win, domain) {
                    var _this = this;
                    if (!win) throw this.component.createError("window to listen to not set");
                    if (!domain) throw new Error("Must pass domain to listen to");
                    if (this.listeners) {
                        var listeners = this.listeners(), _loop = function() {
                            if (_isArray2) {
                                if (_i2 >= _iterator2.length) return "break";
                                _ref2 = _iterator2[_i2++];
                            } else {
                                if ((_i2 = _iterator2.next()).done) return "break";
                                _ref2 = _i2.value;
                            }
                            var listenerName = _ref2, name = listenerName.replace(/^zoid_/, ""), errorHandler = function(err) {
                                _this.error(err);
                            }, listener = (0, _src2.on)(listenerName, {
                                window: win,
                                domain: domain,
                                errorHandler: errorHandler
                            }, function(_ref3) {
                                var source = _ref3.source, data = _ref3.data;
                                _this.component.log("listener_" + name);
                                return listeners[listenerName].call(_this, source, data);
                            }), errorListener = (0, _src2.on)(listenerName, {
                                window: win,
                                errorHandler: errorHandler
                            }, function(_ref4) {
                                var origin = _ref4.origin;
                                _this.component.logError("unexpected_listener_" + name, {
                                    origin: origin,
                                    domain: domain.toString()
                                });
                                _this.error(new Error("Unexpected " + name + " message from domain " + origin + " -- expected message from " + domain.toString()));
                            });
                            _this.clean.register(function() {
                                listener.cancel();
                                errorListener.cancel();
                            });
                        }, _iterator2 = Object.keys(listeners), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                            var _ref2;
                            if ("break" === _loop()) break;
                        }
                    }
                };
                return BaseComponent;
            }();
        },
        "./src/component/child/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ChildComponent = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _client = __webpack_require__("./node_modules/beaver-logger/client/index.js"), _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _window = __webpack_require__("./src/component/window.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _error = __webpack_require__("./src/error.js"), _props = __webpack_require__("./src/component/child/props.js");
            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            exports.ChildComponent = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(ChildComponent, _BaseComponent);
                function ChildComponent(component) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ChildComponent);
                    var _this = _possibleConstructorReturn(this, _BaseComponent.call(this));
                    _this.component = component;
                    if (!_this.hasValidParentDomain()) {
                        _this.error(new _error.RenderError("Can not be rendered by domain: " + _this.getParentDomain()));
                        return _possibleConstructorReturn(_this);
                    }
                    _this.component.log("construct_child");
                    _this.onPropHandlers = [];
                    for (var _arr = [ _this.component, window ], _loop = function() {
                        for (var item = _arr[_i], _arr2 = [ [ "xchild", function() {
                            return _this;
                        } ], [ "xprops", function() {
                            return _this.props;
                        } ] ], _loop2 = function() {
                            var _arr2$_i = _arr2[_i2], name = _arr2$_i[0], getter = _arr2$_i[1];
                            Object.defineProperty(item, name, {
                                configurable: !0,
                                get: function() {
                                    _this.props || _this.setProps(_this.getInitialProps(), (0, _window.getParentDomain)());
                                    delete item[name];
                                    item[name] = getter();
                                    return item[name];
                                }
                            });
                        }, _i2 = 0; _i2 < _arr2.length; _i2++) _loop2();
                    }, _i = 0; _i < _arr.length; _i++) _loop();
                    _this.component.log("init_child");
                    _this.setWindows();
                    _this.listenForResize();
                    _this.onInit = _this.sendToParent(_constants.POST_MESSAGE.INIT, {
                        exports: _this.exports()
                    }).then(function(_ref) {
                        var origin = _ref.origin, data = _ref.data;
                        _this.context = data.context;
                        _this.setProps(data.props, origin);
                        _this.watchForResize();
                        return _this;
                    }).catch(function(err) {
                        _this.error(err);
                        throw err;
                    });
                    return _this;
                }
                ChildComponent.prototype.listenForResize = function() {
                    var _this2 = this;
                    if (this.component.listenForResize) {
                        this.sendToParent(_constants.POST_MESSAGE.ONRESIZE, {}, {
                            fireAndForget: !0
                        });
                        window.addEventListener("resize", function() {
                            _this2.sendToParent(_constants.POST_MESSAGE.ONRESIZE, {}, {
                                fireAndForget: !0
                            });
                        });
                    }
                };
                ChildComponent.prototype.hasValidParentDomain = function() {
                    return (0, _src.matchDomain)(this.component.allowedParentDomains, this.getParentDomain());
                };
                ChildComponent.prototype.init = function() {
                    return this.onInit;
                };
                ChildComponent.prototype.getParentDomain = function() {
                    return (0, _window.getParentDomain)();
                };
                ChildComponent.prototype.onProps = function(handler) {
                    this.onPropHandlers.push(handler);
                };
                ChildComponent.prototype.getParentComponentWindow = function() {
                    return (0, _window.getParentComponentWindow)();
                };
                ChildComponent.prototype.getParentRenderWindow = function() {
                    return (0, _window.getParentRenderWindow)();
                };
                ChildComponent.prototype.getInitialProps = function() {
                    var _this3 = this, componentMeta = (0, _window.getComponentMeta)(), props = componentMeta.props;
                    if (props.type === _constants.INITIAL_PROPS.RAW) props = props.value; else {
                        if (props.type !== _constants.INITIAL_PROPS.UID) throw new Error("Unrecognized props type: " + props.type);
                        var parentComponentWindow = (0, _window.getParentComponentWindow)();
                        if (!(0, _src.isSameDomain)(parentComponentWindow)) {
                            if ("file:" === window.location.protocol) throw new Error("Can not get props from file:// domain");
                            throw new Error("Parent component window is on a different domain - expected " + (0, 
                            _src.getDomain)() + " - can not retrieve props");
                        }
                        var global = (0, _lib.globalFor)(parentComponentWindow);
                        if (!global) throw new Error("Can not find global for parent component - can not retrieve props");
                        props = JSON.parse(global.props[componentMeta.uid]);
                    }
                    if (!props) throw new Error("Initial props not found");
                    return (0, _lib.deserializeFunctions)(props, function(_ref2) {
                        var fullKey = _ref2.fullKey, self = _ref2.self, args = _ref2.args;
                        return _this3.onInit.then(function() {
                            var func = (0, _lib.get)(_this3.props, fullKey);
                            if ("function" != typeof func) throw new TypeError("Expected " + fullKey + " to be function, got " + (void 0 === func ? "undefined" : _typeof(func)));
                            return func.apply(self, args);
                        });
                    });
                };
                ChildComponent.prototype.setProps = function(props, origin) {
                    var required = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    this.props = this.props || {};
                    var normalizedProps = (0, _props.normalizeChildProps)(this.component, props, origin, required);
                    (0, _lib.extend)(this.props, normalizedProps);
                    this.props.logLevel && (0, _lib.setLogLevel)(this.props.logLevel);
                    var _iterator = this.onPropHandlers, _isArray = Array.isArray(_iterator), _i3 = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray) {
                            if (_i3 >= _iterator.length) break;
                            _ref3 = _iterator[_i3++];
                        } else {
                            if ((_i3 = _iterator.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        _ref3.call(this, this.props);
                    }
                };
                ChildComponent.prototype.sendToParent = function(name) {
                    var data = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, parentWindow = (0, 
                    _window.getParentComponentWindow)();
                    if (!parentWindow) throw new Error("Can not find parent component window to message");
                    this.component.log("send_to_parent_" + name);
                    return (0, _src2.send)(parentWindow, name, data, _extends({
                        domain: (0, _window.getParentDomain)()
                    }, options));
                };
                ChildComponent.prototype.setWindows = function() {
                    if (window.__activeZoidComponent__) throw this.component.createError("Can not attach multiple components to the same window");
                    window.__activeZoidComponent__ = this;
                    if (!(0, _window.getParentComponentWindow)()) throw this.component.createError("Can not find parent window");
                    var componentMeta = (0, _window.getComponentMeta)();
                    if (componentMeta.tag !== this.component.tag) throw this.component.createError("Parent is " + componentMeta.tag + " - can not attach " + this.component.tag);
                    this.watchForClose();
                };
                ChildComponent.prototype.watchForClose = function() {
                    var _this4 = this;
                    window.addEventListener("unload", function() {
                        return _this4.checkClose();
                    });
                };
                ChildComponent.prototype.enableAutoResize = function() {
                    var _ref4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref4$width = _ref4.width, width = void 0 === _ref4$width || _ref4$width, _ref4$height = _ref4.height, height = void 0 === _ref4$height || _ref4$height;
                    this.autoResize = {
                        width: width,
                        height: height
                    };
                    this.watchForResize();
                };
                ChildComponent.prototype.getAutoResize = function() {
                    var width = !1, height = !1, autoResize = this.autoResize || this.component.autoResize;
                    if ("object" === (void 0 === autoResize ? "undefined" : _typeof(autoResize))) {
                        width = Boolean(autoResize.width);
                        height = Boolean(autoResize.height);
                    } else if (autoResize) {
                        width = !0;
                        height = !0;
                    }
                    return {
                        width: width,
                        height: height,
                        element: autoResize.element ? (0, _lib.getElement)(autoResize.element) : window.navigator.userAgent.match(/MSIE (9|10)\./) ? document.body : document.documentElement
                    };
                };
                ChildComponent.prototype.watchForResize = function() {
                    var _this5 = this, _getAutoResize = this.getAutoResize(), width = _getAutoResize.width, height = _getAutoResize.height, element = _getAutoResize.element;
                    if ((width || height) && this.context !== _constants.CONTEXT_TYPES.POPUP && !this.watchingForResize) {
                        this.watchingForResize = !0;
                        return _src3.ZalgoPromise.try(function() {
                            return _lib.documentReady;
                        }).then(function() {
                            if (!(0, _lib.dimensionsMatchViewport)(element, {
                                width: width,
                                height: height
                            })) return _this5.resizeToElement(element, {
                                width: width,
                                height: height
                            });
                        }).then(function() {
                            return (0, _lib.cycle)(function() {
                                return (0, _lib.onDimensionsChange)(element, {
                                    width: width,
                                    height: height
                                }).then(function() {
                                    return _this5.resizeToElement(element, {
                                        width: width,
                                        height: height
                                    });
                                });
                            });
                        });
                    }
                };
                ChildComponent.prototype.exports = function() {
                    var self = this;
                    return {
                        updateProps: function(props) {
                            var _this6 = this;
                            return _src3.ZalgoPromise.try(function() {
                                return self.setProps(props, _this6.origin, !1);
                            });
                        },
                        close: function() {
                            return _src3.ZalgoPromise.try(function() {
                                return self.destroy();
                            });
                        }
                    };
                };
                ChildComponent.prototype.resize = function(width, height) {
                    var _this7 = this;
                    return _src3.ZalgoPromise.resolve().then(function() {
                        _this7.component.log("resize", {
                            width: (0, _lib.stringify)(width),
                            height: (0, _lib.stringify)(height)
                        });
                        if (_this7.context !== _constants.CONTEXT_TYPES.POPUP) return _this7.sendToParent(_constants.POST_MESSAGE.RESIZE, {
                            width: width,
                            height: height
                        }).then(_lib.noop);
                    });
                };
                ChildComponent.prototype.resizeToElement = function(el, _ref5) {
                    var _this8 = this, width = _ref5.width, height = _ref5.height, history = [];
                    return function resize() {
                        return _src3.ZalgoPromise.try(function() {
                            var tracker = (0, _lib.trackDimensions)(el, {
                                width: width,
                                height: height
                            }), dimensions = tracker.check().dimensions, _iterator2 = history, _isArray2 = Array.isArray(_iterator2), _i4 = 0;
                            for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                var _ref6;
                                if (_isArray2) {
                                    if (_i4 >= _iterator2.length) break;
                                    _ref6 = _iterator2[_i4++];
                                } else {
                                    if ((_i4 = _iterator2.next()).done) break;
                                    _ref6 = _i4.value;
                                }
                                var size = _ref6, widthMatch = !width || size.width === dimensions.width, heightMatch = !height || size.height === dimensions.height;
                                if (widthMatch && heightMatch) return;
                            }
                            history.push({
                                width: dimensions.width,
                                height: dimensions.height
                            });
                            return _this8.resize(width ? dimensions.width : null, height ? dimensions.height : null).then(function() {
                                if (tracker.check().changed) return resize();
                            });
                        });
                    }();
                };
                ChildComponent.prototype.hide = function() {
                    return this.sendToParent(_constants.POST_MESSAGE.HIDE).then(_lib.noop);
                };
                ChildComponent.prototype.show = function() {
                    return this.sendToParent(_constants.POST_MESSAGE.SHOW).then(_lib.noop);
                };
                ChildComponent.prototype.userClose = function() {
                    return this.close(_constants.CLOSE_REASONS.USER_CLOSED);
                };
                ChildComponent.prototype.close = function() {
                    var reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.CHILD_CALL;
                    this.component.log("close_child");
                    this.sendToParent(_constants.POST_MESSAGE.CLOSE, {
                        reason: reason
                    });
                };
                ChildComponent.prototype.checkClose = function() {
                    this.sendToParent(_constants.POST_MESSAGE.CHECK_CLOSE, {}, {
                        fireAndForget: !0
                    });
                };
                ChildComponent.prototype.destroy = function() {
                    return (0, _client.flush)().then(function() {
                        window.close();
                    });
                };
                ChildComponent.prototype.focus = function() {
                    this.component.log("focus");
                    window.focus();
                };
                ChildComponent.prototype.error = function(err) {
                    var stringifiedError = (0, _lib.stringifyError)(err);
                    this.component.logError("error", {
                        error: stringifiedError
                    });
                    return this.sendToParent(_constants.POST_MESSAGE.ERROR, {
                        error: stringifiedError
                    }).then(_lib.noop);
                };
                return ChildComponent;
            }(_base.BaseComponent);
        },
        "./src/component/child/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.normalizeChildProp = normalizeChildProp;
            exports.normalizeChildProps = function(component, props, origin) {
                for (var required = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], result = {}, _iterator = Object.keys(props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var _key = _ref, prop = component.getProp(_key), value = props[_key];
                    if (!prop || !prop.sameDomain || origin === (0, _src.getDomain)(window)) {
                        result[_key] = normalizeChildProp(component, props, _key, value);
                        prop && prop.alias && !result[prop.alias] && (result[prop.alias] = value);
                    }
                }
                if (required) for (var _iterator2 = component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var key = _ref2;
                    props.hasOwnProperty(key) || (result[key] = normalizeChildProp(component, props, key, props[key]));
                }
                return result;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js");
            function normalizeChildProp(component, props, key, value) {
                var prop = component.getProp(key);
                return prop ? "function" == typeof prop.childDecorate ? prop.childDecorate(value) : value : component.looseProps ? value : void 0;
            }
        },
        "./src/component/component/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.Component = void 0;
            var _class, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _child = __webpack_require__("./src/component/child/index.js"), _parent = __webpack_require__("./src/component/parent/index.js"), _delegate = __webpack_require__("./src/component/delegate/index.js"), _window = __webpack_require__("./src/component/window.js"), _constants = __webpack_require__("./src/constants.js"), _index = __webpack_require__("./src/drivers/index.js"), _lib = __webpack_require__("./src/lib/index.js"), _validate = __webpack_require__("./src/component/component/validate.js"), _templates = __webpack_require__("./src/component/component/templates/index.js"), _props = __webpack_require__("./src/component/component/props.js");
            var drivers = {
                angular: _index.angular,
                angular2: _index.angular2,
                glimmer: _index.glimmer,
                react: _index.react,
                vue: _index.vue,
                script: _index.script
            };
            (exports.Component = (function(target, property, decorators, descriptor, context) {
                var desc = {};
                Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                });
                desc.enumerable = !!desc.enumerable;
                desc.configurable = !!desc.configurable;
                ("value" in desc || desc.initializer) && (desc.writable = !0);
                desc = decorators.slice().reverse().reduce(function(desc, decorator) {
                    return decorator(target, property, desc) || desc;
                }, desc);
                if (context && void 0 !== desc.initializer) {
                    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                    desc.initializer = void 0;
                }
                if (void 0 === desc.initializer) {
                    Object.defineProperty(target, property, desc);
                    desc = null;
                }
            }((_class = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(Component, _BaseComponent);
                function Component(options) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, Component);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    (0, _validate.validate)(options);
                    _this.addProp(options, "tag");
                    _this.addProp(options, "defaultLogLevel", "info");
                    _this.addProp(options, "allowedParentDomains", _constants.WILDCARD);
                    (0, _lib.setLogLevel)(_this.defaultLogLevel);
                    if (Component.components[_this.tag]) throw new Error("Can not register multiple components with the same tag");
                    _this.addProp(options, "name", _this.tag.replace(/-/g, "_"));
                    _this.builtinProps = (0, _props.getInternalProps)();
                    _this.props = options.props || {};
                    options.props || (_this.looseProps = !0);
                    _this.addProp(options, "dimensions");
                    _this.addProp(options, "scrolling");
                    _this.addProp(options, "listenForResize");
                    _this.addProp(options, "version", "latest");
                    _this.addProp(options, "defaultEnv");
                    _this.addProp(options, "buildUrl");
                    _this.addProp(options, "url");
                    _this.addProp(options, "domain");
                    _this.addProp(options, "bridgeUrl");
                    _this.addProp(options, "bridgeDomain");
                    _this.addProp(options, "attributes", {});
                    _this.addProp(options, "contexts", {
                        iframe: !0,
                        popup: !1
                    });
                    _this.addProp(options, "defaultContext");
                    _this.addProp(options, "autoResize", !1);
                    _this.addProp(options, "containerTemplate", _templates.defaultContainerTemplate);
                    _this.addProp(options, "prerenderTemplate", _templates.defaultPrerenderTemplate);
                    _this.addProp(options, "validate");
                    _this.addProp(options, "unsafeRenderTo", !1);
                    Component.components[_this.tag] = _this;
                    _this.registerDrivers();
                    _this.registerChild();
                    _this.listenDelegate();
                    return _this;
                }
                Component.prototype.getPropNames = function() {
                    var props = Object.keys(this.props), _iterator = Object.keys(this.builtinProps), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref;
                        -1 === props.indexOf(key) && props.push(key);
                    }
                    return props;
                };
                Component.prototype.getProp = function(name) {
                    return this.props[name] || this.builtinProps[name];
                };
                Component.prototype.registerDrivers = function() {
                    this.driverCache = {};
                    var _iterator2 = Object.keys(drivers), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var driverName = _ref2;
                        if (0 !== driverName.indexOf("_")) {
                            var glob = drivers[driverName].global();
                            glob && this.driver(driverName, glob);
                        }
                    }
                };
                Component.prototype.driver = function(name, dep) {
                    if (!drivers[name]) throw new Error("Could not find driver for framework: " + name);
                    this.driverCache[name] || (this.driverCache[name] = drivers[name].register(this, dep));
                    return this.driverCache[name];
                };
                Component.prototype.registerChild = function() {
                    var _this2 = this;
                    return _src2.ZalgoPromise.try(function() {
                        if (_this2.isChild()) return new _child.ChildComponent(_this2);
                    });
                };
                Component.prototype.listenDelegate = function() {
                    var _this3 = this;
                    (0, _src.on)(_constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + this.name, function() {
                        return !0;
                    });
                    (0, _src.on)(_constants.POST_MESSAGE.DELEGATE + "_" + this.name, function(_ref3) {
                        var source = _ref3.source, origin = _ref3.origin, data = _ref3.data, domain = _this3.getDomain(null, data.env || _this3.defaultEnv);
                        if (!domain) throw new Error("Could not determine domain to allow remote render");
                        if (!(0, _src3.matchDomain)(domain, origin)) throw new Error("Can not render from " + origin + " - expected " + domain.toString());
                        var delegate = _this3.delegate(source, data.options);
                        return {
                            overrides: delegate.getOverrides(data.context),
                            destroy: function() {
                                return delegate.destroy();
                            }
                        };
                    });
                };
                Component.prototype.canRenderTo = function(win) {
                    return (0, _src.send)(win, _constants.POST_MESSAGE.ALLOW_DELEGATE + "_" + this.name).then(function(_ref4) {
                        return _ref4.data;
                    }).catch(function() {
                        return !1;
                    });
                };
                Component.prototype.getValidDomain = function(url) {
                    if (url) {
                        var domain = (0, _src3.getDomainFromUrl)(url);
                        if ("string" == typeof this.domain && domain === this.domain) return domain;
                        var domains = this.domain;
                        if (domains && "object" === (void 0 === domains ? "undefined" : _typeof(domains)) && !(domains instanceof RegExp)) {
                            var _iterator3 = Object.keys(domains), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                            for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                var _ref5;
                                if (_isArray3) {
                                    if (_i3 >= _iterator3.length) break;
                                    _ref5 = _iterator3[_i3++];
                                } else {
                                    if ((_i3 = _iterator3.next()).done) break;
                                    _ref5 = _i3.value;
                                }
                                if ("test" !== _ref5 && domain === domains[_ref5]) return domain;
                            }
                        }
                    }
                };
                Component.prototype.getDomain = function(url, env) {
                    var domain = this.getForEnv(this.domain, env);
                    if (domain) return domain;
                    if (domain = this.getValidDomain(url)) return domain;
                    var envUrl = this.getForEnv(this.url, env);
                    return envUrl ? (0, _src3.getDomainFromUrl)(envUrl) : url ? (0, _src3.getDomainFromUrl)(url) : void 0;
                };
                Component.prototype.getBridgeUrl = function(env) {
                    return this.getForEnv(this.bridgeUrl, env);
                };
                Component.prototype.getForEnv = function(item, env) {
                    if (item) {
                        if ("string" == typeof item || item instanceof RegExp) return item;
                        env || (env = this.defaultEnv);
                        if (env) return env && "object" === (void 0 === item ? "undefined" : _typeof(item)) && item[env] ? item[env] : void 0;
                    }
                };
                Component.prototype.getBridgeDomain = function(env) {
                    var bridgeDomain = this.getForEnv(this.bridgeDomain, env);
                    if (bridgeDomain) return bridgeDomain;
                    var bridgeUrl = this.getBridgeUrl(env);
                    return bridgeUrl ? (0, _src3.getDomainFromUrl)(bridgeUrl) : void 0;
                };
                Component.prototype.getUrl = function(env, props) {
                    var url = this.getForEnv(this.url, env);
                    if (url) return url;
                    if (this.buildUrl) return this.buildUrl(props);
                    throw new Error("Unable to get url");
                };
                Component.prototype.isZoidComponent = function() {
                    return (0, _window.isZoidComponentWindow)();
                };
                Component.prototype.isChild = function() {
                    return (0, _window.isZoidComponentWindow)() && (0, _window.getComponentMeta)().tag === this.tag;
                };
                Component.prototype.createError = function(message, tag) {
                    return new Error("[" + (tag || this.tag) + "] " + message);
                };
                Component.prototype.init = function(props, context, element) {
                    return new _parent.ParentComponent(this, this.getRenderContext(context, element), {
                        props: props
                    });
                };
                Component.prototype.delegate = function(source, options) {
                    return new _delegate.DelegateComponent(this, source, options);
                };
                Component.prototype.validateRenderContext = function(context, element) {
                    if (context && !this.contexts[context]) throw new Error("[" + this.tag + "] Can not render to " + context);
                    if (!element && context === _constants.CONTEXT_TYPES.IFRAME) throw new Error("[" + this.tag + "] Context type " + _constants.CONTEXT_TYPES.IFRAME + " requires an element selector");
                };
                Component.prototype.getDefaultContext = function() {
                    if (this.defaultContext) return this.defaultContext;
                    if (this.contexts[_constants.CONTEXT_TYPES.IFRAME]) return _constants.CONTEXT_TYPES.IFRAME;
                    if (this.contexts[_constants.CONTEXT_TYPES.POPUP]) return _constants.CONTEXT_TYPES.POPUP;
                    throw new Error("Can not determine default context");
                };
                Component.prototype.getRenderContext = function(context, element) {
                    context = context || this.getDefaultContext();
                    this.validateRenderContext(context, element);
                    return context;
                };
                Component.prototype.render = function(props, element) {
                    var _this4 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this4, _this4.getRenderContext(null, element), {
                            props: props
                        }).render(element);
                    });
                };
                Component.prototype.renderIframe = function(props, element) {
                    var _this5 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this5, _this5.getRenderContext(_constants.CONTEXT_TYPES.IFRAME, element), {
                            props: props
                        }).render(element);
                    });
                };
                Component.prototype.renderPopup = function(props) {
                    var _this6 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this6, _this6.getRenderContext(_constants.CONTEXT_TYPES.POPUP), {
                            props: props
                        }).render();
                    });
                };
                Component.prototype.renderTo = function(win, props, element) {
                    var _this7 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this7, _this7.getRenderContext(null, element), {
                            props: props
                        }).renderTo(win, element);
                    });
                };
                Component.prototype.renderIframeTo = function(win, props, element) {
                    var _this8 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this8, _this8.getRenderContext(_constants.CONTEXT_TYPES.IFRAME, element), {
                            props: props
                        }).renderTo(win, element);
                    });
                };
                Component.prototype.renderPopupTo = function(win, props) {
                    var _this9 = this;
                    return _src2.ZalgoPromise.try(function() {
                        return new _parent.ParentComponent(_this9, _this9.getRenderContext(_constants.CONTEXT_TYPES.POPUP), {
                            props: props
                        }).renderTo(win);
                    });
                };
                Component.prototype.prerender = function(props, element) {
                    var instance = new _parent.ParentComponent(this, this.getRenderContext(null, element), {
                        props: props
                    });
                    instance.prefetch();
                    return {
                        render: function(innerProps, innerElement) {
                            innerProps && instance.updateProps(innerProps);
                            return instance.render(innerElement);
                        },
                        renderTo: function(win, innerProps, innerElement) {
                            innerProps && instance.updateProps(innerProps);
                            return instance.renderTo(win, innerElement);
                        },
                        get html() {
                            return instance.html;
                        },
                        set html(value) {
                            instance.html = value;
                        }
                    };
                };
                Component.prototype.log = function(event) {
                    var payload = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    (0, _lib.info)(this.name, event, payload);
                };
                Component.prototype.logWarning = function(event, payload) {
                    (0, _lib.warn)(this.name, event, payload);
                };
                Component.prototype.logError = function(event, payload) {
                    (0, _lib.error)(this.name, event, payload);
                };
                Component.getByTag = function(tag) {
                    return Component.components[tag];
                };
                return Component;
            }(_base.BaseComponent)).prototype, "getPropNames", [ _lib.memoize ], Object.getOwnPropertyDescriptor(_class.prototype, "getPropNames"), _class.prototype), 
            _class)).components = {};
        },
        "./src/component/component/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.getInternalProps = function() {
                return {
                    env: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.defaultEnv;
                        }
                    },
                    uid: {
                        type: "string",
                        def: function() {
                            return (0, _lib.uniqueID)();
                        },
                        queryParam: !0
                    },
                    logLevel: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.defaultLogLevel;
                        }
                    },
                    url: {
                        type: "string",
                        required: !1,
                        promise: !0,
                        sendToChild: !1
                    },
                    dimensions: {
                        type: "object",
                        required: !1
                    },
                    version: {
                        type: "string",
                        required: !1,
                        queryParam: !0,
                        def: function() {
                            return this.version;
                        }
                    },
                    timeout: {
                        type: "number",
                        required: !1,
                        sendToChild: !1
                    },
                    onDisplay: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        memoize: !0,
                        sendToChild: !1
                    },
                    onEnter: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onRender: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onClose: {
                        type: "function",
                        required: !1,
                        noop: !0,
                        once: !0,
                        promisify: !0,
                        sendToChild: !1
                    },
                    onTimeout: {
                        type: "function",
                        required: !1,
                        memoize: !0,
                        promisify: !0,
                        sendToChild: !1,
                        def: function() {
                            return function(err) {
                                if (this.props.onError) return this.props.onError(err);
                                throw err;
                            };
                        }
                    },
                    onError: {
                        type: "function",
                        required: !1,
                        promisify: !0,
                        sendToChild: !0,
                        once: !0,
                        def: function() {
                            return function(err) {
                                setTimeout(function() {
                                    throw err;
                                });
                            };
                        }
                    }
                };
            };
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _lib = __webpack_require__("./src/lib/index.js");
            __webpack_require__("./src/types.js");
        },
        "./src/component/component/templates/component.jsx": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.defaultPrerenderTemplate = function(_ref) {
                var jsxDom = _ref.jsxDom;
                return jsxDom("html", null, jsxDom("head", null, jsxDom("style", null, "\n                        html, body {\n                            width: 100%;\n                            height: 100%;\n                            overflow: hidden;\n                            top: 0;\n                            left: 0;\n                            margin: 0;\n                            text-align: center;\n                        }\n\n                        .spinner {\n                            position: absolute;\n                            max-height: 60vmin;\n                            max-width: 60vmin;\n                            height: 40px;\n                            width: 40px;\n                            top: 50%;\n                            left: 50%;\n                            transform: translateX(-50%) translateY(-50%);\n                            z-index: 10;\n                        }\n\n                        .spinner .loader {\n                            height: 100%;\n                            width: 100%;\n                            box-sizing: border-box;\n                            border: 3px solid rgba(0, 0, 0, .2);\n                            border-top-color: rgba(33, 128, 192, 0.8);\n                            border-radius: 100%;\n                            animation: rotation .7s infinite linear;\n\n                        }\n\n                        @keyframes rotation {\n                            from {\n                                transform: rotate(0deg)\n                            }\n                            to {\n                                transform: rotate(359deg)\n                            }\n                        }\n                    ")), jsxDom("body", null, jsxDom("div", {
                    class: "spinner"
                }, jsxDom("div", {
                    id: "loader",
                    class: "loader"
                }))));
            };
            __webpack_require__("./src/component/parent/index.js");
        },
        "./src/component/component/templates/container.jsx": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.defaultContainerTemplate = function(_ref) {
                var id = _ref.id, tag = _ref.tag, context = _ref.context, CLASS = _ref.CLASS, outlet = _ref.outlet, jsxDom = _ref.jsxDom, _ref$dimensions = _ref.dimensions, width = _ref$dimensions.width, height = _ref$dimensions.height;
                return jsxDom("div", {
                    id: id,
                    class: CLASS.ZOID + " " + CLASS.ZOID + "-tag-" + tag + " " + CLASS.ZOID + "-context-" + context
                }, jsxDom("style", null, "\n                    #" + id + ", #" + id + " > ." + CLASS.OUTLET + " {\n                        width: " + width + ";\n                        height: " + height + ";\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " {\n                        display: inline-block;\n                        position: relative;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe {\n                        height: 100%;\n                        width: 100%;\n                        position: absolute;\n                        top: 0;\n                        left: 0;\n                        transition: opacity .2s ease-in-out;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe." + CLASS.VISIBLE + " {\n                        opacity: 1;\n                    }\n\n                    #" + id + " > ." + CLASS.OUTLET + " > iframe." + CLASS.INVISIBLE + " {\n                        opacity: 0;\n                    }\n                "), outlet);
            };
            __webpack_require__("./src/component/parent/index.js");
        },
        "./src/component/component/templates/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _container = __webpack_require__("./src/component/component/templates/container.jsx");
            Object.keys(_container).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _container[key];
                    }
                });
            });
            var _component = __webpack_require__("./src/component/component/templates/component.jsx");
            Object.keys(_component).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _component[key];
                    }
                });
            });
        },
        "./src/component/component/validate.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.validate = function(options) {
                if (!options) throw new Error("Expecred options to be passed");
                if (!options.tag || !options.tag.match(/^[a-z0-9-]+$/)) throw new Error("Invalid options.tag: " + options.tag);
                !function(options) {
                    if (options.props && "object" !== _typeof(options.props)) throw new Error("Expected options.props to be an object");
                    if (options.props) for (var _iterator = Object.keys(options.props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref, prop = options.props[key];
                        if (!prop || "object" !== (void 0 === prop ? "undefined" : _typeof(prop))) throw new Error("Expected options.props." + key + " to be an object");
                        if (!prop.type) throw new Error("Expected prop.type");
                        if (-1 === _constants.PROP_TYPES_LIST.indexOf(prop.type)) throw new Error("Expected prop.type to be one of " + _constants.PROP_TYPES_LIST.join(", "));
                        if (prop.required && prop.def) throw new Error("Required prop can not have a default value");
                    }
                }(options);
                if (options.dimensions) {
                    if (options.dimensions && !(0, _lib.isPx)(options.dimensions.width) && !(0, _lib.isPerc)(options.dimensions.width)) throw new Error("Expected options.dimensions.width to be a px or % string value");
                    if (options.dimensions && !(0, _lib.isPx)(options.dimensions.height) && !(0, _lib.isPerc)(options.dimensions.height)) throw new Error("Expected options.dimensions.height to be a px or % string value");
                }
                if (options.contexts) {
                    options.contexts.popup, 0;
                    for (var anyEnabled = !1, _iterator2 = Object.keys(options.contexts), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var context = _ref2;
                        if (-1 === _constants.CONTEXT_TYPES_LIST.indexOf(context)) throw new Error("Unsupported context type: " + context);
                        (options.contexts && options.contexts[context] || options.contexts && void 0 === options.contexts[context]) && (anyEnabled = !0);
                    }
                    if (!anyEnabled) throw new Error("No context type is enabled");
                }
                if (options.defaultContext) {
                    if (-1 === _constants.CONTEXT_TYPES_LIST.indexOf(options.defaultContext)) throw new Error("Unsupported context type: " + (options.defaultContext || "unknown"));
                    if (options.contexts && options.defaultContext && !options.contexts[options.defaultContext]) throw new Error("Disallowed default context type: " + (options.defaultContext || "unknown"));
                }
                if (options.url && options.buildUrl) throw new Error("Can not pass both options.url and options.buildUrl");
                if (options.defaultEnv) {
                    if ("string" != typeof options.defaultEnv) throw new TypeError("Expected options.defaultEnv to be a string");
                    if (!options.buildUrl && "object" !== _typeof(options.url)) throw new Error("Expected options.url to be an object mapping env->url");
                    if (options.url && "object" === _typeof(options.url) && !options.url[options.defaultEnv]) throw new Error("No url found for default env: " + options.defaultEnv);
                }
                if (options.url && "object" === _typeof(options.url)) {
                    if (!options.defaultEnv) throw new Error("Must pass options.defaultEnv with env->url mapping");
                    for (var _iterator3 = Object.keys(options.url), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var env = _ref3;
                        if (!options.url[env]) throw new Error("No url specified for env: " + env);
                    }
                }
                if (options.prerenderTemplate && "function" != typeof options.prerenderTemplate) throw new Error("Expected options.prerenderTemplate to be a function");
                if (options.containerTemplate && "function" != typeof options.containerTemplate) throw new Error("Expected options.containerTemplate to be a function");
            };
            var _constants = __webpack_require__("./src/constants.js"), _lib = __webpack_require__("./src/lib/index.js");
        },
        "./src/component/delegate/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.DelegateComponent = void 0;
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        "value" in descriptor && (descriptor.writable = !0);
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    protoProps && defineProperties(Constructor.prototype, protoProps);
                    staticProps && defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }(), _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _base = (__webpack_require__("./node_modules/zalgo-promise/src/index.js"), 
            __webpack_require__("./src/component/base.js")), _parent = __webpack_require__("./src/component/parent/index.js"), _drivers = __webpack_require__("./src/component/parent/drivers.js"), _lib = __webpack_require__("./src/lib/index.js");
            exports.DelegateComponent = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(DelegateComponent, _BaseComponent);
                function DelegateComponent(component, source, options) {
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, DelegateComponent);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    _this.component = component;
                    _this.clean.set("source", source);
                    _this.context = options.context;
                    _this.props = {
                        uid: options.props.uid,
                        dimensions: options.props.dimensions,
                        onClose: options.props.onClose,
                        onDisplay: options.props.onDisplay
                    };
                    var _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var propName = _ref;
                        _this.component.getProp(propName).allowDelegate && (_this.props[propName] = options.props[propName]);
                    }
                    _this.focus = function() {
                        return options.overrides.focus.call(_this);
                    };
                    _this.clean.register("destroyFocusOverride", function() {
                        _this.focus = _lib.noop;
                    });
                    _this.userClose = options.overrides.userClose;
                    _this.getDomain = options.overrides.getDomain;
                    _this.error = options.overrides.error;
                    _this.on = options.overrides.on;
                    var delegateOverrides = _drivers.RENDER_DRIVERS[options.context].delegateOverrides, _iterator2 = Object.keys(delegateOverrides), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref2;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref2 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref2 = _i2.value;
                        }
                        var key = _ref2;
                        _this[key] = _parent.ParentComponent.prototype[key];
                    }
                    _this.childWindowName = options.childWindowName;
                    _parent.ParentComponent.prototype.registerActiveComponent.call(_this);
                    _this.watchForClose();
                    return _this;
                }
                DelegateComponent.prototype.watchForClose = function() {
                    var _this2 = this, closeWindowListener = (0, _src.onCloseWindow)(this.source, function() {
                        return _this2.destroy();
                    }, 3e3);
                    this.clean.register("destroyCloseWindowListener", closeWindowListener.cancel);
                };
                DelegateComponent.prototype.getOverrides = function(context) {
                    var delegateOverrides = _drivers.RENDER_DRIVERS[context].delegateOverrides, overrides = {}, self = this, _loop = function() {
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) return "break";
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) return "break";
                            _ref3 = _i3.value;
                        }
                        var key = _ref3;
                        overrides[key] = function() {
                            return _parent.ParentComponent.prototype[key].apply(self, arguments);
                        };
                    }, _iterator3 = Object.keys(delegateOverrides), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if ("break" === _loop()) break;
                    }
                    return overrides;
                };
                DelegateComponent.prototype.destroy = function() {
                    return this.clean.all();
                };
                _createClass(DelegateComponent, [ {
                    key: "driver",
                    get: function() {
                        if (!this.context) throw new Error("Context not set");
                        return _drivers.RENDER_DRIVERS[this.context];
                    }
                } ]);
                return DelegateComponent;
            }(_base.BaseComponent);
        },
        "./src/component/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _component = __webpack_require__("./src/component/component/index.js");
            Object.keys(_component).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _component[key];
                    }
                });
            });
            var _parent = __webpack_require__("./src/component/parent/index.js");
            Object.keys(_parent).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _parent[key];
                    }
                });
            });
            var _child = __webpack_require__("./src/component/child/index.js");
            Object.keys(_child).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _child[key];
                    }
                });
            });
        },
        "./src/component/parent/drivers.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.RENDER_DRIVERS = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src2 = __webpack_require__("./node_modules/post-robot/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _window = __webpack_require__("./src/component/window.js"), RENDER_DRIVERS = exports.RENDER_DRIVERS = {};
            RENDER_DRIVERS[_constants.CONTEXT_TYPES.IFRAME] = {
                focusable: !1,
                renderedIntoContainerTemplate: !0,
                allowResize: !0,
                openOnClick: !1,
                needsBridge: !1,
                open: function(url) {
                    var _this = this, attributes = this.component.attributes.iframe || {};
                    this.iframe = (0, _lib.iframe)({
                        url: url,
                        attributes: _extends({
                            name: this.childWindowName,
                            title: this.component.name,
                            scrolling: this.component.scrolling ? "yes" : "no"
                        }, attributes),
                        class: [ _constants.CLASS_NAMES.COMPONENT_FRAME, _constants.CLASS_NAMES.INVISIBLE ]
                    }, this.element);
                    return (0, _lib.awaitFrameWindow)(this.iframe).then(function(frameWindow) {
                        _this.window = frameWindow;
                        var detectClose = function() {
                            return _src.ZalgoPromise.try(function() {
                                return _this.props.onClose(_constants.CLOSE_REASONS.CLOSE_DETECTED);
                            }).finally(function() {
                                return _this.destroy();
                            });
                        }, iframeWatcher = (0, _lib.watchElementForClose)(_this.iframe, detectClose), elementWatcher = (0, 
                        _lib.watchElementForClose)(_this.element, detectClose);
                        _this.clean.register("destroyWindow", function() {
                            iframeWatcher.cancel();
                            elementWatcher.cancel();
                            (0, _src2.cleanUpWindow)(_this.window);
                            delete _this.window;
                            if (_this.iframe) {
                                (0, _lib.destroyElement)(_this.iframe);
                                delete _this.iframe;
                            }
                        });
                    });
                },
                openPrerender: function() {
                    var _this2 = this, attributes = this.component.attributes.iframe || {};
                    this.prerenderIframe = (0, _lib.iframe)({
                        attributes: _extends({
                            name: "__prerender__" + this.childWindowName,
                            scrolling: this.component.scrolling ? "yes" : "no"
                        }, attributes),
                        class: [ _constants.CLASS_NAMES.PRERENDER_FRAME, _constants.CLASS_NAMES.VISIBLE ]
                    }, this.element);
                    return (0, _lib.awaitFrameWindow)(this.prerenderIframe).then(function(prerenderFrameWindow) {
                        _this2.prerenderWindow = prerenderFrameWindow;
                        _this2.clean.register("destroyPrerender", function() {
                            if (_this2.prerenderIframe) {
                                (0, _lib.destroyElement)(_this2.prerenderIframe);
                                delete _this2.prerenderIframe;
                            }
                        });
                    });
                },
                switchPrerender: function() {
                    var _this3 = this;
                    (0, _lib.addClass)(this.prerenderIframe, _constants.CLASS_NAMES.INVISIBLE);
                    (0, _lib.removeClass)(this.prerenderIframe, _constants.CLASS_NAMES.VISIBLE);
                    (0, _lib.addClass)(this.iframe, _constants.CLASS_NAMES.VISIBLE);
                    (0, _lib.removeClass)(this.iframe, _constants.CLASS_NAMES.INVISIBLE);
                    setTimeout(function() {
                        _this3.prerenderIframe && (0, _lib.destroyElement)(_this3.prerenderIframe);
                    }, 1e3);
                },
                delegateOverrides: {
                    openContainer: _constants.DELEGATE.CALL_DELEGATE,
                    destroyComponent: _constants.DELEGATE.CALL_DELEGATE,
                    destroyContainer: _constants.DELEGATE.CALL_DELEGATE,
                    cancelContainerEvents: _constants.DELEGATE.CALL_DELEGATE,
                    createPrerenderTemplate: _constants.DELEGATE.CALL_DELEGATE,
                    elementReady: _constants.DELEGATE.CALL_DELEGATE,
                    showContainer: _constants.DELEGATE.CALL_DELEGATE,
                    showComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hideContainer: _constants.DELEGATE.CALL_DELEGATE,
                    hideComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hide: _constants.DELEGATE.CALL_DELEGATE,
                    show: _constants.DELEGATE.CALL_DELEGATE,
                    resize: _constants.DELEGATE.CALL_DELEGATE,
                    loadUrl: _constants.DELEGATE.CALL_DELEGATE,
                    hijackSubmit: _constants.DELEGATE.CALL_DELEGATE,
                    openPrerender: _constants.DELEGATE.CALL_DELEGATE,
                    switchPrerender: _constants.DELEGATE.CALL_DELEGATE,
                    renderTemplate: _constants.DELEGATE.CALL_ORIGINAL,
                    openContainerFrame: _constants.DELEGATE.CALL_ORIGINAL,
                    getOutlet: _constants.DELEGATE.CALL_ORIGINAL,
                    open: function(original, override) {
                        return function() {
                            var _this4 = this;
                            return override.apply(this, arguments).then(function() {
                                _this4.clean.set("window", (0, _src3.findFrameByName)((0, _window.getParentComponentWindow)(), _this4.childWindowName));
                                if (!_this4.window) throw new Error("Unable to find parent component iframe window");
                            });
                        };
                    }
                },
                resize: function(width, height) {
                    if (width) {
                        this.container.style.width = (0, _lib.toCSS)(width);
                        this.element.style.width = (0, _lib.toCSS)(width);
                    }
                    if (height) {
                        this.container.style.height = (0, _lib.toCSS)(height);
                        this.element.style.height = (0, _lib.toCSS)(height);
                    }
                },
                show: function() {
                    (0, _lib.showElement)(this.element);
                },
                hide: function() {
                    (0, _lib.hideElement)(this.element);
                },
                loadUrl: function(url) {
                    this.iframe.setAttribute("src", url);
                }
            };
            RENDER_DRIVERS[_constants.CONTEXT_TYPES.POPUP] = {
                focusable: !0,
                renderedIntoContainerTemplate: !1,
                allowResize: !1,
                openOnClick: !0,
                needsBridge: !0,
                open: function() {
                    var _this5 = this, url = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                    return _src.ZalgoPromise.try(function() {
                        var _ref = _this5.component.dimensions || {}, _ref$width = _ref.width, width = void 0 === _ref$width ? _constants.DEFAULT_DIMENSIONS.WIDTH : _ref$width, _ref$height = _ref.height, height = void 0 === _ref$height ? _constants.DEFAULT_DIMENSIONS.HEIGHT : _ref$height;
                        width = (0, _lib.normalizeDimension)(width, window.outerWidth);
                        height = (0, _lib.normalizeDimension)(height, window.outerWidth);
                        var _getPosition = (0, _window.getPosition)({
                            width: width,
                            height: height
                        }), x = _getPosition.x, y = _getPosition.y, attributes = _this5.component.attributes.popup || {};
                        _this5.window = (0, _lib.popup)(url || "", _extends({
                            name: _this5.childWindowName,
                            width: width,
                            height: height,
                            top: y,
                            left: x,
                            status: 1,
                            toolbar: 0,
                            menubar: 0,
                            resizable: 1,
                            scrollbars: 1
                        }, attributes));
                        _this5.prerenderWindow = _this5.window;
                        _this5.clean.register("destroyWindow", function() {
                            if (_this5.window) {
                                _this5.window.close();
                                (0, _src2.cleanUpWindow)(_this5.window);
                                delete _this5.window;
                                delete _this5.prerenderWindow;
                            }
                        });
                        _this5.resize(width, height);
                    });
                },
                openPrerender: function() {
                    return _src.ZalgoPromise.try(_lib.noop);
                },
                resize: function() {},
                hide: function() {
                    throw new Error("Can not hide popup");
                },
                show: function() {
                    throw new Error("Can not show popup");
                },
                delegateOverrides: {
                    openContainer: _constants.DELEGATE.CALL_DELEGATE,
                    destroyContainer: _constants.DELEGATE.CALL_DELEGATE,
                    elementReady: _constants.DELEGATE.CALL_DELEGATE,
                    showContainer: _constants.DELEGATE.CALL_DELEGATE,
                    showComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hideContainer: _constants.DELEGATE.CALL_DELEGATE,
                    hideComponent: _constants.DELEGATE.CALL_DELEGATE,
                    hide: _constants.DELEGATE.CALL_DELEGATE,
                    show: _constants.DELEGATE.CALL_DELEGATE,
                    cancelContainerEvents: _constants.DELEGATE.CALL_DELEGATE,
                    open: _constants.DELEGATE.CALL_ORIGINAL,
                    loadUrl: _constants.DELEGATE.CALL_ORIGINAL,
                    createPrerenderTemplate: _constants.DELEGATE.CALL_ORIGINAL,
                    destroyComponent: _constants.DELEGATE.CALL_ORIGINAL,
                    resize: _constants.DELEGATE.CALL_ORIGINAL,
                    renderTemplate: _constants.DELEGATE.CALL_ORIGINAL,
                    openContainerFrame: _constants.DELEGATE.CALL_ORIGINAL,
                    getOutlet: _constants.DELEGATE.CALL_ORIGINAL
                },
                loadUrl: function(url) {
                    if ((0, _src3.isSameDomain)(this.window)) try {
                        if (this.window.location && this.window.location.replace) {
                            this.window.location.replace(url);
                            return;
                        }
                    } catch (err) {}
                    this.window.location = url;
                }
            };
        },
        "./src/component/parent/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.ParentComponent = void 0;
            var _class, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        "value" in descriptor && (descriptor.writable = !0);
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    protoProps && defineProperties(Constructor.prototype, protoProps);
                    staticProps && defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }(), _client = __webpack_require__("./node_modules/beaver-logger/client/index.js"), _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _src2 = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src3 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _base = __webpack_require__("./src/component/base.js"), _window = __webpack_require__("./src/component/window.js"), _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js"), _error = __webpack_require__("./src/error.js"), _drivers = __webpack_require__("./src/component/parent/drivers.js"), _validate = __webpack_require__("./src/component/parent/validate.js"), _props = __webpack_require__("./src/component/parent/props.js");
            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
                var desc = {};
                Object.keys(descriptor).forEach(function(key) {
                    desc[key] = descriptor[key];
                });
                desc.enumerable = !!desc.enumerable;
                desc.configurable = !!desc.configurable;
                ("value" in desc || desc.initializer) && (desc.writable = !0);
                desc = decorators.slice().reverse().reduce(function(desc, decorator) {
                    return decorator(target, property, desc) || desc;
                }, desc);
                if (context && void 0 !== desc.initializer) {
                    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                    desc.initializer = void 0;
                }
                if (void 0 === desc.initializer) {
                    Object.defineProperty(target, property, desc);
                    desc = null;
                }
                return desc;
            }
            _lib.global.props = _lib.global.props || {};
            _lib.global.windows = _lib.global.windows || {};
            (exports.ParentComponent = (_applyDecoratedDescriptor((_class = function(_BaseComponent) {
                !function(subClass, superClass) {
                    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    });
                    superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                }(ParentComponent, _BaseComponent);
                function ParentComponent(component, context, _ref) {
                    var props = _ref.props;
                    !function(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    }(this, ParentComponent);
                    var _this = function(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" != typeof call && "function" != typeof call ? self : call;
                    }(this, _BaseComponent.call(this));
                    _this.component = component;
                    _this.validateParentDomain();
                    _this.context = context;
                    _this.setProps(props);
                    _this.props.logLevel && (0, _lib.setLogLevel)(_this.props.logLevel);
                    _this.childWindowName = _this.buildChildWindowName({
                        renderTo: window
                    });
                    _this.registerActiveComponent();
                    _this.component.log("construct_parent");
                    _this.watchForUnload();
                    _this.onInit = new _src3.ZalgoPromise();
                    _this.onInit.catch(function(err) {
                        return _this.error(err);
                    });
                    return _this;
                }
                ParentComponent.prototype.render = function(element) {
                    var _this2 = this, loadUrl = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return this.tryInit(function() {
                        _this2.component.log("render_" + _this2.context, {
                            context: _this2.context,
                            element: element,
                            loadUrl: (0, _lib.stringify)(loadUrl)
                        });
                        var tasks = {};
                        tasks.onRender = _this2.props.onRender();
                        tasks.getDomain = _this2.getDomain();
                        tasks.elementReady = _src3.ZalgoPromise.try(function() {
                            if (element) return _this2.elementReady(element);
                        });
                        tasks.openContainer = tasks.elementReady.then(function() {
                            return _this2.openContainer(element);
                        });
                        tasks.showContainer = tasks.openContainer.then(function() {
                            return _this2.showContainer();
                        });
                        tasks.openPrerender = tasks.openContainer.then(function() {
                            return _this2.openPrerender();
                        });
                        tasks.switchPrerender = _src3.ZalgoPromise.all([ tasks.openPrerender, _this2.onInit ]).then(function() {
                            return _this2.switchPrerender();
                        });
                        tasks.open = _this2.driver.openOnClick ? _this2.open() : tasks.openContainer.then(function() {
                            return _this2.open();
                        });
                        tasks.listen = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref2) {
                            var domain = _ref2[0];
                            _this2.listen(_this2.window, domain);
                        });
                        tasks.watchForClose = tasks.open.then(function() {
                            return _this2.watchForClose();
                        });
                        tasks.linkDomain = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref3) {
                            var domain = _ref3[0];
                            if (_src.bridge && "string" == typeof domain) return _src.bridge.linkUrl(_this2.window, domain);
                        });
                        if (!_this2.html) {
                            tasks.createPrerenderTemplate = tasks.openPrerender.then(function() {
                                return _this2.createPrerenderTemplate();
                            });
                            tasks.showComponent = tasks.createPrerenderTemplate.then(function() {
                                return _this2.showComponent();
                            });
                        }
                        tasks.openBridge = _src3.ZalgoPromise.all([ tasks.getDomain, tasks.open ]).then(function(_ref4) {
                            var domain = _ref4[0];
                            return _this2.openBridge("string" == typeof domain ? domain : null);
                        });
                        if (_this2.html) tasks.loadHTML = tasks.open.then(function() {
                            return _this2.loadHTML();
                        }); else if (loadUrl) {
                            tasks.buildUrl = _this2.buildUrl();
                            tasks.loadUrl = _src3.ZalgoPromise.all([ tasks.buildUrl, tasks.open, tasks.linkDomain, tasks.listen, tasks.open, tasks.openBridge, tasks.createPrerenderTemplate ]).then(function(_ref5) {
                                var url = _ref5[0];
                                return _this2.loadUrl(url);
                            });
                            tasks.runTimeout = tasks.loadUrl.then(function() {
                                return _this2.runTimeout();
                            });
                        }
                        return _src3.ZalgoPromise.hash(tasks);
                    }).then(function() {
                        return _this2.props.onEnter();
                    }).then(function() {
                        return _this2;
                    });
                };
                ParentComponent.prototype.getOutlet = function() {
                    var outlet = document.createElement("div");
                    (0, _lib.addClass)(outlet, _constants.CLASS_NAMES.OUTLET);
                    return outlet;
                };
                ParentComponent.prototype.validateParentDomain = function() {
                    var domain = (0, _src2.getDomain)();
                    if (!(0, _src2.matchDomain)(this.component.allowedParentDomains, domain)) throw new _error.RenderError("Can not be rendered by domain: " + domain);
                };
                ParentComponent.prototype.renderTo = function(win, element) {
                    var _this3 = this;
                    return this.tryInit(function() {
                        if (win === window) return _this3.render(element);
                        if (!(0, _src2.isSameTopWindow)(window, win)) throw new Error("Can only renderTo an adjacent frame");
                        if (element && "string" != typeof element) throw new Error("Element passed to renderTo must be a string selector, got " + (void 0 === element ? "undefined" : _typeof(element)) + " " + element);
                        _this3.checkAllowRenderTo(win);
                        _this3.component.log("render_" + _this3.context + "_to_win", {
                            element: (0, _lib.stringify)(element),
                            context: _this3.context
                        });
                        _this3.childWindowName = _this3.buildChildWindowName({
                            renderTo: win
                        });
                        _this3.delegate(win);
                        return _this3.render(element);
                    });
                };
                ParentComponent.prototype.prefetch = function() {
                    var _this4 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this4.html = _this4.buildUrl().then(function(url) {
                            return (0, _lib.prefetchPage)(url).then(function(html) {
                                return '\n                        <base href="' + ("" + url.split("/").slice(0, 3).join("/")) + '">\n\n                        ' + html + "\n\n                        <script>\n                            if (window.history && window.history.pushState) {\n                                window.history.pushState({}, '', '" + ("/" + url.split("/").slice(3).join("/")) + "');\n                            }\n                        <\/script>\n                    ";
                            });
                        });
                    });
                };
                ParentComponent.prototype.loadHTML = function() {
                    var _this5 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (!_this5.html) throw new Error("Html not prefetched");
                        return _this5.html.then(function(html) {
                            return (0, _lib.writeToWindow)(_this5.window, html);
                        });
                    });
                };
                ParentComponent.prototype.checkAllowRenderTo = function(win) {
                    if (!win) throw this.component.createError("Must pass window to renderTo");
                    if (!(0, _src2.isSameDomain)(win)) {
                        var origin = (0, _src2.getDomain)(), domain = this.component.getDomain(null, this.props.env);
                        if (!domain) throw new Error("Could not determine domain to allow remote render");
                        if (!(0, _src2.matchDomain)(domain, origin)) throw new Error("Can not render remotely to " + domain.toString() + " - can only render to " + origin);
                    }
                };
                ParentComponent.prototype.registerActiveComponent = function() {
                    var _this6 = this;
                    ParentComponent.activeComponents.push(this);
                    this.clean.register(function() {
                        ParentComponent.activeComponents.splice(ParentComponent.activeComponents.indexOf(_this6), 1);
                    });
                };
                ParentComponent.prototype.getComponentParentRef = function() {
                    var renderToWindow = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window;
                    if (this.context === _constants.CONTEXT_TYPES.POPUP) return {
                        ref: _constants.WINDOW_REFERENCES.OPENER
                    };
                    if (renderToWindow === window) return (0, _src2.isTop)(window) ? {
                        ref: _constants.WINDOW_REFERENCES.TOP
                    } : {
                        ref: _constants.WINDOW_REFERENCES.PARENT,
                        distance: (0, _src2.getDistanceFromTop)(window)
                    };
                    var uid = (0, _lib.uniqueID)();
                    _lib.global.windows[uid] = window;
                    this.clean.register(function() {
                        delete _lib.global.windows[uid];
                    });
                    return {
                        ref: _constants.WINDOW_REFERENCES.GLOBAL,
                        uid: uid
                    };
                };
                ParentComponent.prototype.getRenderParentRef = function() {
                    var renderToWindow = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window;
                    if (renderToWindow === window) return this.getComponentParentRef(renderToWindow);
                    var uid = (0, _lib.uniqueID)();
                    _lib.global.windows[uid] = renderToWindow;
                    this.clean.register(function() {
                        delete _lib.global.windows[uid];
                    });
                    return {
                        ref: _constants.WINDOW_REFERENCES.GLOBAL,
                        uid: uid
                    };
                };
                ParentComponent.prototype.buildChildWindowName = function() {
                    var _ref6$renderTo = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).renderTo, renderTo = void 0 === _ref6$renderTo ? window : _ref6$renderTo, sameDomain = (0, 
                    _src2.isSameDomain)(renderTo), uid = (0, _lib.uniqueID)(), tag = this.component.tag, sProps = (0, 
                    _lib.serializeFunctions)(this.getPropsForChild()), componentParent = this.getComponentParentRef(renderTo), renderParent = this.getRenderParentRef(renderTo), props = !sameDomain && !this.component.unsafeRenderTo ? {
                        type: _constants.INITIAL_PROPS.UID,
                        uid: uid
                    } : {
                        type: _constants.INITIAL_PROPS.RAW,
                        value: sProps
                    };
                    if (props.type === _constants.INITIAL_PROPS.UID) {
                        _lib.global.props[uid] = JSON.stringify(sProps);
                        this.clean.register(function() {
                            delete _lib.global.props[uid];
                        });
                    }
                    return (0, _window.buildChildWindowName)(this.component.name, this.component.version, {
                        uid: uid,
                        tag: tag,
                        componentParent: componentParent,
                        renderParent: renderParent,
                        props: props
                    });
                };
                ParentComponent.prototype.sendToParent = function(name, data) {
                    if (!(0, _window.getParentComponentWindow)()) throw new Error("Can not find parent component window to message");
                    this.component.log("send_to_parent_" + name);
                    return (0, _src.send)((0, _window.getParentComponentWindow)(), name, data, {
                        domain: (0, _window.getParentDomain)()
                    });
                };
                ParentComponent.prototype.setProps = function(props) {
                    var required = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    (0, _validate.validateProps)(this.component, props, required);
                    this.component.validate && this.component.validate(this.component, props);
                    this.props = this.props || {};
                    (0, _lib.extend)(this.props, (0, _props.normalizeProps)(this.component, this, props));
                };
                ParentComponent.prototype.buildUrl = function() {
                    var _this7 = this, propUrl = this.props.url;
                    return _src3.ZalgoPromise.all([ propUrl, (0, _props.propsToQuery)(_extends({}, this.component.props, this.component.builtinProps), this.props) ]).then(function(_ref7) {
                        var url = _ref7[0], query = _ref7[1];
                        return url && !_this7.component.getValidDomain(url) ? url : _src3.ZalgoPromise.try(function() {
                            return url || _this7.component.getUrl(_this7.props.env, _this7.props);
                        }).then(function(finalUrl) {
                            query.xcomponent = "1";
                            return (0, _lib.extendUrl)(finalUrl, {
                                query: query
                            });
                        });
                    });
                };
                ParentComponent.prototype.getDomain = function() {
                    var _this8 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this8.props.url;
                    }).then(function(url) {
                        var domain = _this8.component.getDomain(url, _this8.props.env);
                        return domain || (_this8.component.buildUrl ? _src3.ZalgoPromise.try(function() {
                            return _this8.component.buildUrl(_this8.props);
                        }).then(function(builtUrl) {
                            return _this8.component.getDomain(builtUrl, _this8.props.env);
                        }) : void 0);
                    }).then(function(domain) {
                        if (!domain) throw new Error("Could not determine domain");
                        return domain;
                    });
                };
                ParentComponent.prototype.getPropsForChild = function() {
                    var result = {}, _iterator = Object.keys(this.props), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref8;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref8 = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref8 = _i.value;
                        }
                        var key = _ref8, prop = this.component.getProp(key);
                        prop && !1 === prop.sendToChild || (result[key] = this.props[key]);
                    }
                    return result;
                };
                ParentComponent.prototype.updateProps = function(props) {
                    var _this9 = this;
                    this.setProps(props, !1);
                    return this.onInit.then(function() {
                        if (_this9.childExports) return _this9.childExports.updateProps(_this9.getPropsForChild());
                        throw new Error("Child exports were not available");
                    });
                };
                ParentComponent.prototype.openBridge = function(domain) {
                    var _this10 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_src.bridge && _this10.driver.needsBridge) {
                            var needsBridgeParams = {
                                win: _this10.window
                            };
                            domain && (needsBridgeParams.domain = domain);
                            var needsBridge = _src.bridge.needsBridge(needsBridgeParams), bridgeUrl = _this10.component.getBridgeUrl(_this10.props.env);
                            if (bridgeUrl) {
                                bridgeUrl = (0, _lib.extendUrl)(bridgeUrl, {
                                    query: {
                                        version: _this10.component.version
                                    }
                                });
                                var bridgeDomain = _this10.component.getBridgeDomain(_this10.props.env);
                                if (!bridgeDomain) throw new Error("Can not determine domain for bridge");
                                return needsBridge ? _src.bridge.openBridge(bridgeUrl, bridgeDomain).then(function(result) {
                                    if (result) return result;
                                }) : void 0;
                            }
                            if (needsBridge && domain && !_src.bridge.hasBridge(domain, domain)) throw new Error("Bridge url needed to render " + _this10.context);
                        }
                    });
                };
                ParentComponent.prototype.open = function() {
                    var _this11 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this11.component.log("open_" + _this11.context, {
                            windowName: _this11.childWindowName
                        });
                        return _this11.driver.open.call(_this11);
                    });
                };
                ParentComponent.prototype.openPrerender = function() {
                    var _this12 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this12.component.prerenderTemplate) return _this12.driver.openPrerender.call(_this12);
                    });
                };
                ParentComponent.prototype.switchPrerender = function() {
                    var _this13 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this13.prerenderWindow && _this13.driver.switchPrerender) return _this13.driver.switchPrerender.call(_this13);
                    });
                };
                ParentComponent.prototype.elementReady = function(element) {
                    return (0, _lib.elementReady)(element).then(_lib.noop);
                };
                ParentComponent.prototype.delegate = function(win) {
                    var _this14 = this;
                    this.component.log("delegate_" + this.context);
                    var props = {
                        uid: this.props.uid,
                        dimensions: this.props.dimensions,
                        onClose: this.props.onClose,
                        onDisplay: this.props.onDisplay
                    }, _iterator2 = this.component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                    for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                        var _ref9;
                        if (_isArray2) {
                            if (_i2 >= _iterator2.length) break;
                            _ref9 = _iterator2[_i2++];
                        } else {
                            if ((_i2 = _iterator2.next()).done) break;
                            _ref9 = _i2.value;
                        }
                        var propName = _ref9;
                        this.component.getProp(propName).allowDelegate && (props[propName] = this.props[propName]);
                    }
                    var delegate = (0, _src.send)(win, _constants.POST_MESSAGE.DELEGATE + "_" + this.component.name, {
                        context: this.context,
                        env: this.props.env,
                        options: {
                            context: this.context,
                            childWindowName: this.childWindowName,
                            props: props,
                            overrides: {
                                focus: function() {
                                    return _this14.focus();
                                },
                                userClose: function() {
                                    return _this14.userClose();
                                },
                                getDomain: function() {
                                    return _this14.getDomain();
                                },
                                error: function(err) {
                                    return _this14.error(err);
                                },
                                on: function(eventName, handler) {
                                    return _this14.on(eventName, handler);
                                }
                            }
                        }
                    }).then(function(_ref10) {
                        var data = _ref10.data;
                        _this14.clean.register(data.destroy);
                        return data;
                    }).catch(function(err) {
                        throw new Error("Unable to delegate rendering. Possibly the component is not loaded in the target window.\n\n" + (0, 
                        _lib.stringifyError)(err));
                    }), overrides = this.driver.delegateOverrides, _loop = function() {
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) return "break";
                            _ref11 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) return "break";
                            _ref11 = _i3.value;
                        }
                        var key = _ref11, val = overrides[key];
                        if (val === _constants.DELEGATE.CALL_ORIGINAL) return "continue";
                        var original = _this14[key];
                        _this14[key] = function() {
                            var _this15 = this, _arguments = arguments;
                            return delegate.then(function(data) {
                                var override = data.overrides[key];
                                if (val === _constants.DELEGATE.CALL_DELEGATE) return override.apply(_this15, _arguments);
                                if ("function" == typeof val) return val(original, override).apply(_this15, _arguments);
                                throw new Error("Expected delgate to be CALL_ORIGINAL, CALL_DELEGATE, or factory method");
                            });
                        };
                    };
                    var _iterator3 = Object.keys(overrides), _isArray3 = Array.isArray(_iterator3), _i3 = 0;
                    _loop2: for (_iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref11;
                        switch (_loop()) {
                          case "break":
                            break _loop2;

                          case "continue":
                            continue;
                        }
                    }
                };
                ParentComponent.prototype.watchForClose = function() {
                    var _this16 = this, closeWindowListener = (0, _src2.onCloseWindow)(this.window, function() {
                        _this16.component.log("detect_close_child");
                        return _src3.ZalgoPromise.try(function() {
                            return _this16.props.onClose(_constants.CLOSE_REASONS.CLOSE_DETECTED);
                        }).finally(function() {
                            return _this16.destroy();
                        });
                    }, 3e3);
                    this.clean.register("destroyCloseWindowListener", closeWindowListener.cancel);
                };
                ParentComponent.prototype.watchForUnload = function() {
                    var _this17 = this, onunload = (0, _lib.once)(function() {
                        _this17.component.log("navigate_away");
                        (0, _client.flush)();
                        _this17.destroyComponent();
                    }), unloadWindowListener = (0, _lib.addEventListener)(window, "unload", onunload);
                    this.clean.register("destroyUnloadWindowListener", unloadWindowListener.cancel);
                };
                ParentComponent.prototype.loadUrl = function(url) {
                    var _this18 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this18.component.log("load_url");
                        if (window.location.href.split("#")[0] === url.split("#")[0]) {
                            var _query;
                            url = (0, _lib.extendUrl)(url, {
                                query: (_query = {}, _query[(0, _lib.uniqueID)()] = "1", _query)
                            });
                        }
                        return _this18.driver.loadUrl.call(_this18, url);
                    });
                };
                ParentComponent.prototype.hijack = function(targetElement) {
                    targetElement.target = this.childWindowName;
                };
                ParentComponent.prototype.runTimeout = function() {
                    var _this19 = this, timeout = this.props.timeout;
                    if (timeout) {
                        var _id = this.timeout = setTimeout(function() {
                            _this19.component.log("timed_out", {
                                timeout: timeout.toString()
                            });
                            var error = _this19.component.createError("Loading component timed out after " + timeout + " milliseconds");
                            _this19.onInit.reject(error);
                            _this19.props.onTimeout(error);
                        }, timeout);
                        this.clean.register(function() {
                            clearTimeout(_id);
                            delete _this19.timeout;
                        });
                    }
                };
                ParentComponent.prototype.listeners = function() {
                    var _ref12;
                    return (_ref12 = {})[_constants.POST_MESSAGE.INIT] = function(source, data) {
                        this.childExports = data.exports;
                        this.onInit.resolve(this);
                        this.timeout && clearTimeout(this.timeout);
                        return {
                            props: this.getPropsForChild(),
                            context: this.context
                        };
                    }, _ref12[_constants.POST_MESSAGE.CLOSE] = function(source, data) {
                        this.close(data.reason);
                    }, _ref12[_constants.POST_MESSAGE.CHECK_CLOSE] = function() {
                        this.checkClose();
                    }, _ref12[_constants.POST_MESSAGE.RESIZE] = function(source, data) {
                        var _this20 = this;
                        return _src3.ZalgoPromise.try(function() {
                            if (_this20.driver.allowResize) return _this20.resize(data.width, data.height);
                        });
                    }, _ref12[_constants.POST_MESSAGE.ONRESIZE] = function() {
                        this.event.trigger("resize");
                    }, _ref12[_constants.POST_MESSAGE.HIDE] = function() {
                        this.hide();
                    }, _ref12[_constants.POST_MESSAGE.SHOW] = function() {
                        this.show();
                    }, _ref12[_constants.POST_MESSAGE.ERROR] = function(source, data) {
                        this.error(new Error(data.error));
                    }, _ref12;
                };
                ParentComponent.prototype.resize = function(width, height) {
                    var _this21 = this, _ref13$waitForTransit = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).waitForTransition, waitForTransition = void 0 === _ref13$waitForTransit || _ref13$waitForTransit;
                    return _src3.ZalgoPromise.try(function() {
                        _this21.component.log("resize", {
                            height: (0, _lib.stringify)(height),
                            width: (0, _lib.stringify)(width)
                        });
                        _this21.driver.resize.call(_this21, width, height);
                        if (waitForTransition && (_this21.element || _this21.iframe)) {
                            var overflow = void 0;
                            _this21.element && (overflow = (0, _lib.setOverflow)(_this21.element, "hidden"));
                            return (0, _lib.elementStoppedMoving)(_this21.element || _this21.iframe).then(function() {
                                overflow && overflow.reset();
                            });
                        }
                    });
                };
                ParentComponent.prototype.hide = function() {
                    this.container && (0, _lib.hideElement)(this.container);
                    return this.driver.hide.call(this);
                };
                ParentComponent.prototype.show = function() {
                    this.container && (0, _lib.showElement)(this.container);
                    return this.driver.show.call(this);
                };
                ParentComponent.prototype.checkClose = function() {
                    var _this22 = this, closeWindowListener = (0, _src2.onCloseWindow)(this.window, function() {
                        _this22.userClose();
                    }, 50, 500);
                    this.clean.register(closeWindowListener.cancel);
                };
                ParentComponent.prototype.userClose = function() {
                    return this.close(_constants.CLOSE_REASONS.USER_CLOSED);
                };
                ParentComponent.prototype.close = function() {
                    var _this23 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL;
                    return _src3.ZalgoPromise.try(function() {
                        _this23.component.log("close", {
                            reason: reason
                        });
                        _this23.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this23.props.onClose(reason);
                    }).then(function() {
                        return _src3.ZalgoPromise.all([ _this23.closeComponent(), _this23.closeContainer() ]);
                    }).then(function() {
                        return _this23.destroy();
                    });
                };
                ParentComponent.prototype.closeContainer = function() {
                    var _this24 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL;
                    return _src3.ZalgoPromise.try(function() {
                        _this24.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this24.props.onClose(reason);
                    }).then(function() {
                        return _src3.ZalgoPromise.all([ _this24.closeComponent(reason), _this24.hideContainer() ]);
                    }).then(function() {
                        return _this24.destroyContainer();
                    });
                };
                ParentComponent.prototype.destroyContainer = function() {
                    var _this25 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this25.clean.run("destroyContainerEvents");
                        _this25.clean.run("destroyContainerTemplate");
                    });
                };
                ParentComponent.prototype.closeComponent = function() {
                    var _this26 = this, reason = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _constants.CLOSE_REASONS.PARENT_CALL, win = this.window;
                    return _src3.ZalgoPromise.try(function() {
                        return _this26.cancelContainerEvents();
                    }).then(function() {
                        _this26.event.triggerOnce(_constants.EVENTS.CLOSE);
                        return _this26.props.onClose(reason);
                    }).then(function() {
                        return _this26.hideComponent();
                    }).then(function() {
                        return _this26.destroyComponent();
                    }).then(function() {
                        _this26.childExports && _this26.context === _constants.CONTEXT_TYPES.POPUP && !(0, 
                        _src2.isWindowClosed)(win) && _this26.childExports.close().catch(_lib.noop);
                    });
                };
                ParentComponent.prototype.destroyComponent = function() {
                    this.clean.run("destroyUnloadWindowListener");
                    this.clean.run("destroyCloseWindowListener");
                    this.clean.run("destroyContainerEvents");
                    this.clean.run("destroyWindow");
                };
                ParentComponent.prototype.showContainer = function() {
                    var _this27 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this27.props.onDisplay) return _this27.props.onDisplay();
                    }).then(function() {
                        if (_this27.container) return (0, _lib.showAndAnimate)(_this27.container, _constants.ANIMATION_NAMES.SHOW_CONTAINER, _this27.clean.register);
                    });
                };
                ParentComponent.prototype.showComponent = function() {
                    var _this28 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this28.props.onDisplay) return _this28.props.onDisplay();
                    }).then(function() {
                        if (_this28.element) return (0, _lib.showAndAnimate)(_this28.element, _constants.ANIMATION_NAMES.SHOW_COMPONENT, _this28.clean.register);
                    });
                };
                ParentComponent.prototype.hideContainer = function() {
                    var _this29 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this29.container ? (0, _lib.animateAndHide)(_this29.container, _constants.ANIMATION_NAMES.HIDE_CONTAINER, _this29.clean.register) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.hideComponent = function() {
                    var _this30 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this30.element ? (0, _lib.animateAndHide)(_this30.element, _constants.ANIMATION_NAMES.HIDE_COMPONENT, _this30.clean.register) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.focus = function() {
                    if (!this.window || (0, _src2.isWindowClosed)(this.window)) throw new Error("No window to focus");
                    this.component.log("focus");
                    this.window.focus();
                };
                ParentComponent.prototype.createPrerenderTemplate = function() {
                    var _this31 = this;
                    return _src3.ZalgoPromise.try(function() {
                        return _this31.component.prerenderTemplate ? _src3.ZalgoPromise.try(function() {
                            return _this31.prerenderIframe ? (0, _lib.awaitFrameLoad)(_this31.prerenderIframe).then(function() {
                                return _this31.prerenderWindow;
                            }) : _this31.prerenderWindow;
                        }).then(function(win) {
                            var doc = void 0;
                            try {
                                doc = win.document;
                            } catch (err) {
                                return;
                            }
                            try {
                                (0, _lib.writeElementToWindow)(win, _this31.renderTemplate(_this31.component.prerenderTemplate, {
                                    jsxDom: _lib.jsxDom.bind(doc),
                                    document: doc
                                }));
                            } catch (err) {}
                        }) : _src3.ZalgoPromise.resolve();
                    });
                };
                ParentComponent.prototype.renderTemplate = function(renderer) {
                    var _this32 = this, options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref14 = this.component.dimensions || {}, _ref14$width = _ref14.width, width = void 0 === _ref14$width ? _constants.DEFAULT_DIMENSIONS.WIDTH + "px" : _ref14$width, _ref14$height = _ref14.height, height = void 0 === _ref14$height ? _constants.DEFAULT_DIMENSIONS.HEIGHT + "px" : _ref14$height;
                    return renderer.call(this, _extends({
                        id: _constants.CLASS_NAMES.ZOID + "-" + this.component.tag + "-" + this.props.uid,
                        props: renderer.__xdomain__ ? null : this.props,
                        tag: this.component.tag,
                        context: this.context,
                        outlet: this.getOutlet(),
                        CLASS: _constants.CLASS_NAMES,
                        ANIMATION: _constants.ANIMATION_NAMES,
                        CONTEXT: _constants.CONTEXT_TYPES,
                        EVENT: _constants.EVENTS,
                        actions: {
                            close: function() {
                                return _this32.userClose();
                            },
                            focus: function() {
                                return _this32.focus();
                            }
                        },
                        on: function(eventName, handler) {
                            return _this32.on(eventName, handler);
                        },
                        jsxDom: _lib.jsxDom,
                        document: document,
                        dimensions: {
                            width: width,
                            height: height
                        }
                    }, options));
                };
                ParentComponent.prototype.openContainer = function(element) {
                    var _this33 = this;
                    return _src3.ZalgoPromise.try(function() {
                        var el = void 0;
                        if (!(el = element ? (0, _lib.getElement)(element) : document.body)) throw new Error("Could not find element to open container into");
                        if (_this33.component.containerTemplate) {
                            var container = _this33.renderTemplate(_this33.component.containerTemplate, {
                                container: el
                            });
                            _this33.container = container;
                            (0, _lib.hideElement)(_this33.container);
                            (0, _lib.appendChild)(el, _this33.container);
                            if (_this33.driver.renderedIntoContainerTemplate) {
                                _this33.element = _this33.getOutlet();
                                (0, _lib.hideElement)(_this33.element);
                                if (!_this33.element) throw new Error("Could not find element to render component into");
                                (0, _lib.hideElement)(_this33.element);
                            }
                            _this33.clean.register("destroyContainerTemplate", function() {
                                _this33.container && _this33.container.parentNode && _this33.container.parentNode.removeChild(_this33.container);
                                delete _this33.container;
                            });
                        } else if (_this33.driver.renderedIntoContainerTemplate) throw new Error("containerTemplate needed to render " + _this33.context);
                    });
                };
                ParentComponent.prototype.cancelContainerEvents = function() {
                    this.clean.run("destroyContainerEvents");
                };
                ParentComponent.prototype.destroy = function() {
                    var _this34 = this;
                    return _src3.ZalgoPromise.try(function() {
                        if (_this34.clean.hasTasks()) {
                            _this34.component.log("destroy");
                            (0, _client.flush)();
                            return _this34.clean.all();
                        }
                    });
                };
                ParentComponent.prototype.tryInit = function(method) {
                    var _this35 = this;
                    return _src3.ZalgoPromise.try(method).catch(function(err) {
                        _this35.onInit.reject(err);
                    }).then(function() {
                        return _this35.onInit;
                    });
                };
                ParentComponent.prototype.error = function(err) {
                    var _this36 = this;
                    return _src3.ZalgoPromise.try(function() {
                        _this36.handledErrors = _this36.handledErrors || [];
                        if (-1 === _this36.handledErrors.indexOf(err)) {
                            _this36.handledErrors.push(err);
                            _this36.onInit.reject(err);
                            return _this36.destroy();
                        }
                    }).then(function() {
                        if (_this36.props.onError) return _this36.props.onError(err);
                    }).catch(function(errErr) {
                        throw new Error("An error was encountered while handling error:\n\n " + (0, _lib.stringifyError)(err) + "\n\n" + (0, 
                        _lib.stringifyError)(errErr));
                    }).then(function() {
                        if (!_this36.props.onError) throw err;
                    });
                };
                ParentComponent.destroyAll = function() {
                    for (var results = []; ParentComponent.activeComponents.length; ) results.push(ParentComponent.activeComponents[0].destroy());
                    return _src3.ZalgoPromise.all(results).then(_lib.noop);
                };
                _createClass(ParentComponent, [ {
                    key: "driver",
                    get: function() {
                        if (!this.context) throw new Error("Context not set");
                        return _drivers.RENDER_DRIVERS[this.context];
                    }
                } ]);
                return ParentComponent;
            }(_base.BaseComponent)).prototype, "getOutlet", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "getOutlet"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "prefetch", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "prefetch"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "loadHTML", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "loadHTML"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "buildUrl", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "buildUrl"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "open", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "open"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "openPrerender", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "openPrerender"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "switchPrerender", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "switchPrerender"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "close", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "close"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "closeContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "closeContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "destroyContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "destroyContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "closeComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "closeComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "showContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "showContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "showComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "showComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "hideContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "hideContainer"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "hideComponent", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "hideComponent"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "createPrerenderTemplate", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "createPrerenderTemplate"), _class.prototype), 
            _applyDecoratedDescriptor(_class.prototype, "openContainer", [ _lib.memoized ], Object.getOwnPropertyDescriptor(_class.prototype, "openContainer"), _class.prototype), 
            _class)).activeComponents = [];
        },
        "./src/component/parent/props.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.normalizeProp = normalizeProp;
            exports.normalizeProps = function(component, instance, props) {
                var result = {};
                props = props || {};
                for (var _iterator = Object.keys(props), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var key = _ref;
                    -1 !== component.getPropNames().indexOf(key) ? result[key] = normalizeProp(component, instance, props, key, props[key]) : result[key] = props[key];
                }
                for (var _iterator2 = component.getPropNames(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _key = _ref2;
                    if (!(props.hasOwnProperty(_key) || instance.props && instance.props.hasOwnProperty(_key))) {
                        var normalizedProp = normalizeProp(component, instance, props, _key, props[_key]);
                        void 0 !== normalizedProp && (result[_key] = normalizedProp);
                    }
                }
                return result;
            };
            exports.propsToQuery = function(propsDef, props) {
                var params = {};
                return _src.ZalgoPromise.all(Object.keys(props).map(function(key) {
                    var prop = propsDef[key];
                    if (prop) return _src.ZalgoPromise.resolve().then(function() {
                        var value = props[key];
                        if (value && prop.queryParam) return value;
                    }).then(function(value) {
                        if (value) return _src.ZalgoPromise.all([ function(prop, key, value) {
                            return _src.ZalgoPromise.try(function() {
                                return "function" == typeof prop.queryParam ? prop.queryParam(value) : "string" == typeof prop.queryParam ? prop.queryParam : key;
                            });
                        }(prop, key, value), function(prop, key, value) {
                            return _src.ZalgoPromise.try(function() {
                                return "function" == typeof prop.queryValue ? prop.queryValue(value) : value;
                            });
                        }(prop, 0, value) ]).then(function(_ref3) {
                            var queryParam = _ref3[0], queryValue = _ref3[1], result = void 0;
                            if ("boolean" == typeof queryValue) result = "1"; else if ("string" == typeof queryValue) result = queryValue.toString(); else {
                                if ("function" == typeof queryValue) return;
                                if ("object" === (void 0 === queryValue ? "undefined" : _typeof(queryValue)) && null !== queryValue) {
                                    if ("json" !== prop.serialization) {
                                        result = (0, _lib.dotify)(queryValue, key);
                                        for (var _iterator3 = Object.keys(result), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                                            var _ref4;
                                            if (_isArray3) {
                                                if (_i3 >= _iterator3.length) break;
                                                _ref4 = _iterator3[_i3++];
                                            } else {
                                                if ((_i3 = _iterator3.next()).done) break;
                                                _ref4 = _i3.value;
                                            }
                                            var dotkey = _ref4;
                                            params[dotkey] = result[dotkey];
                                        }
                                        return;
                                    }
                                    result = JSON.stringify(queryValue);
                                } else "number" == typeof queryValue && (result = queryValue.toString());
                            }
                            params[queryParam] = result;
                        });
                    });
                })).then(function() {
                    return params;
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _lib = __webpack_require__("./src/lib/index.js");
            function normalizeProp(component, instance, props, key, value) {
                var prop = component.getProp(key), resultValue = void 0;
                !(resultValue = prop.value ? prop.value : !prop.def || props.hasOwnProperty(key) && function(value) {
                    return null !== value && void 0 !== value && "" !== value;
                }(value) ? value : prop.def.call(component, props)) && prop.alias && props[prop.alias] && (resultValue = props[prop.alias]);
                var decorated = !1;
                if (prop.decorate && null !== resultValue && void 0 !== resultValue) {
                    resultValue = prop.decorate.call(instance, resultValue, props);
                    decorated = !0;
                }
                var type = prop.type;
                if ("boolean" === type) resultValue = Boolean(resultValue); else if ("function" === type) {
                    if (!resultValue && prop.noop) {
                        resultValue = _lib.noop;
                        !decorated && prop.decorate && (resultValue = prop.decorate.call(instance, _lib.noop, props));
                    }
                    if (resultValue && "function" == typeof resultValue) {
                        resultValue = resultValue.bind(instance);
                        prop.denodeify && (resultValue = (0, _lib.denodeify)(resultValue));
                        prop.promisify && (resultValue = (0, _lib.promisify)(resultValue));
                        var original = resultValue;
                        resultValue = function() {
                            component.log("call_prop_" + key);
                            return original.apply(this, arguments);
                        };
                        prop.once && (resultValue = (0, _lib.once)(resultValue));
                        prop.memoize && (resultValue = (0, _lib.memoize)(resultValue));
                    }
                } else "string" === type || "object" === type || "number" === type && void 0 !== resultValue && (resultValue = parseInt(resultValue, 10));
                return resultValue;
            }
        },
        "./src/component/parent/validate.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.validateProp = validateProp;
            exports.validateProps = function(component, props) {
                var required = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                if ((props = props || {}).env && "object" === _typeof(component.url) && !component.url[props.env]) throw new Error("Invalid env: " + props.env);
                for (var _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                    var _ref;
                    if (_isArray) {
                        if (_i >= _iterator.length) break;
                        _ref = _iterator[_i++];
                    } else {
                        if ((_i = _iterator.next()).done) break;
                        _ref = _i.value;
                    }
                    var key = _ref, prop = component.getProp(key);
                    if (prop.alias && props.hasOwnProperty(prop.alias)) {
                        var value = props[prop.alias];
                        delete props[prop.alias];
                        props[key] || (props[key] = value);
                    }
                }
                for (var _iterator2 = Object.keys(props), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var _key = _ref2, _prop = component.getProp(_key), _value = props[_key];
                    _prop && validateProp(_prop, _key, _value, props, required);
                }
                for (var _iterator3 = component.getPropNames(), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                    var _ref3;
                    if (_isArray3) {
                        if (_i3 >= _iterator3.length) break;
                        _ref3 = _iterator3[_i3++];
                    } else {
                        if ((_i3 = _iterator3.next()).done) break;
                        _ref3 = _i3.value;
                    }
                    var _key2 = _ref3, _prop2 = component.getProp(_key2), _value2 = props[_key2];
                    _prop2 && !props.hasOwnProperty(_key2) && validateProp(_prop2, _key2, _value2, props, required);
                }
            };
            function validateProp(prop, key, value, props) {
                var required = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
                if (null !== value && void 0 !== value && "" !== value) {
                    if (!value || "function" != typeof value.then || !prop.promise) {
                        if ("function" === prop.type) {
                            if ("function" != typeof value) throw new TypeError("Prop is not of type function: " + key);
                        } else if ("string" === prop.type) {
                            if ("string" != typeof value) throw new TypeError("Prop is not of type string: " + key);
                        } else if ("object" === prop.type) try {
                            JSON.stringify(value);
                        } catch (err) {
                            throw new Error("Unable to serialize prop: " + key);
                        } else if ("number" === prop.type && isNaN(parseInt(value, 10))) throw new TypeError("Prop is not a number: " + key);
                        "function" == typeof prop.validate && value && prop.validate(value, props);
                    }
                } else if (required && !1 !== prop.required && !prop.hasOwnProperty("def")) throw new Error("Prop is required: " + key);
            }
        },
        "./src/component/window.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.getParentRenderWindow = exports.getParentComponentWindow = exports.getComponentMeta = exports.isZoidComponentWindow = void 0;
            exports.buildChildWindowName = function(name, version) {
                var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                options.id = (0, _lib.uniqueID)();
                options.domain = (0, _src.getDomain)(window);
                var encodedName = normalize(name), encodedVersion = normalize(version), encodedOptions = (str = JSON.stringify(options), 
                _hiBase2.default.encode(str).replace(/\=/g, "").toLowerCase());
                var str;
                if (!encodedName) throw new Error("Invalid name: " + name + " - must contain alphanumeric characters");
                if (!encodedVersion) throw new Error("Invalid version: " + version + " - must contain alphanumeric characters");
                return [ "xcomponent", encodedName, encodedVersion, encodedOptions, "" ].join("__");
            };
            exports.getParentDomain = function() {
                return getComponentMeta().domain;
            };
            exports.getPosition = function(_ref3) {
                var width = _ref3.width, height = _ref3.height, x = 0, y = 0;
                width && (window.outerWidth ? x = Math.round((window.outerWidth - width) / 2) + window.screenX : window.screen.width && (x = Math.round((window.screen.width - width) / 2)));
                height && (window.outerHeight ? y = Math.round((window.outerHeight - height) / 2) + window.screenY : window.screen.height && (y = Math.round((window.screen.height - height) / 2)));
                return {
                    x: x,
                    y: y
                };
            };
            var obj, _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _hiBase = __webpack_require__("./node_modules/hi-base32/src/base32.js"), _hiBase2 = (obj = _hiBase) && obj.__esModule ? obj : {
                default: obj
            }, _lib = __webpack_require__("./src/lib/index.js"), _constants = __webpack_require__("./src/constants.js");
            function normalize(str) {
                return str.replace(/^[^a-z0-9A-Z]+|[^a-z0-9A-Z]+$/g, "").replace(/[^a-z0-9A-Z]+/g, "_");
            }
            exports.isZoidComponentWindow = (0, _lib.memoize)(function() {
                return !!window.name && "xcomponent" === window.name.split("__")[0];
            });
            var getComponentMeta = exports.getComponentMeta = (0, _lib.memoize)(function() {
                if (!window.name) throw new Error("Can not get component meta without window name");
                var _window$name$split2 = window.name.split("__"), zoidcomp = _window$name$split2[0], name = _window$name$split2[1], version = _window$name$split2[2], encodedOptions = _window$name$split2[3];
                if ("xcomponent" !== zoidcomp) throw new Error("Window not rendered by zoid - got " + zoidcomp);
                var str, componentMeta = void 0;
                try {
                    componentMeta = JSON.parse((str = encodedOptions, _hiBase2.default.decode(str.toUpperCase())));
                } catch (err) {
                    throw new Error("Can not decode component-meta: " + encodedOptions + " " + (0, _lib.stringifyError)(err));
                }
                componentMeta.name = name;
                componentMeta.version = version.replace(/_/g, ".");
                return componentMeta;
            });
            function getWindowByRef(_ref) {
                var ref = _ref.ref, uid = _ref.uid, distance = _ref.distance, result = void 0;
                ref === _constants.WINDOW_REFERENCES.OPENER ? result = (0, _src.getOpener)(window) : ref === _constants.WINDOW_REFERENCES.TOP ? result = (0, 
                _src.getTop)(window) : ref === _constants.WINDOW_REFERENCES.PARENT && (result = distance ? (0, 
                _src.getNthParentFromTop)(window, distance) : (0, _src.getParent)(window));
                if (ref === _constants.WINDOW_REFERENCES.GLOBAL) {
                    var ancestor = (0, _src.getAncestor)(window);
                    if (ancestor) {
                        var _iterator = (0, _src.getAllFramesInWindow)(ancestor), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref2;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref2 = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref2 = _i.value;
                            }
                            var frame = _ref2, global = (0, _lib.globalFor)(frame);
                            if (global && global.windows && global.windows[uid]) {
                                result = global.windows[uid];
                                break;
                            }
                        }
                    }
                }
                if (!result) throw new Error("Unable to find window by ref");
                return result;
            }
            exports.getParentComponentWindow = (0, _lib.memoize)(function() {
                var componentMeta = getComponentMeta();
                if (!componentMeta) throw new Error("Can not get parent component window - window not rendered by zoid");
                return getWindowByRef(componentMeta.componentParent);
            }), exports.getParentRenderWindow = (0, _lib.memoize)(function() {
                var componentMeta = getComponentMeta();
                if (!componentMeta) throw new Error("Can not get parent component window - window not rendered by zoid");
                return getWindowByRef(componentMeta.renderParent);
            });
        },
        "./src/constants.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var ZOID = exports.ZOID = "zoid", PROP_TYPES = (exports.__ZOID__ = "__" + ZOID + "__", 
            exports.POST_MESSAGE = {
                INIT: ZOID + "_init",
                PROPS: ZOID + "_props",
                PROP_CALLBACK: ZOID + "_prop_callback",
                CLOSE: ZOID + "_close",
                CHECK_CLOSE: ZOID + "_check_close",
                REDIRECT: ZOID + "_redirect",
                RESIZE: ZOID + "_resize",
                ONRESIZE: ZOID + "_onresize",
                DELEGATE: ZOID + "_delegate",
                ALLOW_DELEGATE: ZOID + "_allow_delegate",
                ERROR: ZOID + "_error",
                HIDE: ZOID + "_hide",
                SHOW: ZOID + "_show"
            }, exports.PROP_TYPES = {
                STRING: "string",
                OBJECT: "object",
                FUNCTION: "function",
                BOOLEAN: "boolean",
                NUMBER: "number"
            }), CONTEXT_TYPES = (exports.INITIAL_PROPS = {
                RAW: "raw",
                UID: "uid"
            }, exports.WINDOW_REFERENCES = {
                OPENER: "opener",
                TOP: "top",
                PARENT: "parent",
                GLOBAL: "global"
            }, exports.PROP_TYPES_LIST = Object.keys(PROP_TYPES).map(function(key) {
                return PROP_TYPES[key];
            }), exports.CONTEXT_TYPES = {
                IFRAME: "iframe",
                POPUP: "popup"
            });
            exports.CLASS_NAMES = {
                ZOID: "" + ZOID,
                OUTLET: ZOID + "-outlet",
                COMPONENT_FRAME: ZOID + "-component-frame",
                PRERENDER_FRAME: ZOID + "-prerender-frame",
                VISIBLE: ZOID + "-visible",
                INVISIBLE: ZOID + "-invisible"
            }, exports.EVENTS = {
                CLOSE: ZOID + "-close"
            }, exports.ATTRIBUTES = {
                IFRAME_PLACEHOLDER: "data-zoid-" + ZOID + "-placeholder"
            }, exports.ANIMATION_NAMES = {
                SHOW_CONTAINER: ZOID + "-show-container",
                SHOW_COMPONENT: ZOID + "-show-component",
                HIDE_CONTAINER: ZOID + "-hide-container",
                HIDE_COMPONENT: ZOID + "-hide-component"
            }, exports.EVENT_NAMES = {
                CLICK: "click"
            }, exports.CLOSE_REASONS = {
                PARENT_CALL: "parent_call",
                CHILD_CALL: "child_call",
                CLOSE_DETECTED: "close_detected",
                USER_CLOSED: "user_closed",
                PARENT_CLOSE_DETECTED: "parent_close_detected"
            }, exports.CONTEXT_TYPES_LIST = Object.keys(CONTEXT_TYPES).map(function(key) {
                return CONTEXT_TYPES[key];
            }), exports.DELEGATE = {
                CALL_ORIGINAL: "call_original",
                CALL_DELEGATE: "call_delegate"
            }, exports.WILDCARD = "*", exports.DEFAULT_DIMENSIONS = {
                WIDTH: 300,
                HEIGHT: 150
            };
        },
        "./src/drivers/angular.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.angular = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.angular = {
                global: function() {
                    return window.angular;
                },
                register: function(component, ng) {
                    return ng.module(component.tag, []).directive((0, _lib.dasherizeToCamel)(component.tag), function() {
                        var scope = {}, _iterator = component.getPropNames(), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            scope[_ref] = "=";
                        }
                        component.looseProps && (scope.props = "=");
                        return {
                            scope: scope,
                            restrict: "E",
                            controller: [ "$scope", "$element", function($scope, $element) {
                                if (component.looseProps && !$scope.props) throw new Error("For angular bindings to work, prop definitions must be passed to zoid.create");
                                component.log("instantiate_angular_component");
                                var getProps = function() {
                                    var scopeProps = void 0;
                                    if ($scope.props) scopeProps = $scope.props; else {
                                        scopeProps = {};
                                        var _iterator2 = Object.keys(scope), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                                        for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                                            var _ref2;
                                            if (_isArray2) {
                                                if (_i2 >= _iterator2.length) break;
                                                _ref2 = _iterator2[_i2++];
                                            } else {
                                                if ((_i2 = _iterator2.next()).done) break;
                                                _ref2 = _i2.value;
                                            }
                                            var key = _ref2;
                                            void 0 !== $scope[key] && (scopeProps[key] = $scope[key]);
                                        }
                                    }
                                    return scopeProps = (0, _lib.replaceObject)(scopeProps, {
                                        function: function(value) {
                                            return function() {
                                                var result = value.apply(this, arguments);
                                                !function() {
                                                    if ("$apply" !== $scope.$root.$$phase && "$digest" !== $scope.$root.$$phase) try {
                                                        $scope.$apply();
                                                    } catch (err) {}
                                                }();
                                                return result;
                                            };
                                        }
                                    });
                                }, parent = component.init(getProps(), null, $element[0]);
                                parent.render($element[0]);
                                $scope.$watch(function() {
                                    parent.updateProps(getProps());
                                });
                            } ]
                        };
                    });
                }
            };
        },
        "./src/drivers/angular2.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.angular2 = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _lib = __webpack_require__("./src/lib/index.js");
            exports.angular2 = {
                global: function() {},
                register: function(zoid, _ref) {
                    var AngularComponent = _ref.Component, NgModule = _ref.NgModule, ElementRef = _ref.ElementRef, NgZone = _ref.NgZone;
                    zoid.log("initializing angular2 component");
                    var getProps = function(component) {
                        return (0, _lib.replaceObject)(_extends({}, component.internalProps, component.props), {
                            function: function(value) {
                                if ("function" == typeof value) return function() {
                                    var _this = this, _arguments = arguments;
                                    return component.zone.run(function() {
                                        return value.apply(_this, _arguments);
                                    });
                                };
                            }
                        });
                    }, ComponentInstance = AngularComponent({
                        selector: zoid.tag,
                        template: "<div></div>",
                        inputs: [ "props" ]
                    }).Class({
                        constructor: [ ElementRef, NgZone, function(elementRef, zone) {
                            this.elementRef = elementRef;
                            this.zone = zone;
                        } ],
                        ngOnInit: function() {
                            var targetElement = this.elementRef.nativeElement, parent = zoid.init(getProps(this), null, targetElement);
                            parent.render(targetElement);
                            this.parent = parent;
                        },
                        ngOnChanges: function() {
                            this.parent && this.parent.updateProps(getProps(this));
                        }
                    });
                    return NgModule({
                        declarations: [ ComponentInstance ],
                        exports: [ ComponentInstance ]
                    }).Class({
                        constructor: function() {}
                    });
                }
            };
        },
        "./src/drivers/ember.js": function(module, exports, __webpack_require__) {
            "use strict";
        },
        "./src/drivers/glimmer.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            };
            exports.glimmer = {
                global: function() {},
                register: function(component, GlimmerComponent) {
                    return function(_GlimmerComponent) {
                        !function(subClass, superClass) {
                            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            });
                            superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                        }(_class, _GlimmerComponent);
                        function _class() {
                            !function(instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                            }(this, _class);
                            return function(self, call) {
                                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !call || "object" != typeof call && "function" != typeof call ? self : call;
                            }(this, _GlimmerComponent.apply(this, arguments));
                        }
                        _class.prototype.didInsertElement = function() {
                            component.render(_extends({}, this.args), this.element);
                        };
                        return _class;
                    }(GlimmerComponent);
                }
            };
        },
        "./src/drivers/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _script = __webpack_require__("./src/drivers/script.js");
            Object.keys(_script).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _script[key];
                    }
                });
            });
            var _react = __webpack_require__("./src/drivers/react.js");
            Object.keys(_react).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _react[key];
                    }
                });
            });
            var _vue = __webpack_require__("./src/drivers/vue.js");
            Object.keys(_vue).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _vue[key];
                    }
                });
            });
            var _angular = __webpack_require__("./src/drivers/angular.js");
            Object.keys(_angular).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _angular[key];
                    }
                });
            });
            var _ember = __webpack_require__("./src/drivers/ember.js");
            Object.keys(_ember).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _ember[key];
                    }
                });
            });
            var _glimmer = __webpack_require__("./src/drivers/glimmer.js");
            Object.keys(_glimmer).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _glimmer[key];
                    }
                });
            });
            var _angular2 = __webpack_require__("./src/drivers/angular2.js");
            Object.keys(_angular2).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _angular2[key];
                    }
                });
            });
        },
        "./src/drivers/react.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.react = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.react = {
                global: function() {
                    if (window.React && window.ReactDOM) return {
                        React: window.React,
                        ReactDOM: window.ReactDOM
                    };
                },
                register: function(component, _ref) {
                    var React = _ref.React, ReactDOM = _ref.ReactDOM;
                    React.createClass ? component.react = React.createClass({
                        render: function() {
                            return React.createElement("div", null);
                        },
                        componentDidMount: function() {
                            component.log("instantiate_react_component");
                            var el = ReactDOM.findDOMNode(this), parent = component.init((0, _lib.extend)({}, this.props), null, el);
                            this.setState({
                                parent: parent
                            });
                            parent.render(el);
                        },
                        componentDidUpdate: function() {
                            this.state && this.state.parent && this.state.parent.updateProps((0, _lib.extend)({}, this.props));
                        }
                    }) : component.react = function(_React$Component) {
                        !function(subClass, superClass) {
                            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                            subClass.prototype = Object.create(superClass && superClass.prototype, {
                                constructor: {
                                    value: subClass,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            });
                            superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
                        }(_class, _React$Component);
                        function _class() {
                            !function(instance, Constructor) {
                                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                            }(this, _class);
                            return function(self, call) {
                                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !call || "object" != typeof call && "function" != typeof call ? self : call;
                            }(this, _React$Component.apply(this, arguments));
                        }
                        _class.prototype.render = function() {
                            return React.createElement("div", null);
                        };
                        _class.prototype.componentDidMount = function() {
                            component.log("instantiate_react_component");
                            var el = ReactDOM.findDOMNode(this), parent = component.init((0, _lib.extend)({}, this.props), null, el);
                            this.setState({
                                parent: parent
                            });
                            parent.render(el);
                        };
                        _class.prototype.componentDidUpdate = function() {
                            this.state && this.state.parent && this.state.parent.updateProps((0, _lib.extend)({}, this.props));
                        };
                        return _class;
                    }(React.Component);
                    return component.react;
                }
            };
        },
        "./src/drivers/script.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var script = exports.script = {
                global: function() {
                    return window.document;
                },
                register: function register(component, document) {
                    function render(element) {
                        if (element && element.tagName && "script" === element.tagName.toLowerCase() && element.attributes.type && "application/x-component" === element.attributes.type.value && element.parentNode) {
                            var tag = element.getAttribute("data-component");
                            if (tag && tag === component.tag) {
                                component.log("instantiate_script_component");
                                var props = element.innerText ? eval("(" + element.innerText + ")") : {}, container = document.createElement("div");
                                if (!element.parentNode) throw new Error("Element has no parent");
                                element.parentNode.replaceChild(container, element);
                                component.render(props, container);
                            }
                        }
                    }
                    function scan() {
                        var _iterator = Array.prototype.slice.call(document.getElementsByTagName("script")), _isArray = Array.isArray(_iterator), _i = 0;
                        for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i >= _iterator.length) break;
                                _ref = _iterator[_i++];
                            } else {
                                if ((_i = _iterator.next()).done) break;
                                _ref = _i.value;
                            }
                            render(_ref);
                        }
                    }
                    scan();
                    document.addEventListener("DOMContentLoaded", scan);
                    window.addEventListener("load", scan);
                    document.addEventListener("DOMNodeInserted", function(event) {
                        render(event.target);
                    });
                }
            };
        },
        "./src/drivers/vue.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.vue = void 0;
            var _lib = __webpack_require__("./src/lib/index.js");
            exports.vue = {
                global: function() {},
                register: function(component) {
                    return {
                        render: function(createElement) {
                            return createElement("div");
                        },
                        inheritAttrs: !1,
                        mounted: function() {
                            var el = this.$el;
                            this.parent = component.init((0, _lib.extend)({}, this.$attrs), null, el);
                            this.parent.render(el);
                        },
                        beforeUpdate: function() {
                            this.parent && this.$attrs && this.parent.updateProps((0, _lib.extend)({}, this.$attrs));
                        }
                    };
                }
            };
        },
        "./src/error.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.PopupOpenError = PopupOpenError;
            exports.IntegrationError = IntegrationError;
            exports.RenderError = RenderError;
            function PopupOpenError(message) {
                this.message = message;
            }
            PopupOpenError.prototype = Object.create(Error.prototype);
            function IntegrationError(message) {
                this.message = message;
            }
            IntegrationError.prototype = Object.create(Error.prototype);
            function RenderError(message) {
                this.message = message;
            }
            RenderError.prototype = Object.create(Error.prototype);
        },
        "./src/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _interface = __webpack_require__("./src/interface.js");
            Object.keys(_interface).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _interface[key];
                    }
                });
            });
            var INTERFACE = function(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }(_interface);
            exports.default = INTERFACE;
        },
        "./src/interface.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.CONSTANTS = exports.postRobot = exports.getCurrentScriptDir = void 0;
            exports.create = function(options) {
                return new _component.Component(options);
            };
            exports.getByTag = function(tag) {
                return _component.Component.getByTag(tag);
            };
            var _lib = __webpack_require__("./src/lib/index.js");
            Object.defineProperty(exports, "getCurrentScriptDir", {
                enumerable: !0,
                get: function() {
                    return _lib.getCurrentScriptDir;
                }
            });
            exports.destroyAll = function() {
                return _parent.ParentComponent.destroyAll();
            };
            var _error = __webpack_require__("./src/error.js");
            Object.keys(_error).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _error[key];
                    }
                });
            });
            __webpack_require__("./node_modules/zalgo-promise/src/index.js");
            var _postRobot = _interopRequireWildcard(__webpack_require__("./node_modules/post-robot/src/index.js")), _component = __webpack_require__("./src/component/index.js"), _parent = __webpack_require__("./src/component/parent/index.js"), _CONSTANTS = _interopRequireWildcard(__webpack_require__("./src/constants.js"));
            function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj) for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
                newObj.default = obj;
                return newObj;
            }
            exports.postRobot = _postRobot, exports.CONSTANTS = _CONSTANTS;
        },
        "./src/lib/css.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.isPerc = isPerc;
            exports.isPx = isPx;
            exports.toNum = toNum;
            exports.toPx = toPx;
            exports.toCSS = function(val) {
                if ("number" == typeof val) return toPx(val);
                return isPerc(val) ? val : toPx(val);
            };
            exports.percOf = percOf;
            exports.normalizeDimension = function(dim, max) {
                if ("number" == typeof dim) return dim;
                if (isPerc(dim)) return percOf(max, dim);
                if (isPx(dim)) return toNum(dim);
                throw new Error("Can not normalize dimension: " + dim);
            };
            function isPerc(str) {
                return "string" == typeof str && /^[0-9]+%$/.test(str);
            }
            function isPx(str) {
                return "string" == typeof str && /^[0-9]+px$/.test(str);
            }
            function toNum(val) {
                if ("number" == typeof val) return val;
                var match = val.match(/^([0-9]+)(px|%)$/);
                if (!match) throw new Error("Could not match css value from " + val);
                return parseInt(match[1], 10);
            }
            function toPx(val) {
                return toNum(val) + "px";
            }
            function percOf(num, perc) {
                return parseInt(num * toNum(perc) / 100, 10);
            }
        },
        "./src/lib/decorators.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.memoized = function(target, name, descriptor) {
                var method = descriptor.value;
                descriptor.value = function() {
                    this.__memoized__ = this.__memoized__ || {};
                    this.__memoized__.hasOwnProperty(name) || (this.__memoized__[name] = method.apply(this, arguments));
                    return this.__memoized__[name];
                };
                descriptor.value.displayName = name + ":memoized";
            };
            exports.promise = function(target, name, descriptor) {
                var method = descriptor.value;
                descriptor.value = function() {
                    return _src.ZalgoPromise.try(method, this, arguments);
                };
                descriptor.value.displayName = name + ":promisified";
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
        },
        "./src/lib/dom.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.parseQuery = exports.documentReady = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.appendChild = appendChild;
            exports.querySelectorAll = querySelectorAll;
            exports.getElementSafe = getElementSafe;
            exports.getElement = getElement;
            exports.isDocumentReady = isDocumentReady;
            exports.elementReady = function(id) {
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var name = (0, _util.stringify)(id), el = getElementSafe(id);
                    if (el) return resolve(el);
                    if (isDocumentReady()) return reject(new Error("Document is ready and element " + name + " does not exist"));
                    var interval = setInterval(function() {
                        if (el = getElementSafe(id)) {
                            clearInterval(interval);
                            return resolve(el);
                        }
                        if (isDocumentReady()) {
                            clearInterval(interval);
                            return reject(new Error("Document is ready and element " + name + " does not exist"));
                        }
                    }, 10);
                });
            };
            exports.popup = function(url, options) {
                var params = Object.keys(options).map(function(key) {
                    if (options[key]) return key + "=" + (0, _util.stringify)(options[key]);
                }).filter(Boolean).join(","), win = void 0;
                try {
                    win = window.open(url, options.name, params, !0);
                } catch (err) {
                    throw new _error.PopupOpenError("Can not open popup window - " + (err.stack || err.message));
                }
                if ((0, _src.isWindowClosed)(win)) {
                    var err = new _error.PopupOpenError("Can not open popup window - blocked");
                    throw err;
                }
                return win;
            };
            exports.writeToWindow = writeToWindow;
            exports.writeElementToWindow = writeElementToWindow;
            exports.setStyle = setStyle;
            exports.createElement = createElement;
            exports.awaitFrameLoad = awaitFrameLoad;
            exports.awaitFrameWindow = function(frame) {
                if (frame.contentWindow) return _src2.ZalgoPromise.resolve(frame.contentWindow);
                return awaitFrameLoad(frame).then(function(loadedFrame) {
                    if (!loadedFrame.contentWindow) throw new Error("Could not find window in iframe");
                    return loadedFrame.contentWindow;
                });
            };
            exports.iframe = function() {
                var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, el = getElement(arguments[1]), attributes = options.attributes || {}, style = options.style || {}, frame = createElement("iframe", {
                    attributes: _extends({
                        frameBorder: "0",
                        allowTransparency: "true"
                    }, attributes),
                    style: _extends({
                        backgroundColor: "transparent"
                    }, style),
                    html: options.html,
                    class: options.class
                });
                awaitFrameLoad(frame);
                el.appendChild(frame);
                (options.url || window.navigator.userAgent.match(/MSIE|Edge/i)) && frame.setAttribute("src", options.url || "about:blank");
                return frame;
            };
            exports.addEventListener = function(obj, event, handler) {
                obj.addEventListener(event, handler);
                return {
                    cancel: function() {
                        obj.removeEventListener(event, handler);
                    }
                };
            };
            exports.scanForJavascript = function(str) {
                if (!str) return str;
                if (str.match(/<script|on\w+\s*=|javascript:|expression\s*\(|eval\(|new\s*Function/)) throw new Error("HTML contains potential javascript: " + str);
                return str;
            };
            exports.getQueryParam = function(name) {
                return parseQuery(window.location.search.slice(1))[name];
            };
            exports.formatQuery = formatQuery;
            exports.extendQuery = extendQuery;
            exports.extendUrl = function(url) {
                var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, query = options.query || {}, hash = options.hash || {}, originalUrl = void 0, originalHash = void 0, _url$split = url.split("#");
                originalUrl = _url$split[0];
                originalHash = _url$split[1];
                var _originalUrl$split = originalUrl.split("?");
                originalUrl = _originalUrl$split[0];
                var queryString = extendQuery(_originalUrl$split[1], query), hashString = extendQuery(originalHash, hash);
                queryString && (originalUrl = originalUrl + "?" + queryString);
                hashString && (originalUrl = originalUrl + "#" + hashString);
                return originalUrl;
            };
            exports.elementStoppedMoving = function(element) {
                var timeout = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var el = getElement(element), start = el.getBoundingClientRect(), interval = void 0, timer = void 0;
                    interval = setInterval(function() {
                        var end = el.getBoundingClientRect();
                        if (start.top === end.top && start.bottom === end.bottom && start.left === end.left && start.right === end.right && start.width === end.width && start.height === end.height) {
                            clearTimeout(timer);
                            clearInterval(interval);
                            return resolve();
                        }
                        start = end;
                    }, 50);
                    timer = setTimeout(function() {
                        clearInterval(interval);
                        reject(new Error("Timed out waiting for element to stop animating after " + timeout + "ms"));
                    }, timeout);
                });
            };
            exports.getCurrentDimensions = getCurrentDimensions;
            exports.changeStyle = function(el, styles) {
                return new _src2.ZalgoPromise(function(resolve) {
                    for (var _iterator3 = Object.keys(styles), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ;) {
                        var _ref3;
                        if (_isArray3) {
                            if (_i3 >= _iterator3.length) break;
                            _ref3 = _iterator3[_i3++];
                        } else {
                            if ((_i3 = _iterator3.next()).done) break;
                            _ref3 = _i3.value;
                        }
                        var key = _ref3;
                        el.style[key] = styles[key];
                    }
                    setTimeout(resolve, 1);
                });
            };
            exports.setOverflow = function(el) {
                var value = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "auto", _el$style = el.style, overflow = _el$style.overflow, overflowX = _el$style.overflowX, overflowY = _el$style.overflowY;
                el.style.overflow = el.style.overflowX = el.style.overflowY = value;
                return {
                    reset: function() {
                        el.style.overflow = overflow;
                        el.style.overflowX = overflowX;
                        el.style.overflowY = overflowY;
                    }
                };
            };
            exports.trackDimensions = trackDimensions;
            exports.onDimensionsChange = function(el, _ref6) {
                var _ref6$width = _ref6.width, width = void 0 === _ref6$width || _ref6$width, _ref6$height = _ref6.height, height = void 0 === _ref6$height || _ref6$height, _ref6$delay = _ref6.delay, delay = void 0 === _ref6$delay ? 50 : _ref6$delay, _ref6$threshold = _ref6.threshold, threshold = void 0 === _ref6$threshold ? 0 : _ref6$threshold;
                return new _src2.ZalgoPromise(function(resolve) {
                    var tracker = trackDimensions(el, {
                        width: width,
                        height: height,
                        threshold: threshold
                    }), interval = void 0, resolver = (0, _fn.debounce)(function(dimensions) {
                        clearInterval(interval);
                        return resolve(dimensions);
                    }, 4 * delay);
                    interval = setInterval(function() {
                        var _tracker$check = tracker.check(), changed = _tracker$check.changed, dimensions = _tracker$check.dimensions;
                        if (changed) {
                            tracker.reset();
                            return resolver(dimensions);
                        }
                    }, delay);
                    window.addEventListener("resize", function onWindowResize() {
                        var _tracker$check2 = tracker.check(), changed = _tracker$check2.changed, dimensions = _tracker$check2.dimensions;
                        if (changed) {
                            tracker.reset();
                            window.removeEventListener("resize", onWindowResize);
                            resolver(dimensions);
                        }
                    });
                });
            };
            exports.dimensionsMatchViewport = function(el, _ref7) {
                var width = _ref7.width, height = _ref7.height, dimensions = getCurrentDimensions(el);
                if (width && dimensions.width !== window.innerWidth) return !1;
                if (height && dimensions.height !== window.innerHeight) return !1;
                return !0;
            };
            exports.bindEvents = bindEvents;
            exports.setVendorCSS = setVendorCSS;
            exports.animate = animate;
            exports.makeElementVisible = function(element) {
                element.style.setProperty("visibility", "");
            };
            exports.makeElementInvisible = function(element) {
                element.style.setProperty("visibility", STYLE.VISIBILITY.HIDDEN, STYLE.IMPORTANT);
            };
            exports.showElement = showElement;
            exports.hideElement = hideElement;
            exports.destroyElement = function(element) {
                element.parentNode && element.parentNode.removeChild(element);
            };
            exports.showAndAnimate = function(element, name, clean) {
                var animation = animate(element, name, clean);
                showElement(element);
                return animation;
            };
            exports.animateAndHide = function(element, name, clean) {
                return animate(element, name, clean).then(function() {
                    hideElement(element);
                });
            };
            exports.addClass = function(element, name) {
                element.classList ? element.classList.add(name) : -1 === element.className.split(/\s+/).indexOf(name) && (element.className += " " + name);
            };
            exports.removeClass = function(element, name) {
                element.classList ? element.classList.remove(name) : -1 !== element.className.split(/\s+/).indexOf(name) && (element.className = element.className.replace(name, ""));
            };
            exports.getCurrentScriptDir = function() {
                console.warn("Do not use zoid.getCurrentScriptDir() in production -- browser support is limited");
                if (document.currentScript) return document.currentScript.src.split("/").slice(0, -1).join("/");
                return ".";
            };
            exports.getElementName = function(element) {
                if ("string" == typeof element) return element;
                if (!element || !element.tagName) return "<unknown>";
                var name = element.tagName.toLowerCase();
                element.id ? name += "#" + element.id : element.className && (name += "." + element.className.split(" ").join("."));
                return name;
            };
            exports.isElementClosed = isElementClosed;
            exports.watchElementForClose = function(element, handler) {
                handler = (0, _fn.once)(handler);
                var interval = void 0;
                isElementClosed(element) ? handler() : interval = (0, _util.safeInterval)(function() {
                    if (isElementClosed(element)) {
                        interval.cancel();
                        handler();
                    }
                }, 50);
                return {
                    cancel: function() {
                        interval && interval.cancel();
                    }
                };
            };
            exports.getHttpType = getHttpType;
            exports.getHTML = getHTML;
            exports.getCSS = function(url) {
                return getHttpType("text/css", url);
            };
            exports.getScript = function(url) {
                return getHttpType("*/*", url);
            };
            exports.prefetchPage = function(url) {
                return getHTML(url);
            };
            exports.fixScripts = fixScripts;
            exports.jsxDom = function(name, props, content) {
                name = name.toLowerCase();
                var doc = this && this.createElement ? this : window.document, el = doc.createElement(name);
                for (var prop in props) if (prop in JSX_EVENTS) el.addEventListener(JSX_EVENTS[prop], props[prop]); else if ("innerHTML" === prop) {
                    el.innerHTML = props[prop];
                    fixScripts(el, doc);
                } else el.setAttribute(prop, props[prop]);
                if ("style" === name) {
                    if ("string" != typeof content) throw new TypeError("Expected " + name + " tag content to be string, got " + (void 0 === content ? "undefined" : _typeof(content)));
                    if (arguments.length > 3) throw new Error("Expected only text content for " + name + " tag");
                    setStyle(el, content, doc);
                } else if ("iframe" === name) {
                    if (arguments.length > 3) throw new Error("Expected only single child node for iframe");
                    el.addEventListener("load", function() {
                        var win = el.contentWindow;
                        if (!win) throw new Error("Expected frame to have contentWindow");
                        "string" == typeof content ? writeToWindow(win, content) : writeElementToWindow(win, content);
                    });
                } else if ("script" === name) {
                    if ("string" != typeof content) throw new TypeError("Expected " + name + " tag content to be string, got " + (void 0 === content ? "undefined" : _typeof(content)));
                    if (arguments.length > 3) throw new Error("Expected only text content for " + name + " tag");
                    el.text = content;
                } else for (var i = 2; i < arguments.length; i++) if ("string" == typeof arguments[i]) {
                    var textNode = document.createTextNode(arguments[i]);
                    appendChild(el, textNode);
                } else appendChild(el, arguments[i]);
                return el;
            };
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _src2 = __webpack_require__("./node_modules/zalgo-promise/src/index.js"), _src3 = __webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js"), _error = __webpack_require__("./src/error.js"), _fn = __webpack_require__("./src/lib/fn.js"), _util = __webpack_require__("./src/lib/util.js");
            function appendChild(container, child) {
                container.appendChild(child);
            }
            function querySelectorAll(el, selector) {
                return Array.prototype.slice.call(el.querySelectorAll(selector));
            }
            function getElementSafe(id) {
                if (function(element) {
                    return element instanceof window.Element || null !== element && "object" === (void 0 === element ? "undefined" : _typeof(element)) && 1 === element.nodeType && "object" === _typeof(element.style) && "object" === _typeof(element.ownerDocument);
                }(id)) return id;
                if ("string" == typeof id) {
                    var element = document.getElementById(id);
                    if (element) return element;
                    document.querySelector && (element = document.querySelector(id));
                    if (element) return element;
                }
            }
            function getElement(id) {
                var element = getElementSafe(id);
                if (element) return element;
                throw new Error("Can not find element: " + (0, _util.stringify)(id));
            }
            exports.documentReady = new _src2.ZalgoPromise(function(resolve) {
                if ("complete" === window.document.readyState) return resolve(window.document);
                var interval = setInterval(function() {
                    if ("complete" === window.document.readyState) {
                        clearInterval(interval);
                        return resolve(window.document);
                    }
                }, 10);
            });
            function isDocumentReady() {
                return "complete" === window.document.readyState;
            }
            function writeToWindow(win, html) {
                try {
                    win.document.open();
                    win.document.write(html);
                    win.document.close();
                } catch (err) {
                    try {
                        win.location = "javascript: document.open(); document.write(" + JSON.stringify(html) + "); document.close();";
                    } catch (err2) {}
                }
            }
            function writeElementToWindow(win, el) {
                var tag = el.tagName.toLowerCase();
                if ("html" !== tag) throw new Error("Expected element to be html, got " + tag);
                for (var documentElement = win.document.documentElement; documentElement.children && documentElement.children.length; ) documentElement.removeChild(documentElement.children[0]);
                for (;el.children.length; ) documentElement.appendChild(el.children[0]);
            }
            function setStyle(el, styleText) {
                var doc = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : window.document;
                el.styleSheet ? el.styleSheet.cssText = styleText : el.appendChild(doc.createTextNode(styleText));
            }
            function createElement() {
                var tag = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div", options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, container = arguments[2];
                tag = tag.toLowerCase();
                var element = document.createElement(tag);
                options.style && (0, _util.extend)(element.style, options.style);
                options.class && (element.className = options.class.join(" "));
                if (options.attributes) {
                    var _iterator = Object.keys(options.attributes), _isArray = Array.isArray(_iterator), _i = 0;
                    for (_iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                        var _ref;
                        if (_isArray) {
                            if (_i >= _iterator.length) break;
                            _ref = _iterator[_i++];
                        } else {
                            if ((_i = _iterator.next()).done) break;
                            _ref = _i.value;
                        }
                        var key = _ref;
                        element.setAttribute(key, options.attributes[key]);
                    }
                }
                options.styleSheet && setStyle(element, options.styleSheet);
                container && appendChild(container, element);
                if (options.html) if ("iframe" === tag) {
                    if (!container || !element.contentWindow) throw new Error("Iframe html can not be written unless container provided and iframe in DOM");
                    writeToWindow(element.contentWindow, options.html);
                } else element.innerHTML = options.html;
                return element;
            }
            var awaitFrameLoadPromises = new _src3.WeakMap();
            function awaitFrameLoad(frame) {
                if (awaitFrameLoadPromises.has(frame)) {
                    var _promise = awaitFrameLoadPromises.get(frame);
                    if (_promise) return _promise;
                }
                var promise = new _src2.ZalgoPromise(function(resolve, reject) {
                    frame.addEventListener("load", function() {
                        (0, _src.linkFrameWindow)(frame);
                        resolve(frame);
                    });
                    frame.addEventListener("error", function(err) {
                        frame.contentWindow ? resolve(frame) : reject(err);
                    });
                });
                awaitFrameLoadPromises.set(frame, promise);
                return promise;
            }
            var parseQuery = exports.parseQuery = (0, _fn.memoize)(function(queryString) {
                var params = {};
                if (!queryString) return params;
                if (-1 === queryString.indexOf("=")) throw new Error("Can not parse query string params: " + queryString);
                var _iterator2 = queryString.split("&"), _isArray2 = Array.isArray(_iterator2), _i2 = 0;
                for (_iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ;) {
                    var _ref2;
                    if (_isArray2) {
                        if (_i2 >= _iterator2.length) break;
                        _ref2 = _iterator2[_i2++];
                    } else {
                        if ((_i2 = _iterator2.next()).done) break;
                        _ref2 = _i2.value;
                    }
                    var pair = _ref2;
                    (pair = pair.split("="))[0] && pair[1] && (params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]));
                }
                return params;
            });
            function formatQuery() {
                var obj = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return Object.keys(obj).filter(function(key) {
                    return "string" == typeof obj[key];
                }).map(function(key) {
                    return (0, _util.urlEncode)(key) + "=" + (0, _util.urlEncode)(obj[key]);
                }).join("&");
            }
            function extendQuery(originalQuery) {
                var props = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return props && Object.keys(props).length ? formatQuery(_extends({}, parseQuery(originalQuery), props)) : originalQuery;
            }
            function getCurrentDimensions(el) {
                return {
                    width: el.offsetWidth,
                    height: el.offsetHeight
                };
            }
            function trackDimensions(el, _ref5) {
                var _ref5$width = _ref5.width, width = void 0 === _ref5$width || _ref5$width, _ref5$height = _ref5.height, height = void 0 === _ref5$height || _ref5$height, _ref5$threshold = _ref5.threshold, threshold = void 0 === _ref5$threshold ? 0 : _ref5$threshold, currentDimensions = getCurrentDimensions(el);
                return {
                    check: function() {
                        var newDimensions = getCurrentDimensions(el);
                        return {
                            changed: function(one, two, _ref4) {
                                var _ref4$width = _ref4.width, width = void 0 === _ref4$width || _ref4$width, _ref4$height = _ref4.height, height = void 0 === _ref4$height || _ref4$height, _ref4$threshold = _ref4.threshold, threshold = void 0 === _ref4$threshold ? 0 : _ref4$threshold;
                                return !!(width && Math.abs(one.width - two.width) > threshold) || !!(height && Math.abs(one.height - two.height) > threshold);
                            }(currentDimensions, newDimensions, {
                                width: width,
                                height: height,
                                threshold: threshold
                            }),
                            dimensions: newDimensions
                        };
                    },
                    reset: function() {
                        currentDimensions = getCurrentDimensions(el);
                    }
                };
            }
            function bindEvents(element, eventNames, handler) {
                handler = (0, _fn.once)(handler);
                var _iterator4 = eventNames, _isArray4 = Array.isArray(_iterator4), _i4 = 0;
                for (_iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator](); ;) {
                    var _ref8;
                    if (_isArray4) {
                        if (_i4 >= _iterator4.length) break;
                        _ref8 = _iterator4[_i4++];
                    } else {
                        if ((_i4 = _iterator4.next()).done) break;
                        _ref8 = _i4.value;
                    }
                    var eventName = _ref8;
                    element.addEventListener(eventName, handler);
                }
                return {
                    cancel: (0, _fn.once)(function() {
                        var _iterator5 = eventNames, _isArray5 = Array.isArray(_iterator5), _i5 = 0;
                        for (_iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator](); ;) {
                            var _ref9;
                            if (_isArray5) {
                                if (_i5 >= _iterator5.length) break;
                                _ref9 = _iterator5[_i5++];
                            } else {
                                if ((_i5 = _iterator5.next()).done) break;
                                _ref9 = _i5.value;
                            }
                            var eventName = _ref9;
                            element.removeEventListener(eventName, handler);
                        }
                    })
                };
            }
            var VENDOR_PREFIXES = [ "webkit", "moz", "ms", "o" ];
            function setVendorCSS(element, name, value) {
                element.style[name] = value;
                var capitalizedName = (0, _util.capitalizeFirstLetter)(name), _iterator6 = VENDOR_PREFIXES, _isArray6 = Array.isArray(_iterator6), _i6 = 0;
                for (_iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator](); ;) {
                    var _ref10;
                    if (_isArray6) {
                        if (_i6 >= _iterator6.length) break;
                        _ref10 = _iterator6[_i6++];
                    } else {
                        if ((_i6 = _iterator6.next()).done) break;
                        _ref10 = _i6.value;
                    }
                    var prefix = _ref10;
                    element.style["" + prefix + capitalizedName] = value;
                }
            }
            var CSSRule = window.CSSRule, KEYFRAMES_RULE = CSSRule.KEYFRAMES_RULE || CSSRule.WEBKIT_KEYFRAMES_RULE || CSSRule.MOZ_KEYFRAMES_RULE || CSSRule.O_KEYFRAMES_RULE || CSSRule.MS_KEYFRAMES_RULE;
            var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart", "oAnimationStart", "MSAnimationStart" ], ANIMATION_END_EVENTS = [ "animationend", "webkitAnimationEnd", "oAnimationEnd", "MSAnimationEnd" ];
            function animate(element, name, clean) {
                var timeout = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var el = getElement(element);
                    if (!el || !function(element, name) {
                        var stylesheets = element.ownerDocument.styleSheets;
                        try {
                            for (var i = 0; i < stylesheets.length; i++) {
                                var cssRules = stylesheets[i].cssRules;
                                if (cssRules) for (var j = 0; j < cssRules.length; j++) {
                                    var cssRule = cssRules[j];
                                    if (cssRule && cssRule.type === KEYFRAMES_RULE && cssRule.name === name) return !0;
                                }
                            }
                        } catch (err) {
                            return !1;
                        }
                        return !1;
                    }(el, name)) return resolve();
                    var hasStarted = !1, startTimeout = void 0, endTimeout = void 0, startEvent = void 0, endEvent = void 0;
                    function cleanUp() {
                        setVendorCSS(el, "animationName", "");
                        clearTimeout(startTimeout);
                        clearTimeout(endTimeout);
                        startEvent.cancel();
                        endEvent.cancel();
                    }
                    startEvent = bindEvents(el, ANIMATION_START_EVENTS, function(event) {
                        if (event.target === el && event.animationName === name) {
                            clearTimeout(startTimeout);
                            event.stopPropagation();
                            startEvent.cancel();
                            hasStarted = !0;
                            endTimeout = setTimeout(function() {
                                cleanUp();
                                resolve();
                            }, timeout);
                        }
                    });
                    endEvent = bindEvents(el, ANIMATION_END_EVENTS, function(event) {
                        if (event.target === el && event.animationName === name) {
                            cleanUp();
                            return "string" == typeof event.animationName && event.animationName !== name ? reject("Expected animation name to be " + name + ", found " + event.animationName) : resolve();
                        }
                    });
                    setVendorCSS(el, "animationName", name);
                    startTimeout = setTimeout(function() {
                        if (!hasStarted) {
                            cleanUp();
                            return resolve();
                        }
                    }, 200);
                    clean && clean(cleanUp);
                });
            }
            var STYLE = {
                DISPLAY: {
                    NONE: "none",
                    BLOCK: "block"
                },
                VISIBILITY: {
                    VISIBLE: "visible",
                    HIDDEN: "hidden"
                },
                IMPORTANT: "important"
            };
            function showElement(element) {
                element.style.setProperty("display", "");
            }
            function hideElement(element) {
                element.style.setProperty("display", STYLE.DISPLAY.NONE, STYLE.IMPORTANT);
            }
            function isElementClosed(el) {
                return !el || !el.parentNode;
            }
            function getHttpType(contentType, url) {
                return new _src2.ZalgoPromise(function(resolve, reject) {
                    var req = new window.XMLHttpRequest();
                    req.open("GET", url);
                    req.setRequestHeader("Accept", contentType);
                    req.send(null);
                    req.onload = function() {
                        resolve(req.responseText);
                    };
                    req.onerror = function() {
                        return reject(new Error("prefetch failed"));
                    };
                });
            }
            function getHTML(url) {
                return getHttpType("text/html", url);
            }
            var JSX_EVENTS = {
                onClick: "click"
            };
            function fixScripts(el) {
                var doc = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : window.document, _iterator7 = querySelectorAll(el, "script"), _isArray7 = Array.isArray(_iterator7), _i7 = 0;
                for (_iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator](); ;) {
                    var _ref11;
                    if (_isArray7) {
                        if (_i7 >= _iterator7.length) break;
                        _ref11 = _iterator7[_i7++];
                    } else {
                        if ((_i7 = _iterator7.next()).done) break;
                        _ref11 = _i7.value;
                    }
                    var script = _ref11, newScript = doc.createElement("script");
                    newScript.text = script.textContent;
                    script.parentNode.replaceChild(newScript, script);
                }
            }
        },
        "./src/lib/fn.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.noop = function() {};
            exports.once = function(method) {
                var called = !1, result = void 0;
                return function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    if (called) return result;
                    called = !0;
                    return result = method.apply(this, arguments);
                };
            };
            exports.memoize = function(method) {
                var results = {};
                return function() {
                    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                    var cacheKey = void 0;
                    try {
                        cacheKey = JSON.stringify(Array.prototype.slice.call(arguments), function(key, val) {
                            return "function" == typeof val ? "zoid:memoize[" + (0, _util.getObjectID)(val) + "]" : val;
                        });
                    } catch (err) {
                        throw new Error("Arguments not serializable -- can not be used to memoize");
                    }
                    results.hasOwnProperty(cacheKey) || (results[cacheKey] = method.apply(this, arguments));
                    return results[cacheKey];
                };
            };
            exports.debounce = function(method) {
                var time = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100, timeout = void 0;
                return function() {
                    var _this = this, _arguments = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(function() {
                        return method.apply(_this, _arguments);
                    }, time);
                };
            };
            exports.serializeFunctions = function(obj) {
                return (0, _util.replaceObject)(obj, {
                    function: function() {
                        return {
                            __type__: "__function__"
                        };
                    }
                });
            };
            exports.deserializeFunctions = function(obj, handler) {
                return (0, _util.replaceObject)(obj, {
                    object: function(value, key, fullKey) {
                        if (value && "__function__" === value.__type__) return function() {
                            return handler({
                                key: key,
                                fullKey: fullKey,
                                self: this,
                                args: arguments
                            });
                        };
                    }
                });
            };
            var _util = __webpack_require__("./src/lib/util.js");
        },
        "./src/lib/global.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.global = void 0;
            exports.globalFor = globalFor;
            exports.localGlobal = localGlobal;
            var _src = __webpack_require__("./node_modules/cross-domain-utils/src/index.js"), _constants = __webpack_require__("./src/constants.js");
            function globalFor(win) {
                if ((0, _src.isSameDomain)(win)) {
                    win[_constants.__ZOID__] || (win[_constants.__ZOID__] = {});
                    return win[_constants.__ZOID__];
                }
            }
            function localGlobal() {
                var global = globalFor(window);
                if (!global) throw new Error("Could not get local global");
                return global;
            }
            exports.global = localGlobal();
        },
        "./src/lib/index.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _dom = __webpack_require__("./src/lib/dom.js");
            Object.keys(_dom).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _dom[key];
                    }
                });
            });
            var _fn = __webpack_require__("./src/lib/fn.js");
            Object.keys(_fn).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _fn[key];
                    }
                });
            });
            var _promise = __webpack_require__("./src/lib/promise.js");
            Object.keys(_promise).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _promise[key];
                    }
                });
            });
            var _util = __webpack_require__("./src/lib/util.js");
            Object.keys(_util).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _util[key];
                    }
                });
            });
            var _css = __webpack_require__("./src/lib/css.js");
            Object.keys(_css).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _css[key];
                    }
                });
            });
            var _decorators = __webpack_require__("./src/lib/decorators.js");
            Object.keys(_decorators).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _decorators[key];
                    }
                });
            });
            var _logger = __webpack_require__("./src/lib/logger.js");
            Object.keys(_logger).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _logger[key];
                    }
                });
            });
            var _global = __webpack_require__("./src/lib/global.js");
            Object.keys(_global).forEach(function(key) {
                "default" !== key && "__esModule" !== key && Object.defineProperty(exports, key, {
                    enumerable: !0,
                    get: function() {
                        return _global[key];
                    }
                });
            });
        },
        "./src/lib/logger.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.setLogLevel = function(logLevel) {
                if (-1 === _client.logLevels.indexOf(logLevel)) throw new Error("Invalid logLevel: " + logLevel);
                _client.config.logLevel = logLevel;
                _src.CONFIG.LOG_LEVEL = logLevel;
                window.LOG_LEVEL = logLevel;
            };
            exports.info = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.info)("xc_" + name + "_" + event, payload);
            };
            exports.warn = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.warn)("xc_" + name + "_" + event, payload);
            };
            exports.error = function(name, event) {
                var payload = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                (0, _client.error)("xc_" + name + "_" + event, payload);
            };
            var _src = __webpack_require__("./node_modules/post-robot/src/index.js"), _client = __webpack_require__("./node_modules/beaver-logger/client/index.js");
        },
        "./src/lib/promise.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            exports.denodeify = function(method) {
                return function() {
                    var self = this, args = Array.prototype.slice.call(arguments);
                    return args.length >= method.length ? _src.ZalgoPromise.resolve(method.apply(self, args)) : new _src.ZalgoPromise(function(resolve, reject) {
                        args.push(function(err, result) {
                            if (err && !(err instanceof Error)) throw new Error("Passed non-Error object in callback: [ " + err + " ] -- callbacks should either be called with callback(new Error(...)) or callback(null, result).");
                            return err ? reject(err) : resolve(result);
                        });
                        method.apply(self, args);
                    });
                };
            };
            exports.promisify = function(method) {
                return function() {
                    var _this = this, _arguments = arguments;
                    return _src.ZalgoPromise.try(function() {
                        return method.apply(_this, _arguments);
                    });
                };
            };
            exports.delay = function() {
                var time = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                return new _src.ZalgoPromise(function(resolve) {
                    setTimeout(resolve, time);
                });
            };
            exports.cycle = function cycle(method) {
                return _src.ZalgoPromise.try(method).then(function() {
                    return cycle(method);
                });
            };
            var _src = __webpack_require__("./node_modules/zalgo-promise/src/index.js");
        },
        "./src/lib/util.js": function(module, exports, __webpack_require__) {
            "use strict";
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            exports.urlEncode = function(str) {
                return str.replace(/\?/g, "%3F").replace(/&/g, "%26").replace(/#/g, "%23").replace(/\+/g, "%2B");
            };
            exports.camelToDasherize = function(string) {
                return string.replace(/([A-Z])/g, function(g) {
                    return "-" + g.toLowerCase();
                });
            };
            exports.dasherizeToCamel = function(string) {
                return string.replace(/-([a-z])/g, function(g) {
                    return g[1].toUpperCase();
                });
            };
            exports.extend = function(obj, source) {
                if (!source) return obj;
                for (var key in source) source.hasOwnProperty(key) && (obj[key] = source[key]);
                return obj;
            };
            exports.values = function(obj) {
                var results = [];
                for (var key in obj) obj.hasOwnProperty(key) && results.push(obj[key]);
                return results;
            };
            exports.uniqueID = uniqueID;
            exports.stringifyWithFunctions = function(obj) {
                return JSON.stringify(obj, function(key, val) {
                    return "function" == typeof val ? val.toString() : val;
                });
            };
            exports.safeGet = function(obj, prop) {
                var result = void 0;
                try {
                    result = obj[prop];
                } catch (err) {}
                return result;
            };
            exports.capitalizeFirstLetter = function(string) {
                return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
            };
            exports.get = function(item, path, def) {
                if (!path) return def;
                for (var pathParts = path.split("."), i = 0; i < pathParts.length; i++) {
                    if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item) return def;
                    item = item[pathParts[i]];
                }
                return void 0 === item ? def : item;
            };
            exports.safeInterval = safeInterval;
            exports.safeTimeout = function(method, time) {
                var interval = safeInterval(function() {
                    if ((time -= 100) <= 0) {
                        interval.cancel();
                        method();
                    }
                }, 100);
            };
            exports.each = function(item, callback) {
                if (!item) return;
                if (Array.isArray(item)) for (var len = item.length, i = 0; i < len; i++) callback(item[i], i); else if ("object" === (void 0 === item ? "undefined" : _typeof(item))) for (var keys = Object.keys(item), _len = keys.length, _i = 0; _i < _len; _i++) {
                    var key = keys[_i];
                    callback(item[key], key);
                }
            };
            exports.replaceObject = function replaceObject(item, replacers) {
                var fullKey = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
                if (Array.isArray(item)) {
                    var _ret = function() {
                        for (var length = item.length, result = [], _loop = function(i) {
                            Object.defineProperty(result, i, {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    var itemKey = fullKey ? fullKey + "." + i : "" + i, child = item[i], type = void 0 === child ? "undefined" : _typeof(child), replacer = replacers[type];
                                    if (replacer) {
                                        var replaced = replacer(child, i, itemKey);
                                        if (void 0 !== replaced) {
                                            result[i] = replaced;
                                            return result[i];
                                        }
                                    }
                                    if ("object" === (void 0 === child ? "undefined" : _typeof(child)) && null !== child) {
                                        result[i] = replaceObject(child, replacers, itemKey);
                                        return result[i];
                                    }
                                    result[i] = child;
                                    return result[i];
                                },
                                set: function(value) {
                                    delete result[i];
                                    result[i] = value;
                                }
                            });
                        }, i = 0; i < length; i++) _loop(i);
                        return {
                            v: result
                        };
                    }();
                    if ("object" === (void 0 === _ret ? "undefined" : _typeof(_ret))) return _ret.v;
                } else {
                    if ("object" !== (void 0 === item ? "undefined" : _typeof(item)) || null === item) throw new Error("Pass an object or array");
                    var _ret3 = function() {
                        var result = {}, _loop2 = function(key) {
                            if (!item.hasOwnProperty(key)) return "continue";
                            Object.defineProperty(result, key, {
                                configurable: !0,
                                enumerable: !0,
                                get: function() {
                                    var itemKey = fullKey ? fullKey + "." + key : "" + key, child = item[key], type = void 0 === child ? "undefined" : _typeof(child), replacer = replacers[type];
                                    if (replacer) {
                                        var replaced = replacer(child, key, itemKey);
                                        if (void 0 !== replaced) {
                                            result[key] = replaced;
                                            return result[key];
                                        }
                                    }
                                    if ("object" === (void 0 === child ? "undefined" : _typeof(child)) && null !== child) {
                                        result[key] = replaceObject(child, replacers, itemKey);
                                        return result[key];
                                    }
                                    result[key] = child;
                                    return result[key];
                                },
                                set: function(value) {
                                    delete result[key];
                                    result[key] = value;
                                }
                            });
                        };
                        for (var key in item) _loop2(key);
                        return {
                            v: result
                        };
                    }();
                    if ("object" === (void 0 === _ret3 ? "undefined" : _typeof(_ret3))) return _ret3.v;
                }
            };
            exports.copyProp = function(source, target, name, def) {
                if (source.hasOwnProperty(name)) {
                    var descriptor = Object.getOwnPropertyDescriptor(source, name);
                    Object.defineProperty(target, name, descriptor);
                } else target[name] = def;
            };
            exports.dotify = function dotify(obj) {
                var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                var newobj = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                prefix = prefix ? prefix + "." : prefix;
                for (var key in obj) void 0 !== obj[key] && null !== obj[key] && "function" != typeof obj[key] && (obj[key] && Array.isArray(obj[key]) && obj[key].length && obj[key].every(function(val) {
                    return "object" !== (void 0 === val ? "undefined" : _typeof(val));
                }) ? newobj["" + prefix + key] = obj[key].join(",") : obj[key] && "object" === _typeof(obj[key]) ? newobj = dotify(obj[key], "" + prefix + key, newobj) : newobj["" + prefix + key] = obj[key].toString());
                return newobj;
            };
            exports.getObjectID = function(obj) {
                if (null === obj || void 0 === obj || "object" !== (void 0 === obj ? "undefined" : _typeof(obj)) && "function" != typeof obj) throw new Error("Invalid object");
                var uid = objectIDs.get(obj);
                if (!uid) {
                    uid = (void 0 === obj ? "undefined" : _typeof(obj)) + ":" + uniqueID();
                    objectIDs.set(obj, uid);
                }
                return uid;
            };
            exports.regex = regex;
            exports.regexAll = function(pattern, string) {
                var matches = [], start = 0;
                for (;;) {
                    var match = regex(pattern, string, start);
                    if (!match) break;
                    matches.push(match);
                    start = match.end;
                }
                return matches;
            };
            exports.count = function(str, substr) {
                var startIndex = 0, itemCount = 0;
                for (;;) {
                    var index = str.indexOf(substr, startIndex);
                    if (-1 === index) break;
                    startIndex = index;
                    itemCount += 1;
                }
                return itemCount;
            };
            exports.stringify = stringify;
            exports.stringifyError = function(err) {
                if (err) {
                    var stack = err.stack, message = err.message;
                    if ("string" == typeof stack) return stack;
                    if ("string" == typeof message) return message;
                }
                return stringify(err);
            };
            exports.eventEmitter = function() {
                var triggered = {}, handlers = {};
                return {
                    on: function(eventName, handler) {
                        var handlerList = handlers[eventName] = handlers[eventName] || [];
                        handlerList.push(handler);
                        var cancelled = !1;
                        return {
                            cancel: function() {
                                if (!cancelled) {
                                    cancelled = !0;
                                    handlerList.splice(handlerList.indexOf(handler), 1);
                                }
                            }
                        };
                    },
                    once: function(eventName, handler) {
                        var listener = this.on(eventName, function() {
                            listener.cancel();
                            handler();
                        });
                        return listener;
                    },
                    trigger: function(eventName) {
                        var handlerList = handlers[eventName];
                        if (handlerList) for (var _iterator = handlerList, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ;) {
                            var _ref;
                            if (_isArray) {
                                if (_i2 >= _iterator.length) break;
                                _ref = _iterator[_i2++];
                            } else {
                                if ((_i2 = _iterator.next()).done) break;
                                _ref = _i2.value;
                            }
                            var _handler = _ref;
                            _handler();
                        }
                    },
                    triggerOnce: function(eventName) {
                        if (!triggered[eventName]) {
                            triggered[eventName] = !0;
                            this.trigger(eventName);
                        }
                    }
                };
            };
            function uniqueID() {
                var chars = "0123456789abcdef";
                return "xxxxxxxxxx".replace(/./g, function() {
                    return chars.charAt(Math.floor(Math.random() * chars.length));
                });
            }
            function safeInterval(method, time) {
                var timeout = void 0;
                timeout = setTimeout(function runInterval() {
                    timeout = setTimeout(runInterval, time);
                    method.call();
                }, time);
                return {
                    cancel: function() {
                        clearTimeout(timeout);
                    }
                };
            }
            var objectIDs = new (__webpack_require__("./node_modules/cross-domain-safe-weakmap/src/index.js").WeakMap)();
            function regex(pattern, string) {
                var start = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                "string" == typeof pattern && (pattern = new RegExp(pattern));
                var result = string.slice(start).match(pattern);
                if (result) {
                    var index = result.index, match = result[0];
                    return {
                        text: match,
                        groups: result.slice(1),
                        start: start + index,
                        end: start + index + match.length,
                        length: match.length,
                        replace: function(text) {
                            return match ? "" + match.slice(0, start + index) + text + match.slice(index + match.length) : "";
                        }
                    };
                }
            }
            function stringify(item) {
                return "string" == typeof item ? item : item && "function" == typeof item.toString ? item.toString() : Object.prototype.toString.call(item);
            }
        },
        "./src/types.js": function(module, exports, __webpack_require__) {
            "use strict";
        }
    });
});
//# sourceMappingURL=zoid.js.map
//# sourceMappingURL=zoid.js.map

/***/ }),

/***/ "./node_modules/zoid/index.js":
/*!************************************!*\
  !*** ./node_modules/zoid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/* @flow */
/* eslint import/no-commonjs: 0 */

// eslint-disable-next-line no-process-env
if (process.env.ZOID_FRAME_ONLY) {
    // $FlowFixMe
    module.exports = __webpack_require__(/*! ./dist/zoid.frame */ "./node_modules/zoid/dist/zoid.frame.js");
    module.exports.default = module.exports;
} else {
    // $FlowFixMe
    module.exports = __webpack_require__(/*! ./dist/zoid */ "./node_modules/zoid/dist/zoid.js");
    module.exports.default = module.exports;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./src/Component.js":
/*!**************************!*\
  !*** ./src/Component.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var zoid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zoid */ "./node_modules/zoid/index.js");
/* harmony import */ var zoid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zoid__WEBPACK_IMPORTED_MODULE_0__);
// @flow


const Component = Object(zoid__WEBPACK_IMPORTED_MODULE_0__["create"])({
  tag: 'checkout-component',
  defaultEnv: 'locale',
  url: {
    locale: 'http://localhost:5000/button'
  },
});

/* harmony default export */ __webpack_exports__["default"] = (Component);


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./src/Component.js");


const Nano = {
  Component: _Component__WEBPACK_IMPORTED_MODULE_0__
};

window.Nano = Nano;

/* harmony default export */ __webpack_exports__["default"] = (Nano);


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvem9pZC9kaXN0L3pvaWQuZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3pvaWQvZGlzdC96b2lkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy96b2lkL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQSxDQUFDO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUIsUUFBUSxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQixRQUFRLHFCQUFxQjtBQUNsRDtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOFJBQThSLDZEQUE2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QXlCO0FBQ3pCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEVBQUU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Es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QUFDQTtBQUNBLHlMQUF5TCxFQUFFO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxzQzs7Ozs7Ozs7Ozs7QUNsaFFBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNB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QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsRUFBRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FB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Q0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1IQUFtSDtBQUNuSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUIsc0JBQXNCO0FBQzVEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUxBQXlMLEVBQUU7QUFDM0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLGdDOzs7Ozs7Ozs7OztBQ2ptUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUFBO0FBQUE7QUFDaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FDWEE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6ImFwcC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi4vcHVibGljXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIiFmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBtb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoXCJ6b2lkXCIsIFtdLCBmYWN0b3J5KSA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgPyBleHBvcnRzLnpvaWQgPSBmYWN0b3J5KCkgOiByb290LnpvaWQgPSBmYWN0b3J5KCk7XG59KFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHNlbGYgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1vZHVsZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSByZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBsOiAhMSxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAgICAgbW9kdWxlLmwgPSAhMDtcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiAgICAgICAgfVxuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCBcImFcIiwgZ2V0dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnZXR0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4gICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4gICAgfSh7XG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvYnVpbGRlcnMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5hZGRQYXlsb2FkQnVpbGRlciA9IGZ1bmN0aW9uKGJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkQnVpbGRlcnMucHVzaChidWlsZGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZE1ldGFCdWlsZGVyID0gZnVuY3Rpb24oYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIG1ldGFCdWlsZGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkVHJhY2tpbmdCdWlsZGVyID0gZnVuY3Rpb24oYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nQnVpbGRlcnMucHVzaChidWlsZGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZEhlYWRlckJ1aWxkZXIgPSBmdW5jdGlvbihidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyQnVpbGRlcnMucHVzaChidWlsZGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcGF5bG9hZEJ1aWxkZXJzID0gZXhwb3J0cy5wYXlsb2FkQnVpbGRlcnMgPSBbXSwgbWV0YUJ1aWxkZXJzID0gZXhwb3J0cy5tZXRhQnVpbGRlcnMgPSBbXSwgdHJhY2tpbmdCdWlsZGVycyA9IGV4cG9ydHMudHJhY2tpbmdCdWlsZGVycyA9IFtdLCBoZWFkZXJCdWlsZGVycyA9IGV4cG9ydHMuaGVhZGVyQnVpbGRlcnMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9jb25maWcuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5jb25maWcgPSB7XG4gICAgICAgICAgICAgICAgdXJpOiBcIlwiLFxuICAgICAgICAgICAgICAgIHByZWZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBpbml0aWFsX3N0YXRlX25hbWU6IFwiaW5pdFwiLFxuICAgICAgICAgICAgICAgIGZsdXNoSW50ZXJ2YWw6IDZlNSxcbiAgICAgICAgICAgICAgICBkZWJvdW5jZUludGVydmFsOiAxMCxcbiAgICAgICAgICAgICAgICBzaXplTGltaXQ6IDMwMCxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6ICExLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdDogITAsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0Q29uc29sZUxvZzogITAsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0SW50ZXJ2YWw6IDVlMyxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRUb29CdXN5OiAhMSxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRUb29CdXN5VGhyZXNob2xkOiAxZTQsXG4gICAgICAgICAgICAgICAgbG9nTGV2ZWw6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgIGF1dG9Mb2c6IFsgXCJ3YXJuXCIsIFwiZXJyb3JcIiBdLFxuICAgICAgICAgICAgICAgIGxvZ1VubG9hZDogITAsXG4gICAgICAgICAgICAgICAgbG9nUGVyZm9ybWFuY2U6ICEwXG4gICAgICAgICAgICB9LCBleHBvcnRzLmxvZ0xldmVscyA9IFsgXCJlcnJvclwiLCBcIndhcm5cIiwgXCJpbmZvXCIsIFwiZGVidWdcIiBdO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfaW50ZXJmYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2ludGVyZmFjZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnRlcmZhY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ludGVyZmFjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBJTlRFUkZBQ0UgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvYmopIGZvciAodmFyIGtleSBpbiBvYmopIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgKG5ld09ialtrZXldID0gb2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9KF9pbnRlcmZhY2UpO1xuICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gSU5URVJGQUNFO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luaXQuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oY29uZikge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC5leHRlbmQpKF9jb25maWcuY29uZmlnLCBjb25mIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhdGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW5pdGlhdGVkID0gITA7XG4gICAgICAgICAgICAgICAgX2NvbmZpZy5jb25maWcubG9nUGVyZm9ybWFuY2UgJiYgKDAsIF9wZXJmb3JtYW5jZS5pbml0UGVyZm9ybWFuY2UpKCk7XG4gICAgICAgICAgICAgICAgX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0ICYmICgwLCBfcGVyZm9ybWFuY2UuaW5pdEhlYXJ0QmVhdCkoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZy5jb25maWcubG9nVW5sb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW5mbykoXCJ3aW5kb3dfYmVmb3JldW5sb2FkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW1tZWRpYXRlRmx1c2gpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmluZm8pKFwid2luZG93X3VubG9hZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmltbWVkaWF0ZUZsdXNoKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbmZpZy5jb25maWcuZmx1c2hJbnRlcnZhbCAmJiBzZXRJbnRlcnZhbChfbG9nZ2VyLmZsdXNoLCBfY29uZmlnLmNvbmZpZy5mbHVzaEludGVydmFsKTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmJlYXZlckxvZ1F1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5iZWF2ZXJMb2dRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmxvZykocGF5bG9hZC5sZXZlbCwgcGF5bG9hZC5ldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93LmJlYXZlckxvZ1F1ZXVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9jb25maWcuanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3V0aWwuanNcIiksIF9wZXJmb3JtYW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9wZXJmb3JtYW5jZS5qc1wiKSwgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9sb2dnZXIuanNcIiksIGluaXRpYXRlZCA9ICExO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2ludGVyZmFjZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9sb2dnZXIuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfbG9nZ2VyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9sb2dnZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2luaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvaW5pdC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbml0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbml0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF90cmFuc2l0aW9ucyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC90cmFuc2l0aW9ucy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90cmFuc2l0aW9ucykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHJhbnNpdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2J1aWxkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2J1aWxkZXJzLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2J1aWxkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9idWlsZGVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2NvbmZpZy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb25maWcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9sb2dnZXIuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy50cmFjayA9IGV4cG9ydHMuZmx1c2ggPSBleHBvcnRzLnRyYWNraW5nID0gZXhwb3J0cy5idWZmZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24obmV3VHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMucHJpbnQgPSBwcmludDtcbiAgICAgICAgICAgIGV4cG9ydHMuaW1tZWRpYXRlRmx1c2ggPSBpbW1lZGlhdGVGbHVzaDtcbiAgICAgICAgICAgIGV4cG9ydHMubG9nID0gbG9nO1xuICAgICAgICAgICAgZXhwb3J0cy5wcmVmaXggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWc6IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwiZGVidWdcIiwgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbmZvOiBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZyhcImluZm9cIiwgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3YXJuOiBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZyhcIndhcm5cIiwgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2coXCJlcnJvclwiLCBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrOiBmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RyYWNrKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBmbHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVidWcgPSBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2coXCJkZWJ1Z1wiLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pbmZvID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwiaW5mb1wiLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy53YXJuID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwid2FyblwiLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZyhcImVycm9yXCIsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvdXRpbC5qc1wiKSwgX2J1aWxkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2J1aWxkZXJzLmpzXCIpLCBfY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2NvbmZpZy5qc1wiKSwgYnVmZmVyID0gZXhwb3J0cy5idWZmZXIgPSBbXSwgdHJhY2tpbmcgPSBleHBvcnRzLnRyYWNraW5nID0gW107XG4gICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAmJiB3aW5kb3cuY29uc29sZSAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGNvbnNvbGUubG9nKSAmJiBbIFwibG9nXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiIF0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZF0gPSB0aGlzLmJpbmQoY29uc29sZVttZXRob2RdLCBjb25zb2xlKTtcbiAgICAgICAgICAgIH0sIEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsKTtcbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSBmdW5jdGlvbihoZWFkZXJzLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5hamF4KShcInBvc3RcIiwgX2NvbmZpZy5jb25maWcudXJpLCBoZWFkZXJzLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gITE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGxvYWRlZCA9ICEwO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcmludChsZXZlbCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmludChsZXZlbCwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0gd2luZG93LkxPR19MRVZFTCB8fCBfY29uZmlnLmNvbmZpZy5sb2dMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2NvbmZpZy5sb2dMZXZlbHMuaW5kZXhPZihsZXZlbCkgPiBfY29uZmlnLmxvZ0xldmVscy5pbmRleE9mKGxvZ0xldmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbIGV2ZW50IF07XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwuaXNJRSkoKSAmJiAocGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXlsb2FkLmVycm9yIHx8IHBheWxvYWQud2FybmluZykgJiYgYXJncy5wdXNoKFwiXFxuXFxuXCIsIHBheWxvYWQuZXJyb3IgfHwgcGF5bG9hZC53YXJuaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGVbbGV2ZWxdICYmIHdpbmRvdy5jb25zb2xlW2xldmVsXS5hcHBseSA/IHdpbmRvdy5jb25zb2xlW2xldmVsXS5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncykgOiB3aW5kb3cuY29uc29sZS5sb2cgJiYgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5ICYmIHdpbmRvdy5jb25zb2xlLmxvZy5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbW1lZGlhdGVGbHVzaCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZiRmaXJlQW5kRm9yZ2V0ID0gKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge30pLmZpcmVBbmRGb3JnZXQsIGZpcmVBbmRGb3JnZXQgPSB2b2lkIDAgIT09IF9yZWYkZmlyZUFuZEZvcmdldCAmJiBfcmVmJGZpcmVBbmRGb3JnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKF9jb25maWcuY29uZmlnLnVyaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQnVmZmVyID0gYnVmZmVyLmxlbmd0aCwgaGFzVHJhY2tpbmcgPSB0cmFja2luZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNCdWZmZXIgfHwgaGFzVHJhY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0ge30sIF9pdGVyYXRvciA9IF9idWlsZGVycy5tZXRhQnVpbGRlcnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWlsZGVyID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLmV4dGVuZCkobWV0YSwgYnVpbGRlcihtZXRhKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY3VzdG9tIG1ldGEgYnVpbGRlcjpcIiwgZXJyLnN0YWNrIHx8IGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHt9LCBfaXRlcmF0b3IyID0gX2J1aWxkZXJzLmhlYWRlckJ1aWxkZXJzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2J1aWxkZXIgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZXh0ZW5kKShoZWFkZXJzLCBfYnVpbGRlcihoZWFkZXJzKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY3VzdG9tIGhlYWRlciBidWlsZGVyOlwiLCBlcnIuc3RhY2sgfHwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSB0cmFuc3BvcnQoaGVhZGVycywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmc6IHRyYWNraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmlyZUFuZEZvcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy50cmFja2luZyA9IHRyYWNraW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9mbHVzaCA9ICgwLCBfdXRpbC5wcm9taXNlRGVib3VuY2UpKGltbWVkaWF0ZUZsdXNoLCBfY29uZmlnLmNvbmZpZy5kZWJvdW5jZUludGVydmFsKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZmx1c2ggPSBfZmx1c2g7XG4gICAgICAgICAgICBmdW5jdGlvbiBlbnF1ZXVlKGxldmVsLCBldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5hdXRvTG9nLmluZGV4T2YobGV2ZWwpID4gLTEgJiYgX2ZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsb2cobGV2ZWwsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgX2NvbmZpZy5jb25maWcucHJlZml4ICYmIChldmVudCA9IF9jb25maWcuY29uZmlnLnByZWZpeCArIFwiX1wiICsgZXZlbnQpO1xuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIChwYXlsb2FkID0gcGF5bG9hZCB8fCB7fSkgPyBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgfSA6IHBheWxvYWQgaW5zdGFuY2VvZiBFcnJvciAmJiAocGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHBheWxvYWQuc3RhY2sgfHwgcGF5bG9hZC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF5bG9hZC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2J1aWxkZXJzLnBheWxvYWRCdWlsZGVycywgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY0ID0gX2kzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWlsZGVyID0gX3JlZjQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZXh0ZW5kKShwYXlsb2FkLCBidWlsZGVyKHBheWxvYWQpLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGN1c3RvbSBwYXlsb2FkIGJ1aWxkZXI6XCIsIGVyci5zdGFjayB8fCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NvbmZpZy5jb25maWcuc2lsZW50IHx8IHByaW50KGxldmVsLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmxlbmd0aCA9PT0gX2NvbmZpZy5jb25maWcuc2l6ZUxpbWl0ID8gZW5xdWV1ZShcImluZm9cIiwgXCJsb2dnZXJfbWF4X2J1ZmZlcl9sZW5ndGhcIikgOiBidWZmZXIubGVuZ3RoIDwgX2NvbmZpZy5jb25maWcuc2l6ZUxpbWl0ICYmIGVucXVldWUobGV2ZWwsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90cmFjayhwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9idWlsZGVycy50cmFja2luZ0J1aWxkZXJzLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLCBfaTQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgPyBfaXRlcmF0b3I0IDogX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjQubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pNC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidWlsZGVyID0gX3JlZjU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5leHRlbmQpKHBheWxvYWQsIGJ1aWxkZXIocGF5bG9hZCksICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjdXN0b20gdHJhY2tpbmcgYnVpbGRlcjpcIiwgZXJyLnN0YWNrIHx8IGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcmludChcImRlYnVnXCIsIFwidHJhY2tpbmdcIiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nLnB1c2gocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy50cmFjayA9IF90cmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9wZXJmb3JtYW5jZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnJlcVRpbWVyID0gZXhwb3J0cy5jbGllbnRUaW1lciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMubm93ID0gbm93O1xuICAgICAgICAgICAgZXhwb3J0cy5yZXFTdGFydEVsYXBzZWQgPSByZXFTdGFydEVsYXBzZWQ7XG4gICAgICAgICAgICBleHBvcnRzLmluaXRIZWFydEJlYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhcnRCZWF0VGltZXIgPSB0aW1lcigpLCBoZWFydGJlYXRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLnNhZmVJbnRlcnZhbCkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF9jb25maWcuY29uZmlnLmhlYXJ0YmVhdE1heFRocmVzaG9sZCAmJiBoZWFydGJlYXRDb3VudCA+IF9jb25maWcuY29uZmlnLmhlYXJ0YmVhdE1heFRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYXJ0YmVhdENvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZCA9IGhlYXJ0QmVhdFRpbWVyLmVsYXBzZWQoKSwgbGFnID0gZWxhcHNlZCAtIF9jb25maWcuY29uZmlnLmhlYXJ0YmVhdEludGVydmFsLCBoZWFydGJlYXRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBoZWFydGJlYXRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGFwc2VkOiBlbGFwc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25maWcuY29uZmlnLmhlYXJ0YmVhdFRvb0J1c3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFydGJlYXRQYXlsb2FkLmxhZyA9IGxhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWcgPj0gX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0VG9vQnVzeVRocmVzaG9sZCAmJiAoMCwgX2xvZ2dlci5pbmZvKShcInRvb2J1c3lcIiwgaGVhcnRiZWF0UGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub0NvbnNvbGU6ICFfY29uZmlnLmNvbmZpZy5oZWFydGJlYXRDb25zb2xlTG9nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKShcImhlYXJ0YmVhdFwiLCBoZWFydGJlYXRQYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9Db25zb2xlOiAhX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0Q29uc29sZUxvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY29uZmlnLmNvbmZpZy5oZWFydGJlYXRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pbml0UGVyZm9ybWFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZVBlcmZvcm1hbmNlKSByZXR1cm4gKDAsIF9sb2dnZXIuaW5mbykoXCJub19wZXJmb3JtYW5jZV9kYXRhXCIpO1xuICAgICAgICAgICAgICAgICgwLCBfYnVpbGRlcnMuYWRkUGF5bG9hZEJ1aWxkZXIpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmNsaWVudF9lbGFwc2VkID0gY2xpZW50VGltZXIuZWxhcHNlZCgpO1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVQZXJmb3JtYW5jZSAmJiAocGF5bG9hZC5yZXFfZWxhcHNlZCA9IHJlcVRpbWVyLmVsYXBzZWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF91dGlsLndpbmRvd1JlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1pbmcgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgWyBcImNvbm5lY3RFbmRcIiwgXCJjb25uZWN0U3RhcnRcIiwgXCJkb21Db21wbGV0ZVwiLCBcImRvbUNvbnRlbnRMb2FkZWRFdmVudEVuZFwiLCBcImRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0XCIsIFwiZG9tSW50ZXJhY3RpdmVcIiwgXCJkb21Mb2FkaW5nXCIsIFwiZG9tYWluTG9va3VwRW5kXCIsIFwiZG9tYWluTG9va3VwU3RhcnRcIiwgXCJmZXRjaFN0YXJ0XCIsIFwibG9hZEV2ZW50RW5kXCIsIFwibG9hZEV2ZW50U3RhcnRcIiwgXCJuYXZpZ2F0aW9uU3RhcnRcIiwgXCJyZWRpcmVjdEVuZFwiLCBcInJlZGlyZWN0U3RhcnRcIiwgXCJyZXF1ZXN0U3RhcnRcIiwgXCJyZXNwb25zZUVuZFwiLCBcInJlc3BvbnNlU3RhcnRcIiwgXCJzZWN1cmVDb25uZWN0aW9uU3RhcnRcIiwgXCJ1bmxvYWRFdmVudEVuZFwiLCBcInVubG9hZEV2ZW50U3RhcnRcIiBdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1pbmdba2V5XSA9IHBhcnNlSW50KHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmdba2V5XSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGltaW5nLmNvbm5lY3RFbmQgLSB0aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB0aW1pbmcuY29ubmVjdEVuZCAmJiBPYmplY3Qua2V5cyh0aW1pbmcpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSB0aW1pbmdbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICYmICgwLCBfbG9nZ2VyLmluZm8pKFwidGltaW5nX1wiICsgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudF9lbGFwc2VkOiBwYXJzZUludCh0aW1lIC0gdGltaW5nLmNvbm5lY3RFbmQgLSAoY2xpZW50VGltZXIuc3RhcnRUaW1lIC0gb2Zmc2V0KSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcV9lbGFwc2VkOiBwYXJzZUludCh0aW1lIC0gdGltaW5nLmNvbm5lY3RFbmQsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKShcInRpbWluZ1wiLCB0aW1pbmcpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKShcIm1lbW9yeVwiLCB3aW5kb3cucGVyZm9ybWFuY2UubWVtb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW5mbykoXCJuYXZpZ2F0aW9uXCIsIHdpbmRvdy5wZXJmb3JtYW5jZS5uYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXMgJiYgd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbIFwibGlua1wiLCBcInNjcmlwdFwiLCBcImltZ1wiLCBcImNzc1wiIF0uaW5kZXhPZihyZXNvdXJjZS5pbml0aWF0b3JUeXBlKSA+IC0xICYmICgwLCBfbG9nZ2VyLmluZm8pKHJlc291cmNlLmluaXRpYXRvclR5cGUsIHJlc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9jb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvY29uZmlnLmpzXCIpLCBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2xvZ2dlci5qc1wiKSwgX2J1aWxkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2J1aWxkZXJzLmpzXCIpLCBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC91dGlsLmpzXCIpLCBlbmFibGVQZXJmb3JtYW5jZSA9IHdpbmRvdyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ICYmIHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcuY29ubmVjdEVuZCAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ICYmIE1hdGguYWJzKHBlcmZvcm1hbmNlLm5vdygpIC0gRGF0ZS5ub3coKSkgPiAxZTMgJiYgcGVyZm9ybWFuY2Uubm93KCkgLSAocGVyZm9ybWFuY2UudGltaW5nLmNvbm5lY3RFbmQgLSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KSA+IDA7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZVBlcmZvcm1hbmNlID8gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGltZXIoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgPSB2b2lkIDAgIT09IHN0YXJ0VGltZSA/IHN0YXJ0VGltZSA6IG5vdygpLFxuICAgICAgICAgICAgICAgICAgICBlbGFwc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChub3coKSAtIHN0YXJ0VGltZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZXFTdGFydEVsYXBzZWQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZVBlcmZvcm1hbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1pbmcgPSB3aW5kb3cucGVyZm9ybWFuY2UudGltaW5nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGltaW5nLmNvbm5lY3RFbmQgLSB0aW1pbmcubmF2aWdhdGlvblN0YXJ0LCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsaWVudFRpbWVyID0gZXhwb3J0cy5jbGllbnRUaW1lciA9IHRpbWVyKCksIHJlcVRpbWVyID0gZXhwb3J0cy5yZXFUaW1lciA9IHRpbWVyKHJlcVN0YXJ0RWxhcHNlZCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC90cmFuc2l0aW9ucy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnN0YXJ0VHJhbnNpdGlvbiA9IHN0YXJ0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGV4cG9ydHMuZW5kVHJhbnNpdGlvbiA9IGVuZFRyYW5zaXRpb247XG4gICAgICAgICAgICBleHBvcnRzLnRyYW5zaXRpb24gPSBmdW5jdGlvbih0b1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgZW5kVHJhbnNpdGlvbih0b1N0YXRlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3BlcmZvcm1hbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3BlcmZvcm1hbmNlLmpzXCIpLCBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2xvZ2dlci5qc1wiKSwgX2J1aWxkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2J1aWxkZXJzLmpzXCIpLCBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC91dGlsLmpzXCIpLCBfY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2NvbmZpZy5qc1wiKSwgd2luZG93SUQgPSAoMCwgXG4gICAgICAgICAgICBfdXRpbC51bmlxdWVJRCkoKSwgcGFnZUlEID0gKDAsIF91dGlsLnVuaXF1ZUlEKSgpLCBjdXJyZW50U3RhdGUgPSBfY29uZmlnLmNvbmZpZy5pbml0aWFsX3N0YXRlX25hbWUsIHN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSAoMCwgX3BlcmZvcm1hbmNlLm5vdykoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuZFRyYW5zaXRpb24odG9TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHN0YXJ0VGltZSB8fCAoMCwgX3BlcmZvcm1hbmNlLnJlcVN0YXJ0RWxhcHNlZCkoKTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSAoMCwgX3BlcmZvcm1hbmNlLm5vdykoKSwgZWxhcHNlZFRpbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdm9pZCAwICE9PSBzdGFydFRpbWUgJiYgKGVsYXBzZWRUaW1lID0gcGFyc2VJbnQoY3VycmVudFRpbWUgLSBzdGFydFRpbWUsIDApKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSBcInRyYW5zaXRpb25fXCIgKyBjdXJyZW50U3RhdGUgKyBcIl90b19cIiArIHRvU3RhdGU7XG4gICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW5mbykodHJhbnNpdGlvbk5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGVsYXBzZWRUaW1lXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIudHJhY2spKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fdGltZTogZWxhcHNlZFRpbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbW1lZGlhdGVGbHVzaCkoKTtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSB0b1N0YXRlO1xuICAgICAgICAgICAgICAgIHBhZ2VJRCA9ICgwLCBfdXRpbC51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBfYnVpbGRlcnMuYWRkUGF5bG9hZEJ1aWxkZXIpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0lEOiB3aW5kb3dJRCxcbiAgICAgICAgICAgICAgICAgICAgcGFnZUlEOiBwYWdlSURcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoMCwgX2J1aWxkZXJzLmFkZE1ldGFCdWlsZGVyKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJ1aV9cIiArIGN1cnJlbnRTdGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC91dGlsLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMud2luZG93UmVhZHkgPSB2b2lkIDA7XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKGRlc3QsIHNyYykge1xuICAgICAgICAgICAgICAgIHZhciBvdmVyID0gIShhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSkgfHwgYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgICAgIGRlc3QgPSBkZXN0IHx8IHt9O1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYyB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHNyYykgc3JjLmhhc093blByb3BlcnR5KGkpICYmICghb3ZlciAmJiBkZXN0Lmhhc093blByb3BlcnR5KGkpIHx8IChkZXN0W2ldID0gc3JjW2ldKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc1NhbWVQcm90b2NvbCA9IGlzU2FtZVByb3RvY29sO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1NhbWVEb21haW4gPSBpc1NhbWVEb21haW47XG4gICAgICAgICAgICBleHBvcnRzLmFqYXggPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiB7fSwgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDoge30sIF9yZWYkZmlyZUFuZEZvcmdldCA9IChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1s0XSA/IGFyZ3VtZW50c1s0XSA6IHt9KS5maXJlQW5kRm9yZ2V0LCBmaXJlQW5kRm9yZ2V0ID0gdm9pZCAwICE9PSBfcmVmJGZpcmVBbmRGb3JnZXQgJiYgX3JlZiRmaXJlQW5kRm9yZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYy5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgWFJlcXVlc3QgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgd2luZG93LkFjdGl2ZVhPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgIWlzU2FtZURvbWFpbih1cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVByb3RvY29sKHVybCkpIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBYUmVxdWVzdCA9IHdpbmRvdy5YRG9tYWluUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhSZXF1ZXN0KFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXEub3BlbihtZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCAhMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhlYWRlck5hbWUgaW4gaGVhZGVycykgaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShoZWFkZXJOYW1lKSAmJiByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0ID8gcmVzb2x2ZSgpIDogcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnJlYWR5U3RhdGUgPiAzICYmIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkucmVwbGFjZSgvJi9nLCBcIiUyNlwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcm9taXNlRGVib3VuY2UgPSBmdW5jdGlvbihtZXRob2QsIGludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlYm91bmNlID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYm91bmNlLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZS50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZS50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlYm91bmNlLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVyID0gZGVib3VuY2UucmVzb2x2ZXIsIHJlamVjdG9yID0gZGVib3VuY2UucmVqZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGVib3VuY2UucHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZS5yZXNvbHZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZS5yZWplY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZS50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHJlc29sdmVyLCByZWplY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UucHJvbWlzZSA9IGRlYm91bmNlLnByb21pc2UgfHwgbmV3IF9zcmMuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmVyLCByZWplY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYm91bmNlLnJlamVjdG9yID0gcmVqZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVib3VuY2UucHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2FmZUludGVydmFsID0gZnVuY3Rpb24obWV0aG9kLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnVuaXF1ZUlEID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0lFID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4od2luZG93LmRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NhbWVQcm90b2NvbCh1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSB1cmwuc3BsaXQoXCIvXCIpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNTYW1lRG9tYWluKHVybCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHVybC5tYXRjaCgvaHR0cHM/OlxcL1xcL1teL10rLyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFtYXRjaCB8fCBtYXRjaFswXSA9PT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLndpbmRvd1JlYWR5ID0gbmV3IF9zcmMuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBkb2N1bWVudCAmJiBcImNvbXBsZXRlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGUgJiYgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZXNvbHZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfaW50ZXJmYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2ludGVyZmFjZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnRlcmZhY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ludGVyZmFjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBJTlRFUkZBQ0UgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvYmopIGZvciAodmFyIGtleSBpbiBvYmopIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgKG5ld09ialtrZXldID0gb2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9KF9pbnRlcmZhY2UpO1xuICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gSU5URVJGQUNFO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2ludGVyZmFjZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3dlYWttYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvd2Vha21hcC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldlYWtNYXBcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfd2Vha21hcC5Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL25hdGl2ZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmhhc05hdGl2ZVdlYWtNYXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5XZWFrTWFwKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuT2JqZWN0LmZyZWV6ZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0V2Vha01hcCA9IG5ldyB3aW5kb3cuV2Vha01hcCgpLCB0ZXN0S2V5ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5PYmplY3QuZnJlZXplKHRlc3RLZXkpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0V2Vha01hcC5zZXQodGVzdEtleSwgXCJfX3Rlc3R2YWx1ZV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfX3Rlc3R2YWx1ZV9fXCIgPT09IHRlc3RXZWFrTWFwLmdldCh0ZXN0S2V5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvdXRpbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnNhZmVJbmRleE9mID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlbSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy93ZWFrbWFwLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuQ3Jvc3NEb21haW5TYWZlV2Vha01hcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9uYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvbmF0aXZlLmpzXCIpLCBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy91dGlsLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICAgICAgICAgIGV4cG9ydHMuQ3Jvc3NEb21haW5TYWZlV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENyb3NzRG9tYWluU2FmZVdlYWtNYXAoKSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIENyb3NzRG9tYWluU2FmZVdlYWtNYXApO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiX193ZWFrbWFwX1wiICsgKDFlOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApICsgXCJfX1wiICsgY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfbmF0aXZlLmhhc05hdGl2ZVdlYWtNYXApKCkpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSBuZXcgd2luZG93LldlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ3Jvc3NEb21haW5TYWZlV2Vha01hcC5wcm90b3R5cGUuX2NsZWFudXBDbG9zZWRXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXAsIGtleXMgPSB0aGlzLmtleXMsIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1dpbmRvdykodmFsdWUpICYmICgwLCBfc3JjLmlzV2luZG93Q2xvc2VkKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZS5pc1NhZmVUb1JlYWRXcml0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMuaXNXaW5kb3cpKGtleSkpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5ub29wKShrZXkgJiYga2V5LnNlbGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKGtleSAmJiBrZXlbdGhpcy5uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLCBlbnRyeSA9IGtleVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA9IHZhbHVlIDogZGVmaW5lUHJvcGVydHkoa2V5LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFsga2V5LCB2YWx1ZSBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsIHZhbHVlcyA9IHRoaXMudmFsdWVzLCBpbmRleCA9ICgwLCBfdXRpbC5zYWZlSW5kZXhPZikoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuIHdlYWttYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLCBpbmRleCA9ICgwLCBfdXRpbC5zYWZlSW5kZXhPZikoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5KSByZXR1cm4gZW50cnlbMV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ICYmIChlbnRyeVswXSA9IGVudHJ5WzFdID0gdm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cywgaW5kZXggPSAoMCwgX3V0aWwuc2FmZUluZGV4T2YpKGtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3ZWFrbWFwLmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xICE9PSAoMCwgX3V0aWwuc2FmZUluZGV4T2YpKHRoaXMua2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBDcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL3V0aWxzLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3V0aWxzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF91dGlsc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfdHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy90eXBlcy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHlwZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy90eXBlcy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvdXRpbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmlzUmVnZXggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvdXRpbHMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0ZpbGVQcm90b2NvbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB3aW5kb3cpLmxvY2F0aW9uLnByb3RvY29sID09PSBDT05TVEFOVFMuRklMRV9QUk9UT0NPTDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzQWJvdXRQcm90b2NvbCA9IGlzQWJvdXRQcm90b2NvbDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UGFyZW50ID0gZ2V0UGFyZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRPcGVuZXIgPSBnZXRPcGVuZXI7XG4gICAgICAgICAgICBleHBvcnRzLmNhblJlYWRGcm9tV2luZG93ID0gY2FuUmVhZEZyb21XaW5kb3c7XG4gICAgICAgICAgICBleHBvcnRzLmdldEFjdHVhbERvbWFpbiA9IGdldEFjdHVhbERvbWFpbjtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0RG9tYWluID0gZ2V0RG9tYWluO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0JsYW5rRG9tYWluID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJhYm91dDpibGFua1wiID09PSB3aW4ubG9jYXRpb24uaHJlZikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0FjdHVhbGx5U2FtZURvbWFpbiA9IGlzQWN0dWFsbHlTYW1lRG9tYWluO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1NhbWVEb21haW4gPSBpc1NhbWVEb21haW47XG4gICAgICAgICAgICBleHBvcnRzLmdldFBhcmVudHMgPSBnZXRQYXJlbnRzO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0FuY2VzdG9yUGFyZW50ID0gaXNBbmNlc3RvclBhcmVudDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0RnJhbWVzID0gZ2V0RnJhbWVzO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRBbGxDaGlsZEZyYW1lcyA9IGdldEFsbENoaWxkRnJhbWVzO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRUb3AgPSBnZXRUb3A7XG4gICAgICAgICAgICBleHBvcnRzLmdldEFsbEZyYW1lc0luV2luZG93ID0gZ2V0QWxsRnJhbWVzSW5XaW5kb3c7XG4gICAgICAgICAgICBleHBvcnRzLmlzVG9wID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbiA9PT0gZ2V0VG9wKHdpbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0ZyYW1lV2luZG93Q2xvc2VkID0gaXNGcmFtZVdpbmRvd0Nsb3NlZDtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNXaW5kb3dDbG9zZWQgPSBpc1dpbmRvd0Nsb3NlZDtcbiAgICAgICAgICAgIGV4cG9ydHMubGlua0ZyYW1lV2luZG93ID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWZyYW1lRnJhbWVzLmxlbmd0aDsgaSsrKSBpZiAoaXNGcmFtZVdpbmRvd0Nsb3NlZChpZnJhbWVGcmFtZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVGcmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lV2luZG93cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgaWZyYW1lV2luZG93cy5sZW5ndGg7IF9pNSsrKSBpZiAoaXNXaW5kb3dDbG9zZWQoaWZyYW1lV2luZG93c1tfaTVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lRnJhbWVzLnNwbGljZShfaTUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lV2luZG93cy5zcGxpY2UoX2k1LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgZnJhbWUuY29udGVudFdpbmRvdykgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lV2luZG93cy5wdXNoKGZyYW1lLmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWVGcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0VXNlckFnZW50ID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh3aW4gPSB3aW4gfHwgd2luZG93KS5uYXZpZ2F0b3IubW9ja1VzZXJBZ2VudCB8fCB3aW4ubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEZyYW1lQnlOYW1lID0gZ2V0RnJhbWVCeU5hbWU7XG4gICAgICAgICAgICBleHBvcnRzLmZpbmRDaGlsZEZyYW1lQnlOYW1lID0gZmluZENoaWxkRnJhbWVCeU5hbWU7XG4gICAgICAgICAgICBleHBvcnRzLmZpbmRGcmFtZUJ5TmFtZSA9IGZ1bmN0aW9uKHdpbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUgPSBnZXRGcmFtZUJ5TmFtZSh3aW4sIG5hbWUpKSByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRDaGlsZEZyYW1lQnlOYW1lKGdldFRvcCh3aW4pIHx8IHdpbiwgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc1BhcmVudCA9IGZ1bmN0aW9uKHdpbiwgZnJhbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVQYXJlbnQgPSBnZXRQYXJlbnQoZnJhbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZVBhcmVudCkgcmV0dXJuIGZyYW1lUGFyZW50ID09PSB3aW47XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IGdldEZyYW1lcyh3aW4pLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTggPSAwLCBfaXRlcmF0b3I2ID0gX2lzQXJyYXk2ID8gX2l0ZXJhdG9yNiA6IF9pdGVyYXRvcjZbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pOCA+PSBfaXRlcmF0b3I2Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNiA9IF9pdGVyYXRvcjZbX2k4KytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTggPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNiA9IF9pOC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRGcmFtZSA9IF9yZWY2O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRGcmFtZSA9PT0gZnJhbWUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNPcGVuZXIgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA9PT0gZ2V0T3BlbmVyKGNoaWxkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEFuY2VzdG9yID0gZ2V0QW5jZXN0b3I7XG4gICAgICAgICAgICBleHBvcnRzLmdldEFuY2VzdG9ycyA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIGFuY2VzdG9yID0gd2luO1xuICAgICAgICAgICAgICAgIGZvciAoO2FuY2VzdG9yOyApIChhbmNlc3RvciA9IGdldEFuY2VzdG9yKGFuY2VzdG9yKSkgJiYgcmVzdWx0cy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzQW5jZXN0b3IgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBhcmVudCA9IGdldEFuY2VzdG9yKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsUGFyZW50KSByZXR1cm4gYWN0dWFsUGFyZW50ID09PSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VG9wKGNoaWxkKSA9PT0gY2hpbGQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I3ID0gZ2V0RnJhbWVzKHBhcmVudCksIF9pc0FycmF5NyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNyksIF9pOSA9IDAsIF9pdGVyYXRvcjcgPSBfaXNBcnJheTcgPyBfaXRlcmF0b3I3IDogX2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k5ID49IF9pdGVyYXRvcjcubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY3ID0gX2l0ZXJhdG9yN1tfaTkrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pOSA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY3ID0gX2k5LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9yZWY3O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUgPT09IGNoaWxkKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzUG9wdXAgPSBpc1BvcHVwO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0lmcmFtZSA9IGlzSWZyYW1lO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0Z1bGxwYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oIWlzSWZyYW1lKCkgJiYgIWlzUG9wdXAoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXREaXN0YW5jZUZyb21Ub3AgPSBnZXREaXN0YW5jZUZyb21Ub3A7XG4gICAgICAgICAgICBleHBvcnRzLmdldE50aFBhcmVudCA9IGdldE50aFBhcmVudDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0TnRoUGFyZW50RnJvbVRvcCA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROdGhQYXJlbnQod2luLCBnZXREaXN0YW5jZUZyb21Ub3Aod2luKSAtIG4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNTYW1lVG9wV2luZG93ID0gZnVuY3Rpb24od2luMSwgd2luMikge1xuICAgICAgICAgICAgICAgIHZhciB0b3AxID0gZ2V0VG9wKHdpbjEpIHx8IHdpbjEsIHRvcDIgPSBnZXRUb3Aod2luMikgfHwgd2luMjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wMSAmJiB0b3AyKSByZXR1cm4gdG9wMSA9PT0gdG9wMjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdmFyIGFsbEZyYW1lczEgPSBnZXRBbGxGcmFtZXNJbldpbmRvdyh3aW4xKSwgYWxsRnJhbWVzMiA9IGdldEFsbEZyYW1lc0luV2luZG93KHdpbjIpO1xuICAgICAgICAgICAgICAgIGlmIChhbnlNYXRjaChhbGxGcmFtZXMxLCBhbGxGcmFtZXMyKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIHZhciBvcGVuZXIxID0gZ2V0T3BlbmVyKHRvcDEpLCBvcGVuZXIyID0gZ2V0T3BlbmVyKHRvcDIpO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuZXIxICYmIGFueU1hdGNoKGdldEFsbEZyYW1lc0luV2luZG93KG9wZW5lcjEpLCBhbGxGcmFtZXMyKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuZXIyICYmIGFueU1hdGNoKGdldEFsbEZyYW1lc0luV2luZG93KG9wZW5lcjIpLCBhbGxGcmFtZXMxKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm1hdGNoRG9tYWluID0gZnVuY3Rpb24gbWF0Y2hEb21haW4ocGF0dGVybiwgb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG9yaWdpbikgcmV0dXJuIHBhdHRlcm4gPT09IENPTlNUQU5UUy5XSUxEQ0FSRCB8fCBvcmlnaW4gPT09IHBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3V0aWwuaXNSZWdleCkob3JpZ2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX3V0aWwuaXNSZWdleCkocGF0dGVybikpIHJldHVybiAoMCwgX3V0aWwuaXNSZWdleCkob3JpZ2luKSA/IHBhdHRlcm4udG9TdHJpbmcoKSA9PT0gb3JpZ2luLnRvU3RyaW5nKCkgOiAhQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIEJvb2xlYW4ob3JpZ2luLm1hdGNoKHBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkgcmV0dXJuIEFycmF5LmlzQXJyYXkob3JpZ2luKSA/IEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pID09PSBKU09OLnN0cmluZ2lmeShvcmlnaW4pIDogISgwLCBcbiAgICAgICAgICAgICAgICBfdXRpbC5pc1JlZ2V4KShvcmlnaW4pICYmIHBhdHRlcm4uc29tZShmdW5jdGlvbihzdWJwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaERvbWFpbihzdWJwYXR0ZXJuLCBvcmlnaW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeURvbWFpblBhdHRlcm4gPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogKDAsIF91dGlsLmlzUmVnZXgpKHBhdHRlcm4pID8gXCJSZWdFeHAoXCIgKyBwYXR0ZXJuLnRvU3RyaW5nKCkgOiBwYXR0ZXJuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXREb21haW5Gcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoIXVybC5tYXRjaCgvXihodHRwcz98bW9ja3xmaWxlKTpcXC9cXC8vKSkgcmV0dXJuIGdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9IHVybDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluID0gZG9tYWluLnNwbGl0KFwiL1wiKS5zbGljZSgwLCAzKS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm9uQ2xvc2VXaW5kb3cgPSBmdW5jdGlvbih3aW4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAxZTMsIG1heHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IDEgLyAwLCB0aW1lb3V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heHRpbWUgPD0gMCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heHRpbWUgLT0gZGVsYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChjaGVjaywgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc1dpbmRvdyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuV2luZG93ICYmIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5zZWxmID09PSBvYmopIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5wYXJlbnQgPT09IG9iaikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnRvcCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKG9iaiA9PSBvYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5ub29wKShvYmogJiYgb2JqLl9fY3Jvc3NfZG9tYWluX3V0aWxzX3dpbmRvd19jaGVja19fKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvdXRpbC5qc1wiKSwgQ09OU1RBTlRTID0ge1xuICAgICAgICAgICAgICAgIE1PQ0tfUFJPVE9DT0w6IFwibW9jazpcIixcbiAgICAgICAgICAgICAgICBGSUxFX1BST1RPQ09MOiBcImZpbGU6XCIsXG4gICAgICAgICAgICAgICAgQUJPVVRfUFJPVE9DT0w6IFwiYWJvdXQ6XCIsXG4gICAgICAgICAgICAgICAgV0lMRENBUkQ6IFwiKlwiXG4gICAgICAgICAgICB9LCBJRV9XSU5fQUNDRVNTX0VSUk9SID0gXCJDYWxsIHdhcyByZWplY3RlZCBieSBjYWxsZWUuXFxyXFxuXCI7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc0Fib3V0UHJvdG9jb2woKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdykubG9jYXRpb24ucHJvdG9jb2wgPT09IENPTlNUQU5UUy5BQk9VVF9QUk9UT0NPTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBhcmVudCh3aW4pIHtcbiAgICAgICAgICAgICAgICBpZiAod2luKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luLnBhcmVudCAmJiB3aW4ucGFyZW50ICE9PSB3aW4pIHJldHVybiB3aW4ucGFyZW50O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9wZW5lcih3aW4pIHtcbiAgICAgICAgICAgICAgICBpZiAod2luICYmICFnZXRQYXJlbnQod2luKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbi5vcGVuZXI7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY2FuUmVhZEZyb21XaW5kb3cod2luKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKHdpbiAmJiB3aW4ubG9jYXRpb24gJiYgd2luLmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbERvbWFpbih3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB3aW4ubG9jYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWFkIHdpbmRvdyBsb2NhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3RvY29sKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IHByb3RvY29sXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbCA9PT0gQ09OU1RBTlRTLkZJTEVfUFJPVE9DT0wpIHJldHVybiBDT05TVEFOVFMuRklMRV9QUk9UT0NPTCArIFwiLy9cIjtcbiAgICAgICAgICAgICAgICBpZiAocHJvdG9jb2wgPT09IENPTlNUQU5UUy5BQk9VVF9QUk9UT0NPTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KHdpbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgJiYgY2FuUmVhZEZyb21XaW5kb3cod2luKSA/IGdldEFjdHVhbERvbWFpbihwYXJlbnQpIDogQ09OU1RBTlRTLkFCT1VUX1BST1RPQ09MICsgXCIvL1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFob3N0KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGhvc3RcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sICsgXCIvL1wiICsgaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldERvbWFpbih3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZ2V0QWN0dWFsRG9tYWluKHdpbiA9IHdpbiB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21haW4gJiYgd2luLm1vY2tEb21haW4gJiYgMCA9PT0gd2luLm1vY2tEb21haW4uaW5kZXhPZihDT05TVEFOVFMuTU9DS19QUk9UT0NPTCkgPyB3aW4ubW9ja0RvbWFpbiA6IGRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQWN0dWFsbHlTYW1lRG9tYWluKHdpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAmJiAhMSA9PT0gZGVzYy5lbnVtZXJhYmxlKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRBY3R1YWxEb21haW4od2luKSA9PT0gZ2V0QWN0dWFsRG9tYWluKHdpbmRvdykpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNTYW1lRG9tYWluKHdpbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNBY3R1YWxseVNhbWVEb21haW4od2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBYm91dFByb3RvY29sKHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3cod2luKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RG9tYWluKHdpbmRvdykgPT09IGdldERvbWFpbih3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFBhcmVudHMod2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoO3dpbi5wYXJlbnQgIT09IHdpbjsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aW4ucGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbiA9IHdpbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQW5jZXN0b3JQYXJlbnQocGFyZW50LCBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZFBhcmVudCA9IGdldFBhcmVudChjaGlsZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkUGFyZW50ID8gY2hpbGRQYXJlbnQgPT09IHBhcmVudCA6IC0xICE9PSBnZXRQYXJlbnRzKGNoaWxkKS5pbmRleE9mKHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZXMod2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBmcmFtZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luLmZyYW1lcztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVzID0gd2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGZyYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIGlmICgwID09PSBsZW4pIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDEwMDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gZnJhbWVzW19pXTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2ZyYW1lKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChfZnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBfaXRlcmF0b3IgPSBnZXRGcmFtZXMod2luKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IGdldEFsbENoaWxkRnJhbWVzKGZyYW1lKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRGcmFtZSA9IF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRvcCh3aW4pIHtcbiAgICAgICAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLnRvcCkgcmV0dXJuIHdpbi50b3A7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldFBhcmVudCh3aW4pID09PSB3aW4pIHJldHVybiB3aW47XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbmNlc3RvclBhcmVudCh3aW5kb3csIHdpbikgJiYgd2luZG93LnRvcCkgcmV0dXJuIHdpbmRvdy50b3A7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbiwgd2luZG93KSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IGdldEFsbENoaWxkRnJhbWVzKHdpbiksIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pNCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yM1tfaTQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k0ID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS50b3ApIHJldHVybiBmcmFtZS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KGZyYW1lKSA9PT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEFsbEZyYW1lc0luV2luZG93KHdpbikge1xuICAgICAgICAgICAgICAgIHZhciB0b3AgPSBnZXRUb3Aod2luKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsQ2hpbGRGcmFtZXModG9wKS5jb25jYXQodG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRnJhbWVXaW5kb3dDbG9zZWQoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLmNvbnRlbnRXaW5kb3cpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICBpZiAoIWZyYW1lLnBhcmVudE5vZGUpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZnJhbWUub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gISghZG9jIHx8ICFkb2MuYm9keSB8fCBkb2MuYm9keS5jb250YWlucyhmcmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlmcmFtZVdpbmRvd3MgPSBbXSwgaWZyYW1lRnJhbWVzID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1dpbmRvd0Nsb3NlZCh3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsb3dNb2NrID0gIShhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSkgfHwgYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi5jbG9zZWQpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlcnIgfHwgZXJyLm1lc3NhZ2UgIT09IElFX1dJTl9BQ0NFU1NfRVJST1I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd01vY2sgJiYgaXNTYW1lRG9tYWluKHdpbikpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4ubW9ja2Nsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbi5wYXJlbnQgfHwgIXdpbi50b3ApIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKHdpbiA9PSB3aW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpZnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25baV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9KGlmcmFtZVdpbmRvd3MsIHdpbik7XG4gICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpZnJhbWVJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBpZnJhbWVGcmFtZXNbaWZyYW1lSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUgJiYgaXNGcmFtZVdpbmRvd0Nsb3NlZChmcmFtZSkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVCeU5hbWUod2luLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbkZyYW1lcyA9IGdldEZyYW1lcyh3aW4pLCBfaXRlcmF0b3I0ID0gd2luRnJhbWVzLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLCBfaTYgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTYgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaXRlcmF0b3I0W19pNisrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k2ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaTYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkRnJhbWUgPSBfcmVmNDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVEb21haW4oY2hpbGRGcmFtZSkgJiYgY2hpbGRGcmFtZS5uYW1lID09PSBuYW1lICYmIC0xICE9PSB3aW5GcmFtZXMuaW5kZXhPZihjaGlsZEZyYW1lKSkgcmV0dXJuIGNoaWxkRnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSB3aW5GcmFtZXMuaW5kZXhPZih3aW4uZnJhbWVzW25hbWVdKSkgcmV0dXJuIHdpbi5mcmFtZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gd2luRnJhbWVzLmluZGV4T2Yod2luW25hbWVdKSkgcmV0dXJuIHdpbltuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kQ2hpbGRGcmFtZUJ5TmFtZSh3aW4sIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUJ5TmFtZSh3aW4sIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gZ2V0RnJhbWVzKHdpbiksIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNSksIF9pNyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1ID0gX2lzQXJyYXk1ID8gX2l0ZXJhdG9yNSA6IF9pdGVyYXRvcjVbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNyA+PSBfaXRlcmF0b3I1Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k3KytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTcgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pNy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZWRGcmFtZSA9IGZpbmRDaGlsZEZyYW1lQnlOYW1lKF9yZWY1LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVkRnJhbWUpIHJldHVybiBuYW1lZEZyYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEFuY2VzdG9yKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBvcGVuZXIgPSBnZXRPcGVuZXIod2luID0gd2luIHx8IHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5lcikgcmV0dXJuIG9wZW5lcjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50KHdpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCB8fCB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1BvcHVwKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGdldE9wZW5lcih3aW5kb3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzSWZyYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGdldFBhcmVudCh3aW5kb3cpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFueU1hdGNoKGNvbGxlY3Rpb24xLCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I4ID0gY29sbGVjdGlvbjEsIF9pc0FycmF5OCA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yOCksIF9pMTAgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOCA9IF9pc0FycmF5OCA/IF9pdGVyYXRvcjggOiBfaXRlcmF0b3I4W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTEwID49IF9pdGVyYXRvcjgubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yOFtfaTEwKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTEwID0gX2l0ZXJhdG9yOC5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaTEwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtMSA9IF9yZWY4LCBfaXRlcmF0b3I5ID0gY29sbGVjdGlvbjIsIF9pc0FycmF5OSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yOSksIF9pMTEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjkgPSBfaXNBcnJheTkgPyBfaXRlcmF0b3I5IDogX2l0ZXJhdG9yOVtTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kxMSA+PSBfaXRlcmF0b3I5Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjkgPSBfaXRlcmF0b3I5W19pMTErK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kxMSA9IF9pdGVyYXRvcjkubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pMTEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbTEgPT09IF9yZWY5KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VGcm9tVG9wKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRpc3RhbmNlID0gMCwgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB3aW5kb3c7IHBhcmVudDsgKSAocGFyZW50ID0gZ2V0UGFyZW50KHBhcmVudCkpICYmIChkaXN0YW5jZSArPSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXROdGhQYXJlbnQod2luKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogMSwgcGFyZW50ID0gd2luLCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBnZXRQYXJlbnQocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9oaS1iYXNlMzIvc3JjL2Jhc2UzMi5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgKGZ1bmN0aW9uKHByb2Nlc3MsIGdsb2JhbCwgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fLCBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBcIm9iamVjdFwiID09PSAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPyB3aW5kb3cgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgIXJvb3QuSElfQkFTRTMyX05PX05PREVfSlMgJiYgXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gcHJvY2VzcyA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHByb2Nlc3MpKSAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJiAocm9vdCA9IGdsb2JhbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBDT01NT05fSlMgPSAhcm9vdC5ISV9CQVNFMzJfTk9fQ09NTU9OX0pTICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2YobW9kdWxlKSAmJiBtb2R1bGUuZXhwb3J0cywgQU1EID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1wiKSwgQkFTRTMyX0VOQ09ERV9DSEFSID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiLnNwbGl0KFwiXCIpLCBCQVNFMzJfREVDT0RFX0NIQVIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgQjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEM6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBEOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgRTogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEY6IDUsXG4gICAgICAgICAgICAgICAgICAgICAgICBHOiA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgSDogNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEk6IDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBKOiA5LFxuICAgICAgICAgICAgICAgICAgICAgICAgSzogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICBMOiAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE06IDEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgTjogMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICBPOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFA6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgICAgUTogMTYsXG4gICAgICAgICAgICAgICAgICAgICAgICBSOiAxNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFM6IDE4LFxuICAgICAgICAgICAgICAgICAgICAgICAgVDogMTksXG4gICAgICAgICAgICAgICAgICAgICAgICBVOiAyMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFY6IDIxLFxuICAgICAgICAgICAgICAgICAgICAgICAgVzogMjIsXG4gICAgICAgICAgICAgICAgICAgICAgICBYOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFk6IDI0LFxuICAgICAgICAgICAgICAgICAgICAgICAgWjogMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAyOiAyNixcbiAgICAgICAgICAgICAgICAgICAgICAgIDM6IDI3LFxuICAgICAgICAgICAgICAgICAgICAgICAgNDogMjgsXG4gICAgICAgICAgICAgICAgICAgICAgICA1OiAyOSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDY6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgNzogMzFcbiAgICAgICAgICAgICAgICAgICAgfSwgYmxvY2tzID0gWyAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwIF0sIHRocm93SW52YWxpZFV0ZjggPSBmdW5jdGlvbihwb3NpdGlvbiwgcGFydGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5sZW5ndGggPiAxMCAmJiAocGFydGlhbCA9IFwiLi4uXCIgKyBwYXJ0aWFsLnN1YnN0cigtMTApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXCJEZWNvZGVkIGRhdGEgaXMgbm90IHZhbGlkIFVURi04LiBNYXliZSB0cnkgYmFzZTMyLmRlY29kZS5hc0J5dGVzKCk/IFBhcnRpYWwgZGF0YSBhZnRlciByZWFkaW5nIFwiICsgcG9zaXRpb24gKyBcIiBieXRlczogXCIgKyBwYXJ0aWFsICsgXCIgPC1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVjb2RlQXNCeXRlcyA9IGZ1bmN0aW9uKGJhc2UzMlN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvXltBLVoyLTc9XSskLy50ZXN0KGJhc2UzMlN0cikpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTMyIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NywgdjgsIGJ5dGVzID0gW10sIGluZGV4ID0gMCwgbGVuZ3RoID0gKGJhc2UzMlN0ciA9IGJhc2UzMlN0ci5yZXBsYWNlKC89L2csIFwiXCIpKS5sZW5ndGgsIGkgPSAwLCBjb3VudCA9IGxlbmd0aCA+PiAzIDw8IDM7IGkgPCBjb3VudDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY2ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2OCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjQgPDwgNCB8IHY1ID4+PiAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2NyA8PCA1IHwgdjgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MSA8PCAzIHwgdjIgPj4+IDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICg0ID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDUgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MSA8PCAzIHwgdjIgPj4+IDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYyIDw8IDYgfCB2MyA8PCAxIHwgdjQgPj4+IDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHY0IDw8IDQgfCB2NSA+Pj4gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDcgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2NCA8PCA0IHwgdjUgPj4+IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICAgICAgICAgICAgICB9LCBkZWNvZGUgPSBmdW5jdGlvbihiYXNlMzJTdHIsIGFzY2lpT25seSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhc2NpaU9ubHkpIHJldHVybiBmdW5jdGlvbihieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIsIGMsIHN0ciA9IFwiXCIsIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aCwgaSA9IDAsIGZvbGxvd2luZ0NoYXJzID0gMDsgaSA8IGxlbmd0aDsgKSBpZiAoKGIgPSBieXRlc1tpKytdKSA8PSAxMjcpIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPiAxOTEgJiYgYiA8PSAyMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAzMSAmIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dpbmdDaGFycyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA8PSAyMzkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAxNSAmIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dpbmdDaGFycyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYiA8PSAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSA3ICYgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGxvd2luZ0NoYXJzID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHRocm93SW52YWxpZFV0ZjgoaSwgc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb2xsb3dpbmdDaGFyczsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGIgPSBieXRlc1tpKytdKSA8IDEyOCB8fCBiID4gMTkxKSAmJiB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIDw8PSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyArPSA2MyAmIGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA+PSA1NTI5NiAmJiBjIDw9IDU3MzQzICYmIHRocm93SW52YWxpZFV0ZjgoaSwgc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA+IDExMTQxMTEgJiYgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA8PSA2NTUzNSkgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyAtPSA2NTUzNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2ICsgKGMgPj4gMTApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU2MzIwICsgKDEwMjMgJiBjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oZGVjb2RlQXNCeXRlcyhiYXNlMzJTdHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghL15bQS1aMi03PV0rJC8udGVzdChiYXNlMzJTdHIpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2UzMiBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgc3RyID0gXCJcIiwgbGVuZ3RoID0gYmFzZTMyU3RyLmluZGV4T2YoXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IGxlbmd0aCAmJiAobGVuZ3RoID0gYmFzZTMyU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgY291bnQgPSBsZW5ndGggPj4gMyA8PCAzOyBpIDwgY291bnQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjggPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2NCA8PCA0IHwgdjUgPj4+IDEpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHY3IDw8IDUgfCB2OCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDIgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDQgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMikpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICg1ID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMikpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjQgPDwgNCB8IHY1ID4+PiAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDcgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY3ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMikpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCkpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjQgPDwgNCB8IHY1ID4+PiAxKSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2NSA8PCA3IHwgdjYgPDwgMiB8IHY3ID4+PiAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgICAgICB9LCBleHBvcnRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbihpbnB1dCwgYXNjaWlPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdFN0cmluZyA9IFwic3RyaW5nXCIgIT0gdHlwZW9mIGlucHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdFN0cmluZyAmJiBpbnB1dC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIgJiYgKGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm90U3RyaW5nID8gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBiYXNlMzJTdHIgPSBcIlwiLCBsZW5ndGggPSBieXRlcy5sZW5ndGgsIGkgPSAwLCBjb3VudCA9IDUgKiBwYXJzZUludChsZW5ndGggLyA1KTsgaSA8IGNvdW50OyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY1ID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYzIDw8IDEgfCB2NCA+Pj4gNyldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0ID4+PiAyICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHY0IDw8IDMgfCB2NSA+Pj4gNSldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgdjVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YxIDw8IDIgJiAzMV0gKyBcIj09PT09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDIgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyIDw8IDQgJiAzMV0gKyBcIj09PT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MyA8PCAxICYgMzFdICsgXCI9PT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICg0ID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gYnl0ZXNbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MyA8PCAxIHwgdjQgPj4+IDcpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2NCA+Pj4gMiAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2NCA8PCAzICYgMzFdICsgXCI9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UzMlN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGlucHV0KSA6IGFzY2lpT25seSA/IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIGJhc2UzMlN0ciA9IFwiXCIsIGxlbmd0aCA9IHN0ci5sZW5ndGgsIGkgPSAwLCBjb3VudCA9IDUgKiBwYXJzZUludChsZW5ndGggLyA1KTsgaSA8IGNvdW50OyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY1ID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYzIDw8IDEgfCB2NCA+Pj4gNyldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0ID4+PiAyICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHY0IDw8IDMgfCB2NSA+Pj4gNSldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgdjVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1haW4gPSBsZW5ndGggLSBjb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDEgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YxIDw8IDIgJiAzMV0gKyBcIj09PT09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDIgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyIDw8IDQgJiAzMV0gKyBcIj09PT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MyA8PCAxICYgMzFdICsgXCI9PT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICg0ID09PSByZW1haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MyA8PCAxIHwgdjQgPj4+IDcpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2NCA+Pj4gMiAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2NCA8PCAzICYgMzFdICsgXCI9XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UzMlN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGlucHV0KSA6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCBjb2RlLCBpLCBlbmQgPSAhMSwgYmFzZTMyU3RyID0gXCJcIiwgaW5kZXggPSAwLCBzdGFydCA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1s1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxXSA9IGJsb2Nrc1s2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1syXSA9IGJsb2Nrc1s3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNTsgKytpbmRleCkgaWYgKChjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSA8IDEyOCkgYmxvY2tzW2krK10gPSBjb2RlOyBlbHNlIGlmIChjb2RlIDwgMjA0OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTkyIHwgY29kZSA+PiA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTI4IHwgNjMgJiBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgNTUyOTYgfHwgY29kZSA+PSA1NzM0NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMjI0IHwgY29kZSA+PiAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSsrXSA9IDEyOCB8IGNvZGUgPj4gNiAmIDYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTI4IHwgNjMgJiBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gNjU1MzYgKyAoKDEwMjMgJiBjb2RlKSA8PCAxMCB8IDEwMjMgJiBzdHIuY2hhckNvZGVBdCgrK2luZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAyNDAgfCBjb2RlID4+IDE4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTI4IHwgY29kZSA+PiAxMiAmIDYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTI4IHwgY29kZSA+PiA2ICYgNjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxMjggfCA2MyAmIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgLSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPT09IGxlbmd0aCAmJiArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPiBsZW5ndGggJiYgaSA8IDYgJiYgKGVuZCA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gYmxvY2tzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBibG9ja3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBibG9ja3NbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBibG9ja3NbNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjIgPDwgNCB8IHYzID4+PiA0KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjMgPDwgMSB8IHY0ID4+PiA3KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjQgPj4+IDIgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjQgPDwgMyB8IHY1ID4+PiA1KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiB2NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDEgPT09IGkpIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YxIDw8IDIgJiAzMV0gKyBcIj09PT09PVwiOyBlbHNlIGlmICgyID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBibG9ja3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPDwgNCAmIDMxXSArIFwiPT09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgzID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBibG9ja3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjIgPDwgNCB8IHYzID4+PiA0KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjMgPDwgMSAmIDMxXSArIFwiPT09XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYmxvY2tzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gYmxvY2tzWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gYmxvY2tzWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYzIDw8IDEgfCB2NCA+Pj4gNyldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0ID4+PiAyICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0IDw8IDMgJiAzMV0gKyBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoIWVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlMzJTdHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlOiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlLmFzQnl0ZXMgPSBkZWNvZGVBc0J5dGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NTU9OX0pTKSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5iYXNlMzIgPSBleHBvcnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgQU1EICYmIHZvaWQgMCAhPT0gKF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSkgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcIikobW9kdWxlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2JyaWRnZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93cyA9IF9nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd3MgfHwge307XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dJZCA9IDA7XG4gICAgICAgICAgICBmdW5jdGlvbiBkZWxldGVUdW5uZWxXaW5kb3coaWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzW2lkXSAmJiBkZWxldGUgX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93c1tpZF0uc291cmNlO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICBkZWxldGUgX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93c1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRUdW5uZWxXaW5kb3coX3JlZjIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWUsIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSwgY2FuYXJ5ID0gX3JlZjIuY2FuYXJ5LCBzZW5kTWVzc2FnZSA9IF9yZWYyLnNlbmRNZXNzYWdlO1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR1bm5lbFdpbmRvd3MgPSBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzLCBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyh0dW5uZWxXaW5kb3dzKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZiwgdHVubmVsV2luZG93ID0gdHVubmVsV2luZG93c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5ub29wKSh0dW5uZWxXaW5kb3cuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVR1bm5lbFdpbmRvdyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMuaXNXaW5kb3dDbG9zZWQpKHR1bm5lbFdpbmRvdy5zb3VyY2UpICYmIGRlbGV0ZVR1bm5lbFdpbmRvdyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd0lkICs9IDE7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93c1tfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5hcnk6IGNhbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHNlbmRNZXNzYWdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5vcGVuVHVubmVsVG9QYXJlbnQgPSBmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSwgc291cmNlID0gX3JlZjMuc291cmNlLCBjYW5hcnkgPSBfcmVmMy5jYW5hcnksIHNlbmRNZXNzYWdlID0gX3JlZjMuc2VuZE1lc3NhZ2UsIHBhcmVudFdpbmRvdyA9ICgwLCBcbiAgICAgICAgICAgICAgICBfc3JjLmdldFBhcmVudCkod2luZG93KTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiTm8gcGFyZW50IHdpbmRvdyBmb3VuZCB0byBvcGVuIHR1bm5lbCB0b1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBhZGRUdW5uZWxXaW5kb3coe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgY2FuYXJ5OiBjYW5hcnksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBzZW5kTWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC5zZW5kKHBhcmVudFdpbmRvdywgX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9OQU1FUy5PUEVOX1RVTk5FTCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHVubmVsV2luZG93ID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93c1tpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIubm9vcCkodHVubmVsV2luZG93ICYmIHR1bm5lbFdpbmRvdy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlVHVubmVsV2luZG93KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHVubmVsV2luZG93ICYmIHR1bm5lbFdpbmRvdy5zb3VyY2UgJiYgISgwLCBfc3JjLmlzV2luZG93Q2xvc2VkKSh0dW5uZWxXaW5kb3cuc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1bm5lbFdpbmRvdy5jYW5hcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dW5uZWxXaW5kb3cuc2VuZE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfY29uZi5DT05TVEFOVFMuV0lMRENBUkRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2NoaWxkLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMub3BlblR1bm5lbFRvT3BlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW5lciA9ICgwLCBfc3JjMi5nZXRPcGVuZXIpKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuZXIgJiYgKDAsIF9jb21tb24ubmVlZHNCcmlkZ2UpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogb3BlbmVyXG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2NvbW1vbi5yZWdpc3RlclJlbW90ZVdpbmRvdykob3BlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdFJlbW90ZUJyaWRnZUZvcldpbmRvdyhvcGVuZXIpLnRoZW4oZnVuY3Rpb24oYnJpZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyaWRnZSA/IHdpbmRvdy5uYW1lID8gYnJpZGdlW19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXS5vcGVuVHVubmVsVG9QYXJlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB3aW5kb3cubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB3aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmFyeTogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIubm9vcCkod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgIXdpbmRvdy5jbG9zZWQpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVjZWl2ZU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHRoaXMub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjLlphbGdvUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSwgb3JpZ2luID0gX3JlZjIub3JpZ2luLCBkYXRhID0gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3BlbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJTb3VyY2UgZG9lcyBub3QgbWF0Y2ggb3BlbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2NvbW1vbi5yZWdpc3RlclJlbW90ZVNlbmRNZXNzYWdlKShzb3VyY2UsIG9yaWdpbiwgZGF0YS5zZW5kTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY29tbW9uLnJlamVjdFJlbW90ZVNlbmRNZXNzYWdlKShvcGVuZXIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6ICgwLCBfY29tbW9uLnJlamVjdFJlbW90ZVNlbmRNZXNzYWdlKShvcGVuZXIsIG5ldyBFcnJvcihcIkNhbiBub3QgcmVnaXN0ZXIgd2l0aCBvcGVuZXI6IHdpbmRvdyBkb2VzIG5vdCBoYXZlIGEgbmFtZVwiKSkgOiAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbW1vbi5yZWplY3RSZW1vdGVTZW5kTWVzc2FnZSkob3BlbmVyLCBuZXcgRXJyb3IoXCJDYW4gbm90IHJlZ2lzdGVyIHdpdGggb3BlbmVyOiBubyBicmlkZ2UgZm91bmQgaW4gb3BlbmVyXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKSwgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvY29tbW9uLmpzXCIpLCBhd2FpdFJlbW90ZUJyaWRnZUZvcldpbmRvdyA9ICgwLCBcbiAgICAgICAgICAgIF9saWIud2Vha01hcE1lbW9pemUpKGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSAoMCwgX3NyYzIuZ2V0RnJhbWVzKSh3aW4pLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2ZyYW1lICYmIF9mcmFtZSAhPT0gd2luZG93ICYmICgwLCBfc3JjMi5pc1NhbWVEb21haW4pKF9mcmFtZSkgJiYgX2ZyYW1lW19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXSkgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSAoMCwgX3NyYzIuZ2V0RnJhbWVCeU5hbWUpKHdpbiwgKDAsIF9jb21tb24uZ2V0QnJpZGdlTmFtZSkoKDAsIF9zcmMyLmdldERvbWFpbikoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFtZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc3JjMi5pc1NhbWVEb21haW4pKGZyYW1lKSAmJiBmcmFtZVtfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0gPyBmcmFtZSA6IG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gdm9pZCAwLCB0aW1lb3V0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiAoMCwgX3NyYzIuaXNTYW1lRG9tYWluKShmcmFtZSkgJiYgZnJhbWVbX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDJlMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2NvbW1vbi5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmRvY3VtZW50Qm9keVJlYWR5ID0gdm9pZCAwO1xuICAgICAgICAgICAgZXhwb3J0cy5uZWVkc0JyaWRnZUZvckJyb3dzZXIgPSBuZWVkc0JyaWRnZUZvckJyb3dzZXI7XG4gICAgICAgICAgICBleHBvcnRzLm5lZWRzQnJpZGdlRm9yV2luID0gbmVlZHNCcmlkZ2VGb3JXaW47XG4gICAgICAgICAgICBleHBvcnRzLm5lZWRzQnJpZGdlRm9yRG9tYWluID0gbmVlZHNCcmlkZ2VGb3JEb21haW47XG4gICAgICAgICAgICBleHBvcnRzLm5lZWRzQnJpZGdlID0gZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciB3aW4gPSBfcmVmLndpbiwgZG9tYWluID0gX3JlZi5kb21haW47XG4gICAgICAgICAgICAgICAgaWYgKCFuZWVkc0JyaWRnZUZvckJyb3dzZXIoKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiYgIW5lZWRzQnJpZGdlRm9yRG9tYWluKGRvbWFpbiwgd2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmICh3aW4gJiYgIW5lZWRzQnJpZGdlRm9yV2luKHdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRCcmlkZ2VOYW1lID0gZ2V0QnJpZGdlTmFtZTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNCcmlkZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih3aW5kb3cubmFtZSAmJiB3aW5kb3cubmFtZSA9PT0gZ2V0QnJpZGdlTmFtZSgoMCwgX3NyYzMuZ2V0RG9tYWluKSgpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5yZWdpc3RlclJlbW90ZVdpbmRvdyA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlbW90ZVdpbmRvd3Muc2V0KHdpbiwge1xuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZVByb21pc2U6IG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZmluZFJlbW90ZVdpbmRvdyA9IGZpbmRSZW1vdGVXaW5kb3c7XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2lzdGVyUmVtb3RlU2VuZE1lc3NhZ2UgPSBmdW5jdGlvbih3aW4sIGRvbWFpbiwgc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlV2luZG93ID0gZmluZFJlbW90ZVdpbmRvdyh3aW4pO1xuICAgICAgICAgICAgICAgIGlmICghcmVtb3RlV2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgbm90IGZvdW5kIHRvIHJlZ2lzdGVyIHNlbmRNZXNzYWdlIHRvXCIpO1xuICAgICAgICAgICAgICAgIHZhciBzZW5kTWVzc2FnZVdyYXBwZXIgPSBmdW5jdGlvbihyZW1vdGVXaW4sIG1lc3NhZ2UsIHJlbW90ZURvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlV2luICE9PSB3aW4pIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB3aW5kb3cgZG9lcyBub3QgbWF0Y2ggd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMy5tYXRjaERvbWFpbikocmVtb3RlRG9tYWluLCBkb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZW1vdGUgZG9tYWluIFwiICsgcmVtb3RlRG9tYWluICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZW1vdGVXaW5kb3cuc2VuZE1lc3NhZ2VQcm9taXNlLnJlc29sdmUoc2VuZE1lc3NhZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZW1vdGVXaW5kb3cuc2VuZE1lc3NhZ2VQcm9taXNlID0gX3NyYzIuWmFsZ29Qcm9taXNlLnJlc29sdmUoc2VuZE1lc3NhZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlamVjdFJlbW90ZVNlbmRNZXNzYWdlID0gZnVuY3Rpb24od2luLCBlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlV2luZG93ID0gZmluZFJlbW90ZVdpbmRvdyh3aW4pO1xuICAgICAgICAgICAgICAgIGlmICghcmVtb3RlV2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgbm90IGZvdW5kIG9uIHdoaWNoIHRvIHJlamVjdCBzZW5kTWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICByZW1vdGVXaW5kb3cuc2VuZE1lc3NhZ2VQcm9taXNlLmFzeW5jUmVqZWN0KGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zZW5kQnJpZGdlTWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgbWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2luZ0NoaWxkID0gKDAsIF9zcmMzLmlzT3BlbmVyKSh3aW5kb3csIHdpbiksIG1lc3NhZ2luZ1BhcmVudCA9ICgwLCBfc3JjMy5pc09wZW5lcikod2luLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnaW5nQ2hpbGQgJiYgIW1lc3NhZ2luZ1BhcmVudCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgc2VuZCBtZXNzYWdlcyB0byBhbmQgZnJvbSBwYXJlbnQgYW5kIHBvcHVwIHdpbmRvd3NcIik7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZVdpbmRvdyA9IGZpbmRSZW1vdGVXaW5kb3cod2luKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbW90ZVdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IG5vdCBmb3VuZCB0byBzZW5kIG1lc3NhZ2UgdG9cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVdpbmRvdy5zZW5kTWVzc2FnZVByb21pc2UudGhlbihmdW5jdGlvbihzZW5kTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZE1lc3NhZ2Uod2luLCBtZXNzYWdlLCBkb21haW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBuZWVkc0JyaWRnZUZvckJyb3dzZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKDAsIF9zcmMzLmdldFVzZXJBZ2VudCkod2luZG93KS5tYXRjaCgvTVNJRXx0cmlkZW50fGVkZ2VcXC8xMnxlZGdlXFwvMTMvaSkgfHwgIV9jb25mLkNPTkZJRy5BTExPV19QT1NUTUVTU0FHRV9QT1BVUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG5lZWRzQnJpZGdlRm9yV2luKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhKDAsIF9zcmMzLmlzU2FtZVRvcFdpbmRvdykod2luZG93LCB3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbmVlZHNCcmlkZ2VGb3JEb21haW4oZG9tYWluLCB3aW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzMuZ2V0RG9tYWluKSgpICE9PSAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkoZG9tYWluKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luICYmICEoMCwgX3NyYzMuaXNTYW1lRG9tYWluKSh3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QnJpZGdlTmFtZShkb21haW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkRG9tYWluID0gKGRvbWFpbiA9IGRvbWFpbiB8fCAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkoZG9tYWluKSkucmVwbGFjZSgvW15hLXpBLVowLTldKy9nLCBcIl9cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25mLkNPTlNUQU5UUy5CUklER0VfTkFNRV9QUkVGSVggKyBcIl9cIiArIHNhbml0aXplZERvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuZG9jdW1lbnRCb2R5UmVhZHkgPSBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUod2luZG93LmRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZW1vdGVXaW5kb3dzID0gX2dsb2JhbC5nbG9iYWwucmVtb3RlV2luZG93cyB8fCBuZXcgX3NyYy5XZWFrTWFwKCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5kUmVtb3RlV2luZG93KHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC5yZW1vdGVXaW5kb3dzLmdldCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2NoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9jaGlsZC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jaGlsZCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvY29tbW9uLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbW1vbikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29tbW9uW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9wYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL3BhcmVudC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9wYXJlbnQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3BhcmVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvYnJpZGdlLmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9pbnRlcmZhY2UuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9pbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvaW5kZXguanNcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvcGVuQnJpZGdlXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm9wZW5CcmlkZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsaW5rVXJsXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4LmxpbmtVcmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0JyaWRnZVwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbmRleC5pc0JyaWRnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5lZWRzQnJpZGdlXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm5lZWRzQnJpZGdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmVlZHNCcmlkZ2VGb3JCcm93c2VyXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm5lZWRzQnJpZGdlRm9yQnJvd3NlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhhc0JyaWRnZVwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbmRleC5oYXNCcmlkZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuZWVkc0JyaWRnZUZvcldpblwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbmRleC5uZWVkc0JyaWRnZUZvcldpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5lZWRzQnJpZGdlRm9yRG9tYWluXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm5lZWRzQnJpZGdlRm9yRG9tYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwib3BlblR1bm5lbFRvT3BlbmVyXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm9wZW5UdW5uZWxUb09wZW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlc3Ryb3lCcmlkZ2VzXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4LmRlc3Ryb3lCcmlkZ2VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9wYXJlbnQuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5oYXNCcmlkZ2UgPSBmdW5jdGlvbih1cmwsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9IGRvbWFpbiB8fCAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkodXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzW2RvbWFpbl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMub3BlbkJyaWRnZSA9IGZ1bmN0aW9uKHVybCwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluIHx8ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKSh1cmwpO1xuICAgICAgICAgICAgICAgIGlmIChfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzW2RvbWFpbl0pIHJldHVybiBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzW2RvbWFpbl07XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuYnJpZGdlc1tkb21haW5dID0gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMy5nZXREb21haW4pKCkgPT09IGRvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBvcGVuIGJyaWRnZSBvbiB0aGUgc2FtZSBkb21haW4gYXMgY3VycmVudCBkb21haW46IFwiICsgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSAoMCwgX2NvbW1vbi5nZXRCcmlkZ2VOYW1lKShkb21haW4pLCBmcmFtZSA9ICgwLCBfc3JjMy5nZXRGcmFtZUJ5TmFtZSkod2luZG93LCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJGcmFtZSB3aXRoIG5hbWUgXCIgKyBuYW1lICsgXCIgYWxyZWFkeSBleGlzdHMgb24gcGFnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGZ1bmN0aW9uKG5hbWUsIHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xpYi5sb2cuZGVidWcoXCJPcGVuaW5nIGJyaWRnZTpcIiwgbmFtZSwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiaWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJkaXNwbGF5OiBub25lOyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGJvcmRlcjogMHB4IG5vbmU7IG92ZXJmbG93OiBoaWRkZW47XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImZyYW1lYm9yZGVyXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJib3JkZXJcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcInNjcm9sbGluZ1wiLCBcIm5vXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImFsbG93VHJhbnNwYXJlbmN5XCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KG5hbWUsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZUZyYW1lc1tkb21haW5dID0gaWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbW1vbi5kb2N1bWVudEJvZHlSZWFkeS50aGVuKGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicmlkZ2UgPSBpZnJhbWUuY29udGVudFdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihzb3VyY2UsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm9uKF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfTkFNRVMuT1BFTl9UVU5ORUwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gX3JlZi5vcmlnaW4sIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiRG9tYWluIFwiICsgZG9tYWluICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLm5hbWUpIHRocm93IG5ldyBFcnJvcihcIlJlZ2lzdGVyIHdpbmRvdyBleHBlY3RlZCB0byBiZSBwYXNzZWQgd2luZG93IG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5zZW5kTWVzc2FnZSkgdGhyb3cgbmV3IEVycm9yKFwiUmVnaXN0ZXIgd2luZG93IGV4cGVjdGVkIHRvIGJlIHBhc3NlZCBzZW5kTWVzc2FnZSBtZXRob2RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW2RhdGEubmFtZV0pIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyB3aXRoIG5hbWUgXCIgKyBkYXRhLm5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdCwgb3Igd2FzIG5vdCBvcGVuZWQgYnkgdGhpcyB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW2RhdGEubmFtZV0uZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJXZSBkbyBub3QgaGF2ZSBhIHJlZ2lzdGVyZWQgZG9tYWluIGZvciB3aW5kb3cgXCIgKyBkYXRhLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW2RhdGEubmFtZV0uZG9tYWluICE9PSBvcmlnaW4pIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2Ugb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2hlZCByZWdpc3RlcmVkIHdpbmRvdyBvcmlnaW4gXCIgKyBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXS5kb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2NvbW1vbi5yZWdpc3RlclJlbW90ZVNlbmRNZXNzYWdlKShfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXS53aW4sIGRvbWFpbiwgZGF0YS5zZW5kTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cgJiYgIXdpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbkRldGFpbHMgPSBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbkRldGFpbHMpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWNlaXZlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHdpbkRldGFpbHMuZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luRGV0YWlscy53aW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zcmMyLlphbGdvUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oYnJpZGdlLCBkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5vbkNoaWxkV2luZG93UmVhZHkpKGJyaWRnZSwgX2NvbmYuQ09ORklHLkJSSURHRV9USU1FT1VULCBcIkJyaWRnZSBcIiArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBicmlkZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXNbZG9tYWluXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmxpbmtVcmwgPSBmdW5jdGlvbih3aW4sIHVybCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5PcHRpb25zID0gX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlXaW4uZ2V0KHdpbik7XG4gICAgICAgICAgICAgICAgaWYgKHdpbk9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luT3B0aW9ucy5kb21haW4gPSAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9jb21tb24ucmVnaXN0ZXJSZW1vdGVXaW5kb3cpKHdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVzdHJveUJyaWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gT2JqZWN0LmtleXMoX2dsb2JhbC5nbG9iYWwuYnJpZGdlRnJhbWVzKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMCwgX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYzLCBmcmFtZSA9IF9nbG9iYWwuZ2xvYmFsLmJyaWRnZUZyYW1lc1tkb21haW5dO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5wYXJlbnROb2RlICYmIGZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VGcmFtZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzID0ge307XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIiksIF9jb21tb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2NvbW1vbi5qc1wiKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXMgPSBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzIHx8IHt9O1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuYnJpZGdlRnJhbWVzID0gX2dsb2JhbC5nbG9iYWwuYnJpZGdlRnJhbWVzIHx8IHt9O1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlXaW4gPSBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbiB8fCBuZXcgX3NyYy5XZWFrTWFwKCk7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWUgPSBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWUgfHwge307XG4gICAgICAgICAgICB2YXIgd2luZG93T3BlbiA9IHdpbmRvdy5vcGVuO1xuICAgICAgICAgICAgd2luZG93Lm9wZW4gPSBmdW5jdGlvbih1cmwsIG5hbWUsIG9wdGlvbnMsIGxhc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdXJsO1xuICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgMCA9PT0gdXJsLmluZGV4T2YoX2NvbmYuQ09OU1RBTlRTLk1PQ0tfUFJPVE9DT0wpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdXJsJHNwbGl0ID0gdXJsLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gX3VybCRzcGxpdFswXTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gX3VybCRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9tYWluICYmIChkb21haW4gPSAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkoZG9tYWluKSk7XG4gICAgICAgICAgICAgICAgdmFyIHdpbiA9IHdpbmRvd09wZW4uY2FsbCh0aGlzLCB1cmwsIG5hbWUsIG9wdGlvbnMsIGxhc3QpO1xuICAgICAgICAgICAgICAgIGlmICghd2luKSByZXR1cm4gd2luO1xuICAgICAgICAgICAgICAgIHVybCAmJiAoMCwgX2NvbW1vbi5yZWdpc3RlclJlbW90ZVdpbmRvdykod2luKTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc3JjMy5pc1dpbmRvd0Nsb3NlZCkoX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW3dpbk5hbWVdLndpbikgJiYgZGVsZXRlIF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZVt3aW5OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgd2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5PcHRpb25zID0gX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlXaW4uZ2V0KHdpbikgfHwgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW25hbWVdIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB3aW5PcHRpb25zLm5hbWUgPSB3aW5PcHRpb25zLm5hbWUgfHwgbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgd2luT3B0aW9ucy53aW4gPSB3aW5PcHRpb25zLndpbiB8fCB3aW47XG4gICAgICAgICAgICAgICAgICAgIHdpbk9wdGlvbnMuZG9tYWluID0gd2luT3B0aW9ucy5kb21haW4gfHwgZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbi5zZXQod2luLCB3aW5PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW25hbWVdID0gd2luT3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY2xlYW4uanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5jbGVhblVwV2luZG93ID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RQcm9taXNlcyA9IF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RQcm9taXNlcy5nZXQod2luKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdFByb21pc2VzKSBmb3IgKHZhciBfaXRlcmF0b3IgPSByZXF1ZXN0UHJvbWlzZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgZnJvbSB3aW5kb3cgLSBjbGVhbmVkIHVwXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlXaW4gJiYgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlXaW4uZGVsZXRlKHdpbik7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVtb3RlV2luZG93cyAmJiBfZ2xvYmFsLmdsb2JhbC5yZW1vdGVXaW5kb3dzLmRlbGV0ZSh3aW4pO1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RQcm9taXNlcy5kZWxldGUod2luKTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5tZXRob2RzLmRlbGV0ZSh3aW4pO1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlYWR5UHJvbWlzZXMuZGVsZXRlKHdpbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICB2YXIgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29tcGF0L2llLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZW11bGF0ZUlFUmVzdHJpY3Rpb25zID0gZnVuY3Rpb24oc291cmNlV2luZG93LCB0YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9jb25mLkNPTkZJRy5BTExPV19QT1NUTUVTU0FHRV9QT1BVUCAmJiAhMSA9PT0gKDAsIF9zcmMuaXNTYW1lVG9wV2luZG93KShzb3VyY2VXaW5kb3csIHRhcmdldFdpbmRvdykpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2VuZCBhbmQgcmVjZWl2ZSBwb3N0IG1lc3NhZ2VzIGJldHdlZW4gdHdvIGRpZmZlcmVudCB3aW5kb3dzIChkaXNhYmxlZCB0byBlbXVsYXRlIElFKVwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbXBhdC9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2llID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbXBhdC9pZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9jb25maWcuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5DT05GSUcgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX0FMTE9XRURfUE9TVF9NRVNTQUdFLCBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvY29uc3RhbnRzLmpzXCIpLCBDT05GSUcgPSBleHBvcnRzLkNPTkZJRyA9IHtcbiAgICAgICAgICAgICAgICBBTExPV19QT1NUTUVTU0FHRV9QT1BVUDogIShcIl9fQUxMT1dfUE9TVE1FU1NBR0VfUE9QVVBfX1wiIGluIHdpbmRvdykgfHwgd2luZG93Ll9fQUxMT1dfUE9TVE1FU1NBR0VfUE9QVVBfXyxcbiAgICAgICAgICAgICAgICBMT0dfTEVWRUw6IFwiaW5mb1wiLFxuICAgICAgICAgICAgICAgIEJSSURHRV9USU1FT1VUOiA1ZTMsXG4gICAgICAgICAgICAgICAgQ0hJTERfV0lORE9XX1RJTUVPVVQ6IDVlMyxcbiAgICAgICAgICAgICAgICBBQ0tfVElNRU9VVDogLTEgIT09IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFL2kpID8gMmUzIDogMWUzLFxuICAgICAgICAgICAgICAgIFJFU19USU1FT1VUOiAtMSxcbiAgICAgICAgICAgICAgICBMT0dfVE9fUEFHRTogITEsXG4gICAgICAgICAgICAgICAgQUxMT1dFRF9QT1NUX01FU1NBR0VfTUVUSE9EUzogKF9BTExPV0VEX1BPU1RfTUVTU0FHRSA9IHt9LCBfQUxMT1dFRF9QT1NUX01FU1NBR0VbX2NvbnN0YW50cy5DT05TVEFOVFMuU0VORF9TVFJBVEVHSUVTLlBPU1RfTUVTU0FHRV0gPSAhMCwgXG4gICAgICAgICAgICAgICAgX0FMTE9XRURfUE9TVF9NRVNTQUdFW19jb25zdGFudHMuQ09OU1RBTlRTLlNFTkRfU1RSQVRFR0lFUy5CUklER0VdID0gITAsIF9BTExPV0VEX1BPU1RfTUVTU0FHRVtfY29uc3RhbnRzLkNPTlNUQU5UUy5TRU5EX1NUUkFURUdJRVMuR0xPQkFMXSA9ICEwLCBcbiAgICAgICAgICAgICAgICBfQUxMT1dFRF9QT1NUX01FU1NBR0UpLFxuICAgICAgICAgICAgICAgIEFMTE9XX1NBTUVfT1JJR0lOOiAhMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIDAgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoX2NvbnN0YW50cy5DT05TVEFOVFMuRklMRV9QUk9UT0NPTCkgJiYgKENPTkZJRy5BTExPV19QT1NUTUVTU0FHRV9QT1BVUCA9ICEwKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2NvbnN0YW50cy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLkNPTlNUQU5UUyA9IHtcbiAgICAgICAgICAgICAgICBQT1NUX01FU1NBR0VfVFlQRToge1xuICAgICAgICAgICAgICAgICAgICBSRVFVRVNUOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3JlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgUkVTUE9OU0U6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgQUNLOiBcInBvc3Ryb2JvdF9tZXNzYWdlX2Fja1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQT1NUX01FU1NBR0VfQUNLOiB7XG4gICAgICAgICAgICAgICAgICAgIFNVQ0NFU1M6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICBFUlJPUjogXCJlcnJvclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQT1NUX01FU1NBR0VfTkFNRVM6IHtcbiAgICAgICAgICAgICAgICAgICAgTUVUSE9EOiBcInBvc3Ryb2JvdF9tZXRob2RcIixcbiAgICAgICAgICAgICAgICAgICAgSEVMTE86IFwicG9zdHJvYm90X3JlYWR5XCIsXG4gICAgICAgICAgICAgICAgICAgIE9QRU5fVFVOTkVMOiBcInBvc3Ryb2JvdF9vcGVuX3R1bm5lbFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBXSU5ET1dfVFlQRVM6IHtcbiAgICAgICAgICAgICAgICAgICAgRlVMTFBBR0U6IFwiZnVsbHBhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgUE9QVVA6IFwicG9wdXBcIixcbiAgICAgICAgICAgICAgICAgICAgSUZSQU1FOiBcImlmcmFtZVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBXSU5ET1dfUFJPUFM6IHtcbiAgICAgICAgICAgICAgICAgICAgUE9TVFJPQk9UOiBcIl9fcG9zdFJvYm90X19cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgU0VSSUFMSVpBVElPTl9UWVBFUzoge1xuICAgICAgICAgICAgICAgICAgICBNRVRIT0Q6IFwicG9zdHJvYm90X21ldGhvZFwiLFxuICAgICAgICAgICAgICAgICAgICBFUlJPUjogXCJwb3N0cm9ib3RfZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgUFJPTUlTRTogXCJwb3N0cm9ib3RfcHJvbWlzZVwiLFxuICAgICAgICAgICAgICAgICAgICBaQUxHT19QUk9NSVNFOiBcInBvc3Ryb2JvdF96YWxnb19wcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFJFR0VYOiBcInJlZ2V4XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFNFTkRfU1RSQVRFR0lFUzoge1xuICAgICAgICAgICAgICAgICAgICBQT1NUX01FU1NBR0U6IFwicG9zdHJvYm90X3Bvc3RfbWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICBCUklER0U6IFwicG9zdHJvYm90X2JyaWRnZVwiLFxuICAgICAgICAgICAgICAgICAgICBHTE9CQUw6IFwicG9zdHJvYm90X2dsb2JhbFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBNT0NLX1BST1RPQ09MOiBcIm1vY2s6XCIsXG4gICAgICAgICAgICAgICAgRklMRV9QUk9UT0NPTDogXCJmaWxlOlwiLFxuICAgICAgICAgICAgICAgIEJSSURHRV9OQU1FX1BSRUZJWDogXCJfX3Bvc3Ryb2JvdF9icmlkZ2VfX1wiLFxuICAgICAgICAgICAgICAgIFBPU1RST0JPVF9QUk9YWTogXCJfX3Bvc3Ryb2JvdF9wcm94eV9fXCIsXG4gICAgICAgICAgICAgICAgV0lMRENBUkQ6IFwiKlwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIFBPU1RfTUVTU0FHRV9OQU1FUyA9IGV4cG9ydHMuUE9TVF9NRVNTQUdFX05BTUVTID0ge1xuICAgICAgICAgICAgICAgIE1FVEhPRDogXCJwb3N0cm9ib3RfbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgSEVMTE86IFwicG9zdHJvYm90X2hlbGxvXCIsXG4gICAgICAgICAgICAgICAgT1BFTl9UVU5ORUw6IFwicG9zdHJvYm90X29wZW5fdHVubmVsXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLlBPU1RfTUVTU0FHRV9OQU1FU19MSVNUID0gT2JqZWN0LmtleXMoUE9TVF9NRVNTQUdFX05BTUVTKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBPU1RfTUVTU0FHRV9OQU1FU1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2NvbmZpZy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb25maWcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvY29uc3RhbnRzLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbnN0YW50cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29uc3RhbnRzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9yZWNlaXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvcmVjZWl2ZS9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9yZWNlaXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWNlaXZlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9zZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvc2VuZC9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9zZW5kKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZW5kW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9saXN0ZW5lcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9saXN0ZW5lcnMuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfbGlzdGVuZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9saXN0ZW5lcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9saXN0ZW5lcnMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5yZXNldExpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlc3BvbnNlTGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVxdWVzdExpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkUmVzcG9uc2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhc2gsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVzcG9uc2VMaXN0ZW5lcnNbaGFzaF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFJlc3BvbnNlTGlzdGVuZXIgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLnJlc3BvbnNlTGlzdGVuZXJzW2hhc2hdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVsZXRlUmVzcG9uc2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2dsb2JhbC5nbG9iYWwucmVzcG9uc2VMaXN0ZW5lcnNbaGFzaF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5tYXJrUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzW2hhc2hdID0gITA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkID0gZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKF9nbG9iYWwuZ2xvYmFsLmVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1toYXNoXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRSZXF1ZXN0TGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXI7XG4gICAgICAgICAgICBleHBvcnRzLmFkZFJlcXVlc3RMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZFJlcXVlc3RMaXN0ZW5lcihfcmVmNSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWY1Lm5hbWUsIHdpbiA9IF9yZWY1LndpbiwgZG9tYWluID0gX3JlZjUuZG9tYWluO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBuYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIHJlcXVpcmVkIHRvIGFkZCByZXF1ZXN0IGxpc3RlbmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdLCBfaXRlcmF0b3IyID0gd2luLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTMgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjYgPSBfaXRlcmF0b3IyW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjYgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9yZWY2O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGxpc3RlbmVyc0NvbGxlY3Rpb24sIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pNCA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY3ID0gX2l0ZXJhdG9yM1tfaTQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNCA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY3ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxMaXN0ZW5lciA9IF9yZWY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxMaXN0ZW5lci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXSwgX2l0ZXJhdG9yNCA9IGRvbWFpbiwgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k1ID0gMCwgX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yNFtfaTUrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k1ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2k1LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVtID0gX3JlZjg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IF9pdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjUgPSBfbGlzdGVuZXJzQ29sbGVjdGlvbiwgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k2ID0gMCwgX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/IF9pdGVyYXRvcjUgOiBfaXRlcmF0b3I1W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTYgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjkgPSBfaXRlcmF0b3I1W19pNisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k2ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjkgPSBfaTYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbExpc3RlbmVyID0gX3JlZjk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbExpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3aW4gJiYgd2luICE9PSBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQgfHwgKHdpbiA9IF9nbG9iYWwuZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCk7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluIHx8IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRDtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdMaXN0ZW5lcikgdGhyb3cgd2luICYmIGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpICsgXCIgZm9yIFwiICsgKHdpbiA9PT0gX2dsb2JhbC5nbG9iYWwuV0lORE9XX1dJTERDQVJEID8gXCJ3aWxkY2FyZFwiIDogXCJzcGVjaWZpZWRcIikgKyBcIiB3aW5kb3dcIikgOiB3aW4gPyBuZXcgRXJyb3IoXCJSZXF1ZXN0IGxpc3RlbmVyIGFscmVhZHkgZXhpc3RzIGZvciBcIiArIG5hbWUgKyBcIiBmb3IgXCIgKyAod2luID09PSBfZ2xvYmFsLmdsb2JhbC5XSU5ET1dfV0lMRENBUkQgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpKSA6IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3RMaXN0ZW5lcnMgPSBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0TGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZUxpc3RlbmVycyA9IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyc1tuYW1lXSA9IG5hbWVMaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3aW5MaXN0ZW5lcnMgPSBuYW1lTGlzdGVuZXJzLmdldCh3aW4pO1xuICAgICAgICAgICAgICAgIGlmICghd2luTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbkxpc3RlbmVycyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdGVuZXJzLnNldCh3aW4sIHdpbkxpc3RlbmVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdHJEb21haW4gPSBkb21haW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhMaXN0ZW5lcnMgPSB3aW5MaXN0ZW5lcnNbX19ET01BSU5fUkVHRVhfX107XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4TGlzdGVuZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfbGliLmlzUmVnZXgpKGRvbWFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWdleExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbkxpc3RlbmVyc1tfX0RPTUFJTl9SRUdFWF9fXSA9IHJlZ2V4TGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4TGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleDogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4TGlzdGVuZXJzLnB1c2gocmVnZXhMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHdpbkxpc3RlbmVyc1tzdHJEb21haW5dID0gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5MaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luTGlzdGVuZXJzW3N0ckRvbWFpbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luICYmIDAgPT09IE9iamVjdC5rZXlzKHdpbkxpc3RlbmVycykubGVuZ3RoICYmIG5hbWVMaXN0ZW5lcnMuZGVsZXRlKHdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lciAmJiByZWdleExpc3RlbmVycy5zcGxpY2UocmVnZXhMaXN0ZW5lcnMuaW5kZXhPZihyZWdleExpc3RlbmVyLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIik7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZXNwb25zZUxpc3RlbmVycyA9IF9nbG9iYWwuZ2xvYmFsLnJlc3BvbnNlTGlzdGVuZXJzIHx8IHt9O1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVxdWVzdExpc3RlbmVycyA9IF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RMaXN0ZW5lcnMgfHwge307XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5XSU5ET1dfV0lMRENBUkQgPSBfZ2xvYmFsLmdsb2JhbC5XSU5ET1dfV0lMRENBUkQgfHwgbmV3IGZ1bmN0aW9uKCkge30oKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLmVycm9yZWRSZXNwb25zZUxpc3RlbmVycyA9IF9nbG9iYWwuZ2xvYmFsLmVycm9yZWRSZXNwb25zZUxpc3RlbmVycyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBfX0RPTUFJTl9SRUdFWF9fID0gXCJfX2RvbWFpbl9yZWdleF9fXCI7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRSZXF1ZXN0TGlzdGVuZXIoX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLCB3aW4gPSBfcmVmLndpbiwgZG9tYWluID0gX3JlZi5kb21haW47XG4gICAgICAgICAgICAgICAgd2luID09PSBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQgJiYgKHdpbiA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGRvbWFpbiA9PT0gX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEICYmIChkb21haW4gPSBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gZ2V0IHJlcXVlc3QgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0TGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lTGlzdGVuZXJzKSBmb3IgKHZhciBfYXJyID0gWyB3aW4sIF9nbG9iYWwuZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCBdLCBfaSA9IDA7IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpblF1YWxpZmllciA9IF9hcnJbX2ldLCB3aW5MaXN0ZW5lcnMgPSB3aW5RdWFsaWZpZXIgJiYgbmFtZUxpc3RlbmVycy5nZXQod2luUXVhbGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbkxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luTGlzdGVuZXJzW2RvbWFpbl0pIHJldHVybiB3aW5MaXN0ZW5lcnNbZG9tYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luTGlzdGVuZXJzW19fRE9NQUlOX1JFR0VYX19dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSB3aW5MaXN0ZW5lcnNbX19ET01BSU5fUkVHRVhfX10sIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kyID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQgPSBfcmVmMywgcmVnZXggPSBfcmVmNC5yZWdleCwgbGlzdGVuZXIgPSBfcmVmNC5saXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzIubWF0Y2hEb21haW4pKHJlZ2V4LCBkb21haW4pKSByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luTGlzdGVuZXJzW19jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRF0pIHJldHVybiB3aW5MaXN0ZW5lcnNbX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3JlY2VpdmUvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMucmVjZWl2ZU1lc3NhZ2UgPSByZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgICAgIGV4cG9ydHMubWVzc2FnZUxpc3RlbmVyID0gbWVzc2FnZUxpc3RlbmVyO1xuICAgICAgICAgICAgZXhwb3J0cy5saXN0ZW5Gb3JNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICgwLCBfbGliLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgXCJtZXNzYWdlXCIsIG1lc3NhZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpLCBfdHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9yZWNlaXZlL3R5cGVzLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVjZWl2ZWRNZXNzYWdlcyA9IF9nbG9iYWwuZ2xvYmFsLnJlY2VpdmVkTWVzc2FnZXMgfHwgW107XG4gICAgICAgICAgICBmdW5jdGlvbiByZWNlaXZlTWVzc2FnZShldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93IHx8IHdpbmRvdy5jbG9zZWQpIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgcmVjaWV2ZWQgaW4gY2xvc2VkIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LnNvdXJjZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UsIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbiwgbWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZE1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gKDAsIF9saWIuanNvblBhcnNlKShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UgJiYgXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gcGFyc2VkTWVzc2FnZSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHBhcnNlZE1lc3NhZ2UpKSAmJiBudWxsICE9PSBwYXJzZWRNZXNzYWdlICYmIChwYXJzZWRNZXNzYWdlID0gcGFyc2VkTWVzc2FnZVtfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0pICYmIFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IHBhcnNlZE1lc3NhZ2UgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihwYXJzZWRNZXNzYWdlKSkgJiYgbnVsbCAhPT0gcGFyc2VkTWVzc2FnZSAmJiBwYXJzZWRNZXNzYWdlLnR5cGUgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGFyc2VkTWVzc2FnZS50eXBlICYmIF90eXBlcy5SRUNFSVZFX01FU1NBR0VfVFlQRVNbcGFyc2VkTWVzc2FnZS50eXBlXSkgcmV0dXJuIHBhcnNlZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2Uuc291cmNlRG9tYWluIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG1lc3NhZ2Uuc291cmNlRG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtZXNzYWdlIHRvIGhhdmUgc291cmNlRG9tYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICAwICE9PSBtZXNzYWdlLnNvdXJjZURvbWFpbi5pbmRleE9mKF9jb25mLkNPTlNUQU5UUy5NT0NLX1BST1RPQ09MKSAmJiAwICE9PSBtZXNzYWdlLnNvdXJjZURvbWFpbi5pbmRleE9mKF9jb25mLkNPTlNUQU5UUy5GSUxFX1BST1RPQ09MKSB8fCAob3JpZ2luID0gbWVzc2FnZS5zb3VyY2VEb21haW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9nbG9iYWwuZ2xvYmFsLnJlY2VpdmVkTWVzc2FnZXMuaW5kZXhPZihtZXNzYWdlLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVjZWl2ZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSAtMSAhPT0gX2NvbmYuUE9TVF9NRVNTQUdFX05BTUVTX0xJU1QuaW5kZXhPZihtZXNzYWdlLm5hbWUpIHx8IG1lc3NhZ2UudHlwZSA9PT0gX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9UWVBFLkFDSyA/IFwiZGVidWdcIiA6IFwiZXJyb3JcIiA9PT0gbWVzc2FnZS5hY2sgPyBcImVycm9yXCIgOiBcImluZm9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIubG9nLmxvZ0xldmVsKGxldmVsLCBbIFwiXFxuXFxuXFx0XCIsIFwiI3JlY2VpdmVcIiwgbWVzc2FnZS50eXBlLnJlcGxhY2UoL15wb3N0cm9ib3RfbWVzc2FnZV8vLCBcIlwiKSwgXCI6OlwiLCBtZXNzYWdlLm5hbWUsIFwiOjpcIiwgb3JpZ2luLCBcIlxcblxcblwiLCBtZXNzYWdlIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkoc291cmNlKSB8fCBtZXNzYWdlLmZpcmVBbmRGb3JnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgJiYgKG1lc3NhZ2UuZGF0YSA9ICgwLCBfbGliLmRlc2VyaWFsaXplTWV0aG9kcykoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90eXBlcy5SRUNFSVZFX01FU1NBR0VfVFlQRVNbbWVzc2FnZS50eXBlXShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgX2xpYi5sb2cuZGVidWcoXCJTb3VyY2Ugd2luZG93IGlzIGNsb3NlZCAtIGNhbiBub3Qgc2VuZCBcIiArIG1lc3NhZ2UudHlwZSArIFwiIFwiICsgbWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1lc3NhZ2VMaXN0ZW5lcihldmVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLm5vb3ApKGV2ZW50LnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBldmVudC5zb3VyY2UgfHwgZXZlbnQuc291cmNlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBldmVudC5vcmlnaW4gfHwgZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50Lm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbXBhdC9pbmRleC5qc1wiKS5lbXVsYXRlSUVSZXN0cmljdGlvbnMobWVzc2FnZUV2ZW50LnNvdXJjZSwgd2luZG93KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlTWVzc2FnZShtZXNzYWdlRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVjZWl2ZU1lc3NhZ2UgPSByZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3JlY2VpdmUvdHlwZXMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5SRUNFSVZFX01FU1NBR0VfVFlQRVMgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX1JFQ0VJVkVfTUVTU0FHRV9UWVBFLCBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9LCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX3NlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9zZW5kL2luZGV4LmpzXCIpLCBfbGlzdGVuZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvbGlzdGVuZXJzLmpzXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy5SRUNFSVZFX01FU1NBR0VfVFlQRVMgPSAoKF9SRUNFSVZFX01FU1NBR0VfVFlQRSA9IHt9KVtfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuQUNLXSA9IGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgX2xpc3RlbmVycy5pc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKShtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gKDAsIF9saXN0ZW5lcnMuZ2V0UmVzcG9uc2VMaXN0ZW5lcikobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgYWNrIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIubWF0Y2hEb21haW4pKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJBY2sgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNrID0gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX1JFQ0VJVkVfTUVTU0FHRV9UWVBFW19jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5SRVFVRVNUXSA9IGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAoMCwgX2xpc3RlbmVycy5nZXRSZXF1ZXN0TGlzdGVuZXIpKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW46IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNwb25kKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UuZmlyZUFuZEZvcmdldCB8fCAoMCwgX3NyYzIuaXNXaW5kb3dDbG9zZWQpKHNvdXJjZSkgPyBfc3JjLlphbGdvUHJvbWlzZS5yZXNvbHZlKCkgOiAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9zZW5kLnNlbmRNZXNzYWdlKShzb3VyY2UsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogbWVzc2FnZS5vcmlnaW5hbFNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IG1lc3NhZ2UuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZVxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRhKSwgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLmFsbChbIHJlc3BvbmQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuQUNLXG4gICAgICAgICAgICAgICAgfSksIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3Qgb3JpZ2luIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggZG9tYWluIFwiICsgb3B0aW9ucy5kb21haW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5oYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2s6IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfQUNLLlNVQ0NFU1MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKS5yZXBsYWNlKC9eRXJyb3I6IC8sIFwiXCIpLCBjb2RlID0gZXJyLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjazogX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9BQ0suRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pIF0pLnRoZW4oX2xpYi5ub29wKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYW5kbGVFcnJvcikgcmV0dXJuIG9wdGlvbnMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgX2xpYi5sb2cuZXJyb3IoKDAsIF9saWIuc3RyaW5naWZ5RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgX1JFQ0VJVkVfTUVTU0FHRV9UWVBFW19jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5SRVNQT05TRV0gPSBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIF9saXN0ZW5lcnMuaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZCkobWVzc2FnZS5oYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICgwLCBfbGlzdGVuZXJzLmdldFJlc3BvbnNlTGlzdGVuZXIpKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlIHJlc3BvbnNlIGZvciBtZXNzYWdlOiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIGZyb20gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIubWF0Y2hEb21haW4pKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9zcmMyLnN0cmluZ2lmeURvbWFpblBhdHRlcm4pKG9wdGlvbnMuZG9tYWluKSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGlzdGVuZXJzLmRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIpKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmFjayA9PT0gX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9BQ0suRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGUgJiYgKGVyci5jb2RlID0gbWVzc2FnZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlc3BvbmQoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5hY2sgPT09IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfQUNLLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWVzc2FnZS5kYXRhIHx8IG1lc3NhZ2UucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXNwb25kKG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9SRUNFSVZFX01FU1NBR0VfVFlQRSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9zZW5kL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgbWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfanNvblN0cmluZ2lmeTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9LCBpZCA9ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIudW5pcXVlSUQpKCksIHR5cGUgPSAoMCwgX2xpYi5nZXRXaW5kb3dUeXBlKSgpLCBzb3VyY2VEb21haW4gPSAoMCwgX3NyYy5nZXREb21haW4pKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VEb21haW46IHNvdXJjZURvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dUeXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSh3aW4sIG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICgwLCBfbGliLnNlcmlhbGl6ZU1ldGhvZHMpKHdpbiwgZG9tYWluLCBtZXNzYWdlLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZXZlbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwgPSAtMSAhPT0gX2NvbmYuUE9TVF9NRVNTQUdFX05BTUVTX0xJU1QuaW5kZXhPZihtZXNzYWdlLm5hbWUpIHx8IG1lc3NhZ2UudHlwZSA9PT0gX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9UWVBFLkFDSyA/IFwiZGVidWdcIiA6IFwiZXJyb3JcIiA9PT0gbWVzc2FnZS5hY2sgPyBcImVycm9yXCIgOiBcImluZm9cIjtcbiAgICAgICAgICAgICAgICAgICAgX2xpYi5sb2cubG9nTGV2ZWwobGV2ZWwsIFsgXCJcXG5cXG5cXHRcIiwgXCIjc2VuZFwiLCBtZXNzYWdlLnR5cGUucmVwbGFjZSgvXnBvc3Ryb2JvdF9tZXNzYWdlXy8sIFwiXCIpLCBcIjo6XCIsIG1lc3NhZ2UubmFtZSwgXCI6OlwiLCBkb21haW4gfHwgX2NvbmYuQ09OU1RBTlRTLldJTERDQVJELCBcIlxcblxcblwiLCBtZXNzYWdlIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cgJiYgIV9jb25mLkNPTkZJRy5BTExPV19TQU1FX09SSUdJTikgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1waW5nIHRvIHNlbmQgbWVzc2FnZSB0byBzZWxmXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMuaXNXaW5kb3dDbG9zZWQpKHdpbikpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIF9saWIubG9nLmRlYnVnKFwiUnVubmluZyBzZW5kIG1lc3NhZ2Ugc3RyYXRlZ2llc1wiLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gW10sIHNlcmlhbGl6ZWRNZXNzYWdlID0gKDAsIF9saWIuanNvblN0cmluZ2lmeSkoKChfanNvblN0cmluZ2lmeSA9IHt9KVtfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0gPSBtZXNzYWdlLCBcbiAgICAgICAgICAgICAgICAgICAgX2pzb25TdHJpbmdpZnkpLCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS5tYXAoT2JqZWN0LmtleXMoX3N0cmF0ZWdpZXMuU0VORF9NRVNTQUdFX1NUUkFURUdJRVMpLCBmdW5jdGlvbihzdHJhdGVneU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2NvbmYuQ09ORklHLkFMTE9XRURfUE9TVF9NRVNTQUdFX01FVEhPRFNbc3RyYXRlZ3lOYW1lXSkgdGhyb3cgbmV3IEVycm9yKFwiU3RyYXRlZ3kgZGlzYWxsb3dlZDogXCIgKyBzdHJhdGVneU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3RyYXRlZ2llcy5TRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tzdHJhdGVneU5hbWVdKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goc3RyYXRlZ3lOYW1lICsgXCI6IHN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChzdHJhdGVneU5hbWUgKyBcIjogXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gcmVzdWx0cy5zb21lKEJvb2xlYW4pLCBzdGF0dXMgPSBtZXNzYWdlLnR5cGUgKyBcIiBcIiArIG1lc3NhZ2UubmFtZSArIFwiIFwiICsgKHN1Y2Nlc3MgPyBcInN1Y2Nlc3NcIiA6IFwiZXJyb3JcIikgKyBcIjpcXG4gIC0gXCIgKyBtZXNzYWdlcy5qb2luKFwiXFxuICAtIFwiKSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbGliLmxvZy5kZWJ1ZyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB0aHJvdyBuZXcgRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2luZGV4LmpzXCIpLCBfc3RyYXRlZ2llcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3NlbmQvc3RyYXRlZ2llcy5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3NlbmQvc3RyYXRlZ2llcy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLlNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTID0gZXhwb3J0cy5TRU5EX01FU1NBR0VfU1RSQVRFR0lFUyA9IHt9O1xuICAgICAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVNbX2NvbmYuQ09OU1RBTlRTLlNFTkRfU1RSQVRFR0lFUy5QT1NUX01FU1NBR0VdID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbXBhdC9pbmRleC5qc1wiKS5lbXVsYXRlSUVSZXN0cmljdGlvbnMod2luZG93LCB3aW4pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGRvbWFpbikgPyBkb21haW4gOiBcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4gPyBbIGRvbWFpbiBdIDogWyBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQgXSkubWFwKGZ1bmN0aW9uKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gZG9tLmluZGV4T2YoX2NvbmYuQ09OU1RBTlRTLk1PQ0tfUFJPVE9DT0wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBfY29uZi5DT05TVEFOVFMuRklMRV9QUk9UT0NPTCkgcmV0dXJuIF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMuaXNBY3R1YWxseVNhbWVEb21haW4pKHdpbikpIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRpbmcgdG8gc2VuZCBtZXNzc2FnZSB0byBtb2NrIGRvbWFpbiBcIiArIGRvbSArIFwiLCBidXQgd2luZG93IGlzIGFjdHVhbGx5IGNyb3NzLWRvbWFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3NyYy5nZXRBY3R1YWxEb21haW4pKHdpbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT09IGRvbS5pbmRleE9mKF9jb25mLkNPTlNUQU5UUy5GSUxFX1BST1RPQ09MKSA/IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCA6IGRvbTtcbiAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luLnBvc3RNZXNzYWdlKHNlcmlhbGl6ZWRNZXNzYWdlLCBkb20pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvaW5kZXguanNcIiksIHNlbmRCcmlkZ2VNZXNzYWdlID0gX3JlcXVpcmUuc2VuZEJyaWRnZU1lc3NhZ2UsIG5lZWRzQnJpZGdlRm9yQnJvd3NlciA9IF9yZXF1aXJlLm5lZWRzQnJpZGdlRm9yQnJvd3NlciwgaXNCcmlkZ2UgPSBfcmVxdWlyZS5pc0JyaWRnZTtcbiAgICAgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTW19jb25mLkNPTlNUQU5UUy5TRU5EX1NUUkFURUdJRVMuQlJJREdFXSA9IGZ1bmN0aW9uKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGlmIChuZWVkc0JyaWRnZUZvckJyb3dzZXIoKSB8fCBpc0JyaWRnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1NhbWVEb21haW4pKHdpbikpIHRocm93IG5ldyBFcnJvcihcIlBvc3QgbWVzc2FnZSB0aHJvdWdoIGJyaWRnZSBkaXNhYmxlZCBiZXR3ZWVuIHNhbWUgZG9tYWluIHdpbmRvd3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gKDAsIF9zcmMuaXNTYW1lVG9wV2luZG93KSh3aW5kb3csIHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHVzZSBicmlkZ2UgdG8gY29tbXVuaWNhdGUgYmV0d2VlbiB0d28gZGlmZmVyZW50IHdpbmRvd3MsIG5vdCBiZXR3ZWVuIGZyYW1lc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRCcmlkZ2VNZXNzYWdlKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTW19jb25mLkNPTlNUQU5UUy5TRU5EX1NUUkFURUdJRVMuR0xPQkFMXSA9IGZ1bmN0aW9uKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9saWIubmVlZHNHbG9iYWxNZXNzYWdpbmdGb3JCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMuaXNTYW1lRG9tYWluKSh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgdGhyb3VnaCBnbG9iYWwgZGlzYWJsZWQgYmV0d2VlbiBkaWZmZXJlbnQgZG9tYWluIHdpbmRvd3NcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghMSAhPT0gKDAsIF9zcmMuaXNTYW1lVG9wV2luZG93KSh3aW5kb3csIHdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBvbmx5IHVzZSBnbG9iYWwgdG8gY29tbXVuaWNhdGUgYmV0d2VlbiB0d28gZGlmZmVyZW50IHdpbmRvd3MsIG5vdCBiZXR3ZWVuIGZyYW1lc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmVpZ25HbG9iYWwgPSB3aW5bX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmVpZ25HbG9iYWwpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZmluZCBwb3N0Um9ib3QgZ2xvYmFsIG9uIGZvcmVpZ24gd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yZWlnbkdsb2JhbC5yZWNlaXZlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHdpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogKDAsIF9zcmMuZ2V0RG9tYWluKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWFsaXplZE1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5nbG9iYWwgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIChleHBvcnRzLmdsb2JhbCA9IHdpbmRvd1tfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0gPSB3aW5kb3dbX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdIHx8IHt9KS5yZWdpc3RlclNlbGYgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfaW50ZXJmYWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2ludGVyZmFjZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9pbnRlcmZhY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ludGVyZmFjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBJTlRFUkZBQ0UgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvYmopIGZvciAodmFyIGtleSBpbiBvYmopIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgKG5ld09ialtrZXldID0gb2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9KF9pbnRlcmZhY2UpO1xuICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0ID0gSU5URVJGQUNFO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2ludGVyZmFjZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmJyaWRnZSA9IGV4cG9ydHMuUHJvbWlzZSA9IGV4cG9ydHMuY2xlYW5VcFdpbmRvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfcHVibGljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9wdWJsaWMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3B1YmxpY1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfY2xlYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY2xlYW4uanNcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbGVhblVwV2luZG93XCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NsZWFuLmNsZWFuVXBXaW5kb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cG9ydHMuaW5pdCA9IGluaXQ7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy5icmlkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2ludGVyZmFjZS5qc1wiKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLmdsb2JhbC5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2RyaXZlcnMubGlzdGVuRm9yTWVzc2FnZXMpKCk7XG4gICAgICAgICAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvaW5kZXguanNcIikub3BlblR1bm5lbFRvT3BlbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmluaXRPblJlYWR5KSgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5saXN0ZW5Gb3JNZXRob2RzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbjogX3B1YmxpYy5vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IF9wdWJsaWMuc2VuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuaW5pdGlhbGl6ZWQgPSAhMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi91dGlsLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3V0aWwpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3V0aWxba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2xvZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvbG9nLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2xvZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfbG9nW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9zZXJpYWxpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3NlcmlhbGl6ZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9zZXJpYWxpemUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfcmVhZHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3JlYWR5LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3JlYWR5KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWFkeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvbG9nLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMubG9nID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3V0aWwuanNcIiksIExPR19MRVZFTFMgPSBbIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIgXTtcbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIHdpbmRvdy5jb25zb2xlICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2YoY29uc29sZS5sb2cpICYmIFsgXCJsb2dcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIgXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IHRoaXMuYmluZChjb25zb2xlW21ldGhvZF0sIGNvbnNvbGUpO1xuICAgICAgICAgICAgfSwgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwpO1xuICAgICAgICAgICAgdmFyIGxvZyA9IGV4cG9ydHMubG9nID0ge1xuICAgICAgICAgICAgICAgIGNsZWFyTG9nczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmNsZWFyICYmIHdpbmRvdy5jb25zb2xlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29uZi5DT05GSUcuTE9HX1RPX1BBR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvc3RSb2JvdExvZ3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgJiYgY29udGFpbmVyLnBhcmVudE5vZGUgJiYgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd3JpdGVUb1BhZ2U6IGZ1bmN0aW9uKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwb3N0Um9ib3RMb2dzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuaWQgPSBcInBvc3RSb2JvdExvZ3NcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6IDgwMHB4OyBmb250LWZhbWlseTogbW9ub3NwYWNlOyB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBkYXRlID0gbmV3IERhdGUoKS50b1N0cmluZygpLnNwbGl0KFwiIFwiKVs0XSwgcGF5bG9hZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0pIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gKDAsIF91dGlsLmpzb25TdHJpbmdpZnkpKGl0ZW0sIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uID0gXCJbb2JqZWN0XVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXG5cXG5cIiArIGpzb24gKyBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIiBcIiksIG1zZyA9IGRhdGUgKyBcIiBcIiArIGxldmVsICsgXCIgXCIgKyBwYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gbXNnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZzogXCIjZGRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybjogXCJvcmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvOiBcImJsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogXCIjYWFhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1bbGV2ZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IFwibWFyZ2luLXRvcDogMTBweDsgY29sb3I6IFwiICsgY29sb3IgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aCA/IGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoZWwsIGNvbnRhaW5lci5jaGlsZE5vZGVzWzBdKSA6IGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9nTGV2ZWw6IGZ1bmN0aW9uKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2dMZXZlbCA9IHdpbmRvdy5MT0dfTEVWRUwgfHwgX2NvbmYuQ09ORklHLkxPR19MRVZFTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJkaXNhYmxlZFwiID09PSBsb2dMZXZlbCB8fCBMT0dfTEVWRUxTLmluZGV4T2YobGV2ZWwpIDwgTE9HX0xFVkVMUy5pbmRleE9mKGxvZ0xldmVsKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpLnVuc2hpZnQoXCJcIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoXCI6OlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQoXCJcIiArICgwLCBfdXRpbC5nZXRXaW5kb3dUeXBlKSgpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChcIltwb3N0LXJvYm90XVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29uZi5DT05GSUcuTE9HX1RPX1BBR0UgJiYgbG9nLndyaXRlVG9QYWdlKGxldmVsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5jb25zb2xlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGVbbGV2ZWxdIHx8IChsZXZlbCA9IFwibG9nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LmNvbnNvbGVbbGV2ZWxdKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGVbbGV2ZWxdLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWJ1ZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBsb2cubG9nTGV2ZWwoXCJkZWJ1Z1wiLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgICAgICAgICBsb2cubG9nTGV2ZWwoXCJpbmZvXCIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICAgICAgICAgICAgICAgIGxvZy5sb2dMZXZlbChcIndhcm5cIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICAgICAgICAgICAgICAgIGxvZy5sb2dMZXZlbChcImVycm9yXCIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3JlYWR5LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMub25IZWxsbyA9IG9uSGVsbG87XG4gICAgICAgICAgICBleHBvcnRzLnNheUhlbGxvID0gc2F5SGVsbG87XG4gICAgICAgICAgICBleHBvcnRzLmluaXRPblJlYWR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb25IZWxsbyhmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjMuc291cmNlLCBvcmlnaW4gPSBfcmVmMy5vcmlnaW4sIHByb21pc2UgPSBfZ2xvYmFsLmdsb2JhbC5yZWFkeVByb21pc2VzLmdldChzb3VyY2UpIHx8IG5ldyBfc3JjMy5aYWxnb1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWFkeVByb21pc2VzLnNldChzb3VyY2UsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAoMCwgX3NyYzIuZ2V0QW5jZXN0b3IpKCk7XG4gICAgICAgICAgICAgICAgcGFyZW50ICYmIHNheUhlbGxvKHBhcmVudCkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2cubG9nLmRlYnVnKCgwLCBfdXRpbC5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5vbkNoaWxkV2luZG93UmVhZHkgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogNWUzLCBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiBcIldpbmRvd1wiLCBwcm9taXNlID0gX2dsb2JhbC5nbG9iYWwucmVhZHlQcm9taXNlcy5nZXQod2luKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSkgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBfc3JjMy5aYWxnb1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWFkeVByb21pc2VzLnNldCh3aW4sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIC0xICE9PSB0aW1lb3V0ICYmIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IobmFtZSArIFwiIGRpZCBub3QgbG9hZCBhZnRlciBcIiArIHRpbWVvdXQgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpLCBfbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9sb2cuanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi91dGlsLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVhZHlQcm9taXNlcyA9IF9nbG9iYWwuZ2xvYmFsLnJlYWR5UHJvbWlzZXMgfHwgbmV3IF9zcmMuV2Vha01hcCgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gb25IZWxsbyhoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwub24oX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9OQU1FUy5IRUxMTywge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLCBvcmlnaW4gPSBfcmVmLm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNheUhlbGxvKHdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC5zZW5kKHdpbiwgX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9OQU1FUy5IRUxMTywge30sIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBfcmVmMi5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvc2VyaWFsaXplLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMubGlzdGVuRm9yTWV0aG9kcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNlcmlhbGl6ZU1ldGhvZCA9IHNlcmlhbGl6ZU1ldGhvZDtcbiAgICAgICAgICAgIGV4cG9ydHMuc2VyaWFsaXplTWV0aG9kcyA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWwucmVwbGFjZU9iamVjdCkoe1xuICAgICAgICAgICAgICAgICAgICBvYmo6IG9ialxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtID8gc2VyaWFsaXplTWV0aG9kKGRlc3RpbmF0aW9uLCBkb21haW4sIGl0ZW0sIGtleS50b1N0cmluZygpKSA6IGl0ZW0gaW5zdGFuY2VvZiBFcnJvciA/IChlcnIgPSBpdGVtLCBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19tZXNzYWdlX186ICgwLCBfdXRpbC5zdHJpbmdpZnlFcnJvcikoZXJyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY29kZV9fOiBlcnIuY29kZVxuICAgICAgICAgICAgICAgICAgICB9KSA6IHdpbmRvdy5Qcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuUHJvbWlzZSA/IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHByb21pc2UsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlBST01JU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGVuX186IHNlcmlhbGl6ZU1ldGhvZChkZXN0aW5hdGlvbiwgZG9tYWluLCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG5hbWUgKyBcIi50aGVuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIGl0ZW0sIGtleS50b1N0cmluZygpKSA6IF9zcmMzLlphbGdvUHJvbWlzZS5pc1Byb21pc2UoaXRlbSkgPyBmdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCBwcm9taXNlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZV9fOiBfY29uZi5DT05TVEFOVFMuU0VSSUFMSVpBVElPTl9UWVBFUy5aQUxHT19QUk9NSVNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fdGhlbl9fOiBzZXJpYWxpemVNZXRob2QoZGVzdGluYXRpb24sIGRvbWFpbiwgZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBuYW1lICsgXCIudGhlblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfShkZXN0aW5hdGlvbiwgZG9tYWluLCBpdGVtLCBrZXkudG9TdHJpbmcoKSkgOiAoMCwgX3V0aWwuaXNSZWdleCkoaXRlbSkgPyAocmVnZXggPSBpdGVtLCBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlJFR0VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19zb3VyY2VfXzogcmVnZXguc291cmNlXG4gICAgICAgICAgICAgICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyLCByZWdleDtcbiAgICAgICAgICAgICAgICB9KS5vYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZU1ldGhvZCA9IGRlc2VyaWFsaXplTWV0aG9kO1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZUVycm9yID0gZGVzZXJpYWxpemVFcnJvcjtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVzZXJpYWxpemVaYWxnb1Byb21pc2UgPSBkZXNlcmlhbGl6ZVphbGdvUHJvbWlzZTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVzZXJpYWxpemVQcm9taXNlID0gZGVzZXJpYWxpemVQcm9taXNlO1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZVJlZ2V4ID0gZGVzZXJpYWxpemVSZWdleDtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVzZXJpYWxpemVNZXRob2RzID0gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWwucmVwbGFjZU9iamVjdCkoe1xuICAgICAgICAgICAgICAgICAgICBvYmo6IG9ialxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IGl0ZW0gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihpdGVtKSkgJiYgbnVsbCAhPT0gaXRlbSkgcmV0dXJuIGlzU2VyaWFsaXplZChpdGVtLCBfY29uZi5DT05TVEFOVFMuU0VSSUFMSVpBVElPTl9UWVBFUy5NRVRIT0QpID8gZGVzZXJpYWxpemVNZXRob2Qoc291cmNlLCBvcmlnaW4sIGl0ZW0pIDogaXNTZXJpYWxpemVkKGl0ZW0sIF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLkVSUk9SKSA/IGRlc2VyaWFsaXplRXJyb3Ioc291cmNlLCBvcmlnaW4sIGl0ZW0pIDogaXNTZXJpYWxpemVkKGl0ZW0sIF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlBST01JU0UpID8gZGVzZXJpYWxpemVQcm9taXNlKHNvdXJjZSwgb3JpZ2luLCBpdGVtKSA6IGlzU2VyaWFsaXplZChpdGVtLCBfY29uZi5DT05TVEFOVFMuU0VSSUFMSVpBVElPTl9UWVBFUy5aQUxHT19QUk9NSVNFKSA/IGRlc2VyaWFsaXplWmFsZ29Qcm9taXNlKHNvdXJjZSwgb3JpZ2luLCBpdGVtKSA6IGlzU2VyaWFsaXplZChpdGVtLCBfY29uZi5DT05TVEFOVFMuU0VSSUFMSVpBVElPTl9UWVBFUy5SRUdFWCkgPyBkZXNlcmlhbGl6ZVJlZ2V4KHNvdXJjZSwgb3JpZ2luLCBpdGVtKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9KS5vYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKSwgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3V0aWwuanNcIiksIF9sb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2xvZy5qc1wiKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm1ldGhvZHMgPSBfZ2xvYmFsLmdsb2JhbC5tZXRob2RzIHx8IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgIGV4cG9ydHMubGlzdGVuRm9yTWV0aG9kcyA9ICgwLCBfdXRpbC5vbmNlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5vbihfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX05BTUVTLk1FVEhPRCwge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYuc291cmNlLCBvcmlnaW4gPSBfcmVmLm9yaWdpbiwgZGF0YSA9IF9yZWYuZGF0YSwgbWV0aG9kcyA9IF9nbG9iYWwuZ2xvYmFsLm1ldGhvZHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWV0aG9kcykgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgYW55IG1ldGhvZHMgdGhpcyB3aW5kb3cgaGFzIHByaXZpbGVnZXMgdG8gY2FsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGggPSBtZXRob2RzW2RhdGEuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGgpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIG1ldGhvZCB3aXRoIGlkOiBcIiArIGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikobWV0aC5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBkb21haW4gXCIgKyBtZXRoLmRvbWFpbiArIFwiIGRvZXMgbm90IG1hdGNoIG9yaWdpbiBcIiArIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgIF9sb2cubG9nLmRlYnVnKFwiQ2FsbCBsb2NhbCBtZXRob2RcIiwgZGF0YS5uYW1lLCBkYXRhLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRoLm1ldGhvZC5hcHBseSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGF0YS5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gaXNTZXJpYWxpemVkKGl0ZW0sIHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gaXRlbSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGl0ZW0pKSAmJiBudWxsICE9PSBpdGVtICYmIGl0ZW0uX190eXBlX18gPT09IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXRob2QoZGVzdGluYXRpb24sIGRvbWFpbiwgbWV0aG9kLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gKDAsIF91dGlsLnVuaXF1ZUlEKSgpLCBtZXRob2RzID0gX2dsb2JhbC5nbG9iYWwubWV0aG9kcy5nZXQoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICghbWV0aG9kcykge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2RzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm1ldGhvZHMuc2V0KGRlc3RpbmF0aW9uLCBtZXRob2RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgX190eXBlX186IF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLk1FVEhPRCxcbiAgICAgICAgICAgICAgICAgICAgX19pZF9fOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgX19uYW1lX186IG5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVNZXRob2Qoc291cmNlLCBvcmlnaW4sIG9iaikge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgX2xvZy5sb2cuZGVidWcoXCJDYWxsIGZvcmVpZ24gbWV0aG9kXCIsIG9iai5fX25hbWVfXywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC5zZW5kKHNvdXJjZSwgX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9OQU1FUy5NRVRIT0QsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvYmouX19pZF9fLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogb2JqLl9fbmFtZV9fLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IC0xXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2cubG9nLmRlYnVnKFwiR290IGZvcmVpZ24gbWV0aG9kIHJlc3VsdFwiLCBvYmouX19uYW1lX18sIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9nLmxvZy5kZWJ1ZyhcIkdvdCBmb3JlaWduIG1ldGhvZCBlcnJvclwiLCAoMCwgX3V0aWwuc3RyaW5naWZ5RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JhcHBlci5fX25hbWVfXyA9IG9iai5fX25hbWVfXztcbiAgICAgICAgICAgICAgICB3cmFwcGVyLl9feGRvbWFpbl9fID0gITA7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgd3JhcHBlci5vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZUVycm9yKHNvdXJjZSwgb3JpZ2luLCBvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKG9iai5fX21lc3NhZ2VfXyk7XG4gICAgICAgICAgICAgICAgb2JqLl9fY29kZV9fICYmIChlcnIuY29kZSA9IG9iai5fX2NvZGVfXyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplWmFsZ29Qcm9taXNlKHNvdXJjZSwgb3JpZ2luLCBwcm9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMy5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZU1ldGhvZChzb3VyY2UsIG9yaWdpbiwgcHJvbS5fX3RoZW5fXykocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplUHJvbWlzZShzb3VyY2UsIG9yaWdpbiwgcHJvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuUHJvbWlzZSA/IG5ldyB3aW5kb3cuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWV0aG9kKHNvdXJjZSwgb3JpZ2luLCBwcm9tLl9fdGhlbl9fKShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pIDogZGVzZXJpYWxpemVaYWxnb1Byb21pc2Uoc291cmNlLCBvcmlnaW4sIHByb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVSZWdleChzb3VyY2UsIG9yaWdpbiwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGl0ZW0uX19zb3VyY2VfXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3V0aWwuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy53ZWFrTWFwTWVtb2l6ZSA9IGV4cG9ydHMub25jZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeUVycm9yID0gZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAzKSByZXR1cm4gXCJzdHJpbmdpZnlFcnJvciBzdGFjayBvdmVyZmxvd1wiO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSByZXR1cm4gXCI8dW5rbm93biBlcnJvcjogXCIgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKSArIFwiPlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZXJyKSByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGVyciAmJiBlcnIuc3RhY2ssIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgbWVzc2FnZSkgcmV0dXJuIC0xICE9PSBzdGFjay5pbmRleE9mKG1lc3NhZ2UpID8gc3RhY2sgOiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyLnRvU3RyaW5nID8gZXJyLnRvU3RyaW5nKCkgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChuZXdFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3Igd2hpbGUgc3RyaW5naWZ5aW5nIGVycm9yOiBcIiArIHN0cmluZ2lmeUVycm9yKG5ld0VyciwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG9iaiwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lciA/IG9iai5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSA6IG9iai5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyID8gb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpIDogb2JqLmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy51bmlxdWVJRCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcInh4eHh4eHh4eHhcIi5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZWFjaEFycmF5ID0gZWFjaEFycmF5O1xuICAgICAgICAgICAgZXhwb3J0cy5lYWNoT2JqZWN0ID0gZWFjaE9iamVjdDtcbiAgICAgICAgICAgIGV4cG9ydHMuZWFjaCA9IGVhY2g7XG4gICAgICAgICAgICBleHBvcnRzLnJlcGxhY2VPYmplY3QgPSBmdW5jdGlvbiByZXBsYWNlT2JqZWN0KGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+PSAxMDApIHRocm93IG5ldyBFcnJvcihcIlNlbGYtcmVmZXJlbnRpYWwgb2JqZWN0IHBhc3NlZCwgb3Igb2JqZWN0IGNvbnRhaW5lZCB0b28gbWFueSBsYXllcnNcIik7XG4gICAgICAgICAgICAgICAgdmFyIG5ld29iaiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gKHZvaWQgMCA9PT0gaXRlbSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGl0ZW0pKSB8fCBudWxsID09PSBpdGVtIHx8IEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW0pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0eXBlOiBcIiArICh2b2lkIDAgPT09IGl0ZW0gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihpdGVtKSkpO1xuICAgICAgICAgICAgICAgICAgICBuZXdvYmogPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgbmV3b2JqID0ge307XG4gICAgICAgICAgICAgICAgZWFjaChpdGVtLCBmdW5jdGlvbihjaGlsZEl0ZW0sIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2soY2hpbGRJdGVtLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHJlc3VsdCA/IG5ld29ialtrZXldID0gcmVzdWx0IDogXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gY2hpbGRJdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY2hpbGRJdGVtKSkgJiYgbnVsbCAhPT0gY2hpbGRJdGVtID8gbmV3b2JqW2tleV0gPSByZXBsYWNlT2JqZWN0KGNoaWxkSXRlbSwgY2FsbGJhY2ssIGRlcHRoICsgMSkgOiBuZXdvYmpba2V5XSA9IGNoaWxkSXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3b2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2FmZUludGVydmFsID0gZnVuY3Rpb24obWV0aG9kLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcnVuSW50ZXJ2YWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJ1bkludGVydmFsLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzUmVnZXggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiW29iamVjdCBSZWdFeHBdXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFdpbmRvd1R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMyLmlzUG9wdXApKCkpIHJldHVybiBfY29uZi5DT05TVEFOVFMuV0lORE9XX1RZUEVTLlBPUFVQO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzIuaXNJZnJhbWUpKCkpIHJldHVybiBfY29uZi5DT05TVEFOVFMuV0lORE9XX1RZUEVTLklGUkFNRTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmYuQ09OU1RBTlRTLldJTkRPV19UWVBFUy5GVUxMUEFHRTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmpzb25TdHJpbmdpZnkgPSBmdW5jdGlvbihvYmosIHJlcGxhY2VyLCBpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0VG9KU09OID0gdm9pZCAwLCBhcnJheVRvSlNPTiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ7fVwiICE9PSBKU09OLnN0cmluZ2lmeSh7fSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFRvSlNPTiA9IE9iamVjdC5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIE9iamVjdC5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInt9XCIgIT09IEpTT04uc3RyaW5naWZ5KHt9KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb3JyZWN0bHkgc2VyaWFsaXplIEpTT04gb2JqZWN0c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiW11cIiAhPT0gSlNPTi5zdHJpbmdpZnkoW10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheVRvSlNPTiA9IEFycmF5LnByb3RvdHlwZS50b0pTT047XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoXCJbXVwiICE9PSBKU09OLnN0cmluZ2lmeShbXSkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgY29ycmVjdGx5IHNlcmlhbGl6ZSBKU09OIG9iamVjdHNcIik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVwYWlyIEpTT04uc3RyaW5naWZ5OiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5LmNhbGwodGhpcywgb2JqLCByZXBsYWNlciwgaW5kZW50KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RUb0pTT04gJiYgKE9iamVjdC5wcm90b3R5cGUudG9KU09OID0gb2JqZWN0VG9KU09OKTtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlUb0pTT04gJiYgKEFycmF5LnByb3RvdHlwZS50b0pTT04gPSBhcnJheVRvSlNPTik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVwYWlyIEpTT04uc3RyaW5naWZ5OiBcIiArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmpzb25QYXJzZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5lZWRzR2xvYmFsTWVzc2FnaW5nRm9yQnJvd3NlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzIuZ2V0VXNlckFnZW50KSh3aW5kb3cpLm1hdGNoKC9NU0lFfHRyaWRlbnR8ZWRnZVxcLzEyfGVkZ2VcXC8xMy9pKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIGlmICghX2NvbmYuQ09ORklHLkFMTE9XX1BPU1RNRVNTQUdFX1BPUFVQKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy5vbmNlID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRob2QpIHJldHVybiBtZXRob2Q7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlZCA9ICExO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXJyYXkoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW0ubGVuZ3RoOyBpKyspIGNhbGxiYWNrKGl0ZW1baV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZWFjaE9iamVjdChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gaXRlbSkgaXRlbS5oYXNPd25Qcm9wZXJ0eShfa2V5KSAmJiBjYWxsYmFjayhpdGVtW19rZXldLCBfa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2goaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGl0ZW0pID8gZWFjaEFycmF5KGl0ZW0sIGNhbGxiYWNrKSA6IFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IGl0ZW0gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihpdGVtKSkgJiYgbnVsbCAhPT0gaXRlbSAmJiBlYWNoT2JqZWN0KGl0ZW0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMud2Vha01hcE1lbW9pemUgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2Vha21hcCA9IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB3ZWFrbWFwLmdldChhcmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gKHJlc3VsdCA9IG1ldGhvZC5jYWxsKHRoaXMsIGFyZykpICYmIHdlYWttYXAuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9wdWJsaWMvY2xpZW50LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuc2VuZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICBleHBvcnRzLnNlbmRUb1BhcmVudCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luID0gKDAsIF9zcmMzLmdldEFuY2VzdG9yKSgpO1xuICAgICAgICAgICAgICAgIGlmICghd2luKSByZXR1cm4gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgZG9lcyBub3QgaGF2ZSBhIHBhcmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zZW5kKHdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jbGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLndpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy53aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgdmFyIHdpbiA9IG9wdGlvbnMud2luZG93O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQ6IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VuZCh3aW4sIG5hbWUsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RQcm9taXNlcyA9IF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RQcm9taXNlcyB8fCBuZXcgX3NyYy5XZWFrTWFwKCk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLm5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMubmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsIHRhcmdldFdpbmRvdyA9IHZvaWQgMCwgZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygb3B0aW9ucy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMud2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMud2luZG93IFwiICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMud2luZG93KSArIFwiIHRvIGJlIGEgdmFsaWQgZWxlbWVudCBpZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImlmcmFtZVwiICE9PSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMud2luZG93IFwiICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMud2luZG93KSArIFwiIHRvIGJlIGFuIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwuY29udGVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiSWZyYW1lIG11c3QgaGF2ZSBjb250ZW50V2luZG93LiAgTWFrZSBzdXJlIGl0IGhhcyBhIHNyYyBhdHRyaWJ1dGUgYW5kIGlzIGluIHRoZSBET00uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2luZG93ID0gZWwuY29udGVudFdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLndpbmRvdyBpbnN0YW5jZW9mIEhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJpZnJhbWVcIiAhPT0gb3B0aW9ucy53aW5kb3cudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLndpbmRvdyBcIiArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRpb25zLndpbmRvdykgKyBcIiB0byBiZSBhbiBpZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy53aW5kb3cgJiYgIW9wdGlvbnMud2luZG93LmNvbnRlbnRXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIklmcmFtZSBtdXN0IGhhdmUgY29udGVudFdpbmRvdy4gIE1ha2Ugc3VyZSBpdCBoYXMgYSBzcmMgYXR0cmlidXRlIGFuZCBpcyBpbiB0aGUgRE9NLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2luZG93ICYmIG9wdGlvbnMud2luZG93LmNvbnRlbnRXaW5kb3cgJiYgKHRhcmdldFdpbmRvdyA9IG9wdGlvbnMud2luZG93LmNvbnRlbnRXaW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdGFyZ2V0V2luZG93ID0gb3B0aW9ucy53aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLndpbmRvdyB0byBiZSBhIHdpbmRvdyBvYmplY3QsIGlmcmFtZSwgb3IgaWZyYW1lIGVsZW1lbnQgaWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2luID0gdGFyZ2V0V2luZG93O1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBvcHRpb25zLmRvbWFpbiB8fCBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gb3B0aW9ucy5uYW1lICsgXCJfXCIgKyAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMy5pc1dpbmRvd0Nsb3NlZCkod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiVGFyZ2V0IHdpbmRvdyBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNSZXN1bHQgPSAhMSwgcmVxdWVzdFByb21pc2VzID0gX2dsb2JhbC5nbG9iYWwucmVxdWVzdFByb21pc2VzLmdldCh3aW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3RQcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0UHJvbWlzZXMuc2V0KHdpbiwgcmVxdWVzdFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdFByb21pc2UgPSBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMy5pc0FuY2VzdG9yKSh3aW5kb3csIHdpbikpIHJldHVybiAoMCwgX2xpYi5vbkNoaWxkV2luZG93UmVhZHkpKHdpbiwgb3B0aW9ucy50aW1lb3V0IHx8IF9jb25mLkNPTkZJRy5DSElMRF9XSU5ET1dfVElNRU9VVCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge30pLm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2xpYi5pc1JlZ2V4KShkb21haW4pICYmICFvcmlnaW4pIHJldHVybiAoMCwgX2xpYi5zYXlIZWxsbykod2luKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fSkub3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfbGliLmlzUmVnZXgpKGRvbWFpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMy5tYXRjaERvbWFpbikoZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZW1vdGUgd2luZG93IGRvbWFpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIHJlZ2V4OiBcIiArIGRvbWFpbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZG9tYWluICYmICFBcnJheS5pc0FycmF5KGRvbWFpbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBkb21haW4gdG8gYmUgYSBzdHJpbmcgb3IgYXJyYXlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0dWFsRG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZpcmVBbmRGb3JnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogYWN0dWFsRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uZDogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNSZXN1bHQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzLnNwbGljZShyZXF1ZXN0UHJvbWlzZXMuaW5kZXhPZihyZXF1ZXN0UHJvbWlzZSwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9kcml2ZXJzLmFkZFJlc3BvbnNlTGlzdGVuZXIpKGhhc2gsIHJlc3BvbnNlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2RyaXZlcnMuc2VuZE1lc3NhZ2UpKHdpbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuUkVRVUVTVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogb3B0aW9ucy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiBvcHRpb25zLmZpcmVBbmRGb3JnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBhY3R1YWxEb21haW4pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlyZUFuZEZvcmdldCkgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNrVGltZW91dCA9IF9jb25mLkNPTkZJRy5BQ0tfVElNRU9VVCwgcmVzVGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCBfY29uZi5DT05GSUcuUkVTX1RJTUVPVVQsIGN5Y2xlVGltZSA9IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGN5Y2xlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMy5pc1dpbmRvd0Nsb3NlZCkod2luKSkgcmV0dXJuIHJlc3BvbnNlTGlzdGVuZXIuYWNrID8gcmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBjbG9zZWQgZm9yIFwiICsgbmFtZSArIFwiIGJlZm9yZSByZXNwb25zZVwiKSkgOiByZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIGFja1wiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2tUaW1lb3V0ID0gTWF0aC5tYXgoYWNrVGltZW91dCAtIGN5Y2xlVGltZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMSAhPT0gcmVzVGltZW91dCAmJiAocmVzVGltZW91dCA9IE1hdGgubWF4KHJlc1RpbWVvdXQgLSBjeWNsZVRpbWUsIDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUxpc3RlbmVyLmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gcmVzVGltZW91dCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlVGltZSA9IE1hdGgubWluKHJlc1RpbWVvdXQsIDJlMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBhY2tUaW1lb3V0KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIk5vIGFjayBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBuYW1lICsgXCIgaW4gXCIgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NyYzMuZ2V0RG9tYWluKSgpICsgXCIgaW4gXCIgKyBfY29uZi5DT05GSUcuQUNLX1RJTUVPVVQgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcmVzVGltZW91dCkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBuYW1lICsgXCIgaW4gXCIgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NyYzMuZ2V0RG9tYWluKSgpICsgXCIgaW4gXCIgKyAob3B0aW9ucy50aW1lb3V0IHx8IF9jb25mLkNPTkZJRy5SRVNfVElNRU9VVCkgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY3ljbGUsIGN5Y2xlVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjeWNsZVRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UHJvbWlzZS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHJpdmVycy5tYXJrUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQpKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9kcml2ZXJzLmRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIpKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzLnB1c2gocmVxdWVzdFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFByb21pc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBfc2VuZCh3aW5kb3csIG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICBvcHRpb25zLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnNlbmQgPSBfc2VuZDtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnNlbmQgPSBfc2VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9wdWJsaWMvY29uZmlnLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuQ09OU1RBTlRTID0gZXhwb3J0cy5DT05GSUcgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNPTkZJR1wiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb25mLkNPTkZJRztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNPTlNUQU5UU1wiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb25mLkNPTlNUQU5UUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3dbX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBfZHJpdmVycy5tZXNzYWdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfZHJpdmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9jbGllbnQuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfY2xpZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbGllbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3NlcnZlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9wdWJsaWMvc2VydmVyLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3NlcnZlcikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VydmVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvcHVibGljL2NvbmZpZy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb25maWcpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnBhcmVudCA9ICgwLCBfc3JjLmdldEFuY2VzdG9yKSgpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9zZXJ2ZXIuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5vbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmxpc3RlbiA9IGxpc3RlbjtcbiAgICAgICAgICAgIGV4cG9ydHMub25jZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDoge30sIGhhbmRsZXIgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyLCBwcm9taXNlID0gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlID0gITA7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSByZXR1cm4gaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIpIHJldHVybiBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSwgb25jZUxpc3RlbmVyID0gbGlzdGVuKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHByb21pc2UuY2FuY2VsID0gb25jZUxpc3RlbmVyLmNhbmNlbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gbGlzdGVuKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy5uYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5oYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLmhhbmRsZXJcIik7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsIHdpbiA9IG9wdGlvbnMud2luZG93LCBkb21haW4gPSBvcHRpb25zLmRvbWFpbiwgbGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiBvcHRpb25zLmhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yOiBvcHRpb25zLmVycm9ySGFuZGxlciB8fCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW4sXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluIHx8IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgIH0sIHJlcXVlc3RMaXN0ZW5lciA9ICgwLCBfZHJpdmVycy5hZGRSZXF1ZXN0TGlzdGVuZXIpKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluXG4gICAgICAgICAgICAgICAgfSwgbGlzdGVuZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaGFuZGxlciA9IGxpc3RlbmVyT3B0aW9ucy5oYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck9wdGlvbnMuaGFuZGxlciA9ICgwLCBfbGliLm9uY2UpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJPcHRpb25zLndpbmRvdyAmJiBvcHRpb25zLmVycm9yT25DbG9zZSkgdmFyIGludGVydmFsID0gKDAsIF9saWIuc2FmZUludGVydmFsKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSB3aW4gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW4pKSAmJiAoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lck9wdGlvbnMuaGFuZGxlRXJyb3IobmV3IEVycm9yKFwiUG9zdCBtZXNzYWdlIHRhcmdldCB3aW5kb3cgaXMgY2xvc2VkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9vbihuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlciA9IGhhbmRsZXIgfHwgb3B0aW9ucy5oYW5kbGVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW4ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLm9uID0gX29uO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwub24gPSBfb247XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgY2FjaGVkU2V0VGltZW91dCwgY2FjaGVkQ2xlYXJUaW1lb3V0LCBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHNldFRpbWVvdXQgPyBzZXRUaW1lb3V0IDogZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGNsZWFyVGltZW91dCA/IGNsZWFyVGltZW91dCA6IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRRdWV1ZSwgcXVldWUgPSBbXSwgZHJhaW5pbmcgPSAhMSwgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgICAgICAgICAgICAgIGlmIChkcmFpbmluZyAmJiBjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhaW5pbmcgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlLmxlbmd0aCA/IHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSkgOiBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAmJiBkcmFpblF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgICAgICAgICAgICAgICAgICBkcmFpbmluZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7IGxlbjsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsrK3F1ZXVlSW5kZXggPCBsZW47ICkgY3VycmVudFF1ZXVlICYmIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkcmFpbmluZyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24obWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbihmdW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICAgICAgICAgICAgICAxICE9PSBxdWV1ZS5sZW5ndGggfHwgZHJhaW5pbmcgfHwgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICAgICAgICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzLnRpdGxlID0gXCJicm93c2VyXCI7XG4gICAgICAgICAgICBwcm9jZXNzLmJyb3dzZXIgPSAhMDtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52ID0ge307XG4gICAgICAgICAgICBwcm9jZXNzLmFyZ3YgPSBbXTtcbiAgICAgICAgICAgIHByb2Nlc3MudmVyc2lvbiA9IFwiXCI7XG4gICAgICAgICAgICBwcm9jZXNzLnZlcnNpb25zID0ge307XG4gICAgICAgICAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICAgICAgICAgIHByb2Nlc3Mub24gPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLm9uY2UgPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5vZmYgPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLmVtaXQgPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcbiAgICAgICAgICAgIHByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2Vzcy5jd2QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIvXCI7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uKGRpcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbihfX3dlYnBhY2tfYW1kX29wdGlvbnNfXykge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4gICAgICAgICAgICB9KS5jYWxsKGV4cG9ydHMsIHt9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICB2YXIgZywgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDAsIGV2YWwpKFwidGhpc1wiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2Ygd2luZG93ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgJiYgKGcgPSB3aW5kb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBnO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUucGF0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmNoaWxkcmVuIHx8IChtb2R1bGUuY2hpbGRyZW4gPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvZXhjZXB0aW9ucy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmRpc3BhdGNoUG9zc2libHlVbmhhbmRsZWRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmRpc3BhdGNoZWRFcnJvcnMuaW5kZXhPZihlcnIpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmRpc3BhdGNoZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8ICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5sZW5ndGg7IGorKykgKDAsIFxuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLnBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVycik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5vblBvc3NpYmx5VW5oYW5kbGVkRXhjZXB0aW9uID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkucG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMuc3BsaWNlKCgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2dsb2JhbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgICAgIGV4cG9ydHMuZ2V0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbG9iID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93KSBnbG9iID0gd2luZG93OyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGdsb2JhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbiBub3QgZmluZCBnbG9iYWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iID0gZ2xvYmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB6YWxnb0dsb2JhbCA9IGdsb2IuX196YWxnb3Byb21pc2VfXyA9IGdsb2IuX196YWxnb3Byb21pc2VfXyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgemFsZ29HbG9iYWwuZmx1c2hQcm9taXNlcyA9IHphbGdvR2xvYmFsLmZsdXNoUHJvbWlzZXMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHphbGdvR2xvYmFsLmFjdGl2ZUNvdW50ID0gemFsZ29HbG9iYWwuYWN0aXZlQ291bnQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgemFsZ29HbG9iYWwucG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMgPSB6YWxnb0dsb2JhbC5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgemFsZ29HbG9iYWwuZGlzcGF0Y2hlZEVycm9ycyA9IHphbGdvR2xvYmFsLmRpc3BhdGNoZWRFcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB6YWxnb0dsb2JhbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiKSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9wcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL3Byb21pc2UuanNcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJaYWxnb1Byb21pc2VcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZS5aYWxnb1Byb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvcHJvbWlzZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLlphbGdvUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvdXRpbHMuanNcIiksIF9leGNlcHRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2V4Y2VwdGlvbnMuanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICAgICAgdmFyIFphbGdvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIFphbGdvUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdCA9IHZvaWQgMCwgX2Vycm9yID0gdm9pZCAwLCByZXNvbHZlZCA9ICExLCByZWplY3RlZCA9ICExLCBpc0FzeW5jID0gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FzeW5jKSBfdGhpcy5yZXNvbHZlKHJlcyk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlamVjdChlcnIpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBc3luYyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPyB0aGlzLnJlc29sdmUoX3Jlc3VsdCkgOiByZWplY3RlZCAmJiB0aGlzLnJlamVjdChfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfdXRpbHMuaXNQcm9taXNlKShyZXN1bHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3V0aWxzLmlzUHJvbWlzZSkoZXJyb3IpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlamVjdCBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2VyciA9IGVycm9yICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyb3IudG9TdHJpbmcgPyBlcnJvci50b1N0cmluZygpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiRXhwZWN0ZWQgcmVqZWN0IHRvIGJlIGNhbGxlZCB3aXRoIEVycm9yLCBnb3QgXCIgKyBfZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgfHwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5lcnJvckhhbmRsZWQgfHwgKDAsIF9leGNlcHRpb25zLmRpc3BhdGNoUG9zc2libHlVbmhhbmRsZWRFcnJvcikoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUuYXN5bmNSZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzLCBkaXNwYXRjaGluZyA9IHRoaXMuZGlzcGF0Y2hpbmcsIHJlc29sdmVkID0gdGhpcy5yZXNvbHZlZCwgcmVqZWN0ZWQgPSB0aGlzLnJlamVjdGVkLCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzcGF0Y2hpbmcgJiYgKHJlc29sdmVkIHx8IHJlamVjdGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmFjdGl2ZUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbG9vcCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXJzJGkgPSBoYW5kbGVyc1tpXSwgb25TdWNjZXNzID0gX2hhbmRsZXJzJGkub25TdWNjZXNzLCBvbkVycm9yID0gX2hhbmRsZXJzJGkub25FcnJvciwgcHJvbWlzZSA9IF9oYW5kbGVycyRpLnByb21pc2UsIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9uU3VjY2VzcyA/IG9uU3VjY2VzcyhfdGhpczMudmFsdWUpIDogX3RoaXMzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChfdGhpczMuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb25FcnJvcihfdGhpczMuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKHJlc3VsdC5yZXNvbHZlZCB8fCByZXN1bHQucmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShyZXN1bHQudmFsdWUpIDogcHJvbWlzZS5yZWplY3QocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ySGFuZGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAoMCwgX3V0aWxzLmlzUHJvbWlzZSkocmVzdWx0KSA/IHJlc3VsdCBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAocmVzdWx0LnJlc29sdmVkIHx8IHJlc3VsdC5yZWplY3RlZCkgPyByZXN1bHQucmVzb2x2ZWQgPyBwcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKSA6IHByb21pc2UucmVqZWN0KHJlc3VsdC5lcnJvcikgOiByZXN1bHQudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBwcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIF9sb29wKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5hY3RpdmVDb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgMCA9PT0gKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmFjdGl2ZUNvdW50ICYmIFphbGdvUHJvbWlzZS5mbHVzaFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25TdWNjZXNzICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb25TdWNjZXNzICYmICFvblN1Y2Nlc3MuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIHN1Y2Nlc3MgaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRXJyb3IgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvbkVycm9yICYmICFvbkVycm9yLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBlcnJvciBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IG9uU3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ob25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShoYW5kbGVyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnRyeShoYW5kbGVyKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHRpbWUsIGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNC5yZXNvbHZlZCB8fCBfdGhpczQucmVqZWN0ZWQgfHwgX3RoaXM0LnJlamVjdChlcnIgfHwgbmV3IEVycm9yKFwiUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgXCIgKyB0aW1lICsgXCJtc1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgUHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFByb21pc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSA/IHZhbHVlIDogKDAsIF91dGlscy5pc1Byb21pc2UpKHZhbHVlKSA/IG5ldyBaYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KSA6IG5ldyBaYWxnb1Byb21pc2UoKS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFphbGdvUHJvbWlzZSgpLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UuYWxsID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgWmFsZ29Qcm9taXNlKCksIGNvdW50ID0gcHJvbWlzZXMubGVuZ3RoLCByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sb29wMiA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9tID0gcHJvbWlzZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tLnJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoISgwLCBfdXRpbHMuaXNQcm9taXNlKShwcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBwcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZXNvbHZlKHByb20pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwID09PSAoY291bnQgLT0gMSkgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSBfbG9vcDIoaSk7XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IGNvdW50ICYmIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UuaGFzaCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMocHJvbWlzZXMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShwcm9taXNlc1trZXldKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uKGl0ZW1zLCBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoaXRlbXMubWFwKG1ldGhvZCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRFeGNlcHRpb24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2V4Y2VwdGlvbnMub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbikoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UudHJ5ID0gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5kZWxheSA9IGZ1bmN0aW9uKF9kZWxheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIF9kZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSkgfHwgKDAsIF91dGlscy5pc1Byb21pc2UpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmZsdXNoUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmFjdGl2ZUNvdW50ICYmIFphbGdvUHJvbWlzZS5mbHVzaFF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmZsdXNoUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzVG9GbHVzaCA9ICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5mbHVzaFByb21pc2VzO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuZmx1c2hQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gcHJvbWlzZXNUb0ZsdXNoLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlO1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgZXhwb3J0cy5aYWxnb1Byb21pc2UgPSBaYWxnb1Byb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvdXRpbHMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1Byb21pc2UgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93LldpbmRvdyAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvdy5jb25zdHJ1Y3RvciAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LmNvbnN0cnVjdG9yKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfdG9TdHJpbmcuY2FsbChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIltvYmplY3QgV2luZG93XVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBnbG9iYWxdXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IERPTVdpbmRvd11cIiA9PT0gbmFtZSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udGhlbikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5CYXNlQ29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLkJhc2VDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBCYXNlQ29tcG9uZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBCYXNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbiA9IChvYmogPSB0aGlzLCB0YXNrcyA9IFtdLCBjbGVhbmVkID0gITEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24obmFtZSwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkKSByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbbmFtZV0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmpbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiPGFub255bW91cy1jbGVhbnVwLWhhbmRsZXI+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG1ldGhvZCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHRvIGJlIHBhc3NlZCBmdW5jdGlvbiB0byBjbGVhbi5yZWdpc3RlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkID8gbWV0aG9kKCkgOiB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCAmJiBtZXRob2QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Rhc2tzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0YXNrcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWl0ZW0uY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5lZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoO3Rhc2tzLmxlbmd0aDsgKSByZXN1bHRzLnB1c2godGFza3MucG9wKCkucnVuKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBydW46IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCBfaXRlcmF0b3IgPSB0YXNrcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5uYW1lID09PSBuYW1lICYmIHJlc3VsdHMucHVzaChpdGVtLnJ1bigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqLCB0YXNrcywgY2xlYW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9ICgwLCBfbGliLmV2ZW50RW1pdHRlcikoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUuYWRkUHJvcCA9IGZ1bmN0aW9uKG9wdGlvbnMsIG5hbWUsIGRlZikge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5jb3B5UHJvcCkob3B0aW9ucywgdGhpcywgbmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJhc2VDb21wb25lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50Lm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbGlzdGVuZXJzIHRvIGJlIGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZXJyb3IgdG8gYmUgaW1wbGVtZW50ZWQgLSBnb3QgXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbih3aW4sIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbikgdGhyb3cgdGhpcy5jb21wb25lbnQuY3JlYXRlRXJyb3IoXCJ3aW5kb3cgdG8gbGlzdGVuIHRvIG5vdCBzZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHBhc3MgZG9tYWluIHRvIGxpc3RlbiB0b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMoKSwgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck5hbWUgPSBfcmVmMiwgbmFtZSA9IGxpc3RlbmVyTmFtZS5yZXBsYWNlKC9eem9pZF8vLCBcIlwiKSwgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIgPSAoMCwgX3NyYzIub24pKGxpc3RlbmVyTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYzLnNvdXJjZSwgZGF0YSA9IF9yZWYzLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5sb2coXCJsaXN0ZW5lcl9cIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXJzW2xpc3RlbmVyTmFtZV0uY2FsbChfdGhpcywgc291cmNlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZXJyb3JMaXN0ZW5lciA9ICgwLCBfc3JjMi5vbikobGlzdGVuZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXI6IGVycm9ySGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmNC5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5sb2dFcnJvcihcInVuZXhwZWN0ZWRfbGlzdGVuZXJfXCIgKyBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyBuYW1lICsgXCIgbWVzc2FnZSBmcm9tIGRvbWFpbiBcIiArIG9yaWdpbiArIFwiIC0tIGV4cGVjdGVkIG1lc3NhZ2UgZnJvbSBcIiArIGRvbWFpbi50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW4ucmVnaXN0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2l0ZXJhdG9yMiA9IE9iamVjdC5rZXlzKGxpc3RlbmVycyksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiYnJlYWtcIiA9PT0gX2xvb3AoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBCYXNlQ29tcG9uZW50O1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbXBvbmVudC9jaGlsZC9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLkNoaWxkQ29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0sIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSwgX2NsaWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9pbmRleC5qc1wiKSwgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9iYXNlLmpzXCIpLCBfd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC93aW5kb3cuanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpLCBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSwgX2Vycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2Vycm9yLmpzXCIpLCBfcHJvcHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NoaWxkL3Byb3BzLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZikgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5DaGlsZENvbXBvbmVudCA9IGZ1bmN0aW9uKF9CYXNlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHN1cGVyQ2xhc3MgJiYgbnVsbCAhPT0gc3VwZXJDbGFzcykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgKE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9KENoaWxkQ29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ2hpbGRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIENoaWxkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNWYWxpZFBhcmVudERvbWFpbigpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvcihuZXcgX2Vycm9yLlJlbmRlckVycm9yKFwiQ2FuIG5vdCBiZSByZW5kZXJlZCBieSBkb21haW46IFwiICsgX3RoaXMuZ2V0UGFyZW50RG9tYWluKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmxvZyhcImNvbnN0cnVjdF9jaGlsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Qcm9wSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2FyciA9IFsgX3RoaXMuY29tcG9uZW50LCB3aW5kb3cgXSwgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGl0ZW0gPSBfYXJyW19pXSwgX2FycjIgPSBbIFsgXCJ4Y2hpbGRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBdLCBbIFwieHByb3BzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXSBdLCBfbG9vcDIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FycjIkX2kgPSBfYXJyMltfaTJdLCBuYW1lID0gX2FycjIkX2lbMF0sIGdldHRlciA9IF9hcnIyJF9pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdGVtLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcyB8fCBfdGhpcy5zZXRQcm9wcyhfdGhpcy5nZXRJbml0aWFsUHJvcHMoKSwgKDAsIF93aW5kb3cuZ2V0UGFyZW50RG9tYWluKSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdGVtW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtuYW1lXSA9IGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9pMiA9IDA7IF9pMiA8IF9hcnIyLmxlbmd0aDsgX2kyKyspIF9sb29wMigpO1xuICAgICAgICAgICAgICAgICAgICB9LCBfaSA9IDA7IF9pIDwgX2Fyci5sZW5ndGg7IF9pKyspIF9sb29wKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5sb2coXCJpbml0X2NoaWxkXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxpc3RlbkZvclJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkluaXQgPSBfdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuSU5JVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogX3RoaXMuZXhwb3J0cygpXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IF9yZWYub3JpZ2luLCBkYXRhID0gX3JlZi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dCA9IGRhdGEuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFByb3BzKGRhdGEucHJvcHMsIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53YXRjaEZvclJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW5Gb3JSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5saXN0ZW5Gb3JSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFRvUGFyZW50KF9jb25zdGFudHMuUE9TVF9NRVNTQUdFLk9OUkVTSVpFLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuT05SRVNJWkUsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmhhc1ZhbGlkUGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3NyYy5tYXRjaERvbWFpbikodGhpcy5jb21wb25lbnQuYWxsb3dlZFBhcmVudERvbWFpbnMsIHRoaXMuZ2V0UGFyZW50RG9tYWluKCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Jbml0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmdldFBhcmVudERvbWFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF93aW5kb3cuZ2V0UGFyZW50RG9tYWluKSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLm9uUHJvcHMgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Qcm9wSGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfd2luZG93LmdldFBhcmVudENvbXBvbmVudFdpbmRvdykoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQYXJlbnRSZW5kZXJXaW5kb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfd2luZG93LmdldFBhcmVudFJlbmRlcldpbmRvdykoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRJbml0aWFsUHJvcHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXMsIGNvbXBvbmVudE1ldGEgPSAoMCwgX3dpbmRvdy5nZXRDb21wb25lbnRNZXRhKSgpLCBwcm9wcyA9IGNvbXBvbmVudE1ldGEucHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy50eXBlID09PSBfY29uc3RhbnRzLklOSVRJQUxfUFJPUFMuUkFXKSBwcm9wcyA9IHByb3BzLnZhbHVlOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy50eXBlICE9PSBfY29uc3RhbnRzLklOSVRJQUxfUFJPUFMuVUlEKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgcHJvcHMgdHlwZTogXCIgKyBwcm9wcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb21wb25lbnRXaW5kb3cgPSAoMCwgX3dpbmRvdy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjLmlzU2FtZURvbWFpbikocGFyZW50Q29tcG9uZW50V2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZpbGU6XCIgPT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBnZXQgcHJvcHMgZnJvbSBmaWxlOi8vIGRvbWFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgY29tcG9uZW50IHdpbmRvdyBpcyBvbiBhIGRpZmZlcmVudCBkb21haW4gLSBleHBlY3RlZCBcIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjLmdldERvbWFpbikoKSArIFwiIC0gY2FuIG5vdCByZXRyaWV2ZSBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbG9iYWwgPSAoMCwgX2xpYi5nbG9iYWxGb3IpKHBhcmVudENvbXBvbmVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWdsb2JhbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGdsb2JhbCBmb3IgcGFyZW50IGNvbXBvbmVudCAtIGNhbiBub3QgcmV0cmlldmUgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcyA9IEpTT04ucGFyc2UoZ2xvYmFsLnByb3BzW2NvbXBvbmVudE1ldGEudWlkXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcykgdGhyb3cgbmV3IEVycm9yKFwiSW5pdGlhbCBwcm9wcyBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5kZXNlcmlhbGl6ZUZ1bmN0aW9ucykocHJvcHMsIGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbEtleSA9IF9yZWYyLmZ1bGxLZXksIHNlbGYgPSBfcmVmMi5zZWxmLCBhcmdzID0gX3JlZjIuYXJncztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMub25Jbml0LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmMgPSAoMCwgX2xpYi5nZXQpKF90aGlzMy5wcm9wcywgZnVsbEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZnVuYykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFwiICsgZnVsbEtleSArIFwiIHRvIGJlIGZ1bmN0aW9uLCBnb3QgXCIgKyAodm9pZCAwID09PSBmdW5jID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZnVuYykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uKHByb3BzLCBvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVpcmVkID0gIShhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSkgfHwgYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzID0gdGhpcy5wcm9wcyB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wcyA9ICgwLCBfcHJvcHMubm9ybWFsaXplQ2hpbGRQcm9wcykodGhpcy5jb21wb25lbnQsIHByb3BzLCBvcmlnaW4sIHJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuZXh0ZW5kKSh0aGlzLnByb3BzLCBub3JtYWxpemVkUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmxvZ0xldmVsICYmICgwLCBfbGliLnNldExvZ0xldmVsKSh0aGlzLnByb3BzLmxvZ0xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IHRoaXMub25Qcm9wSGFuZGxlcnMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcltfaTMrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMy5jYWxsKHRoaXMsIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuc2VuZFRvUGFyZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDoge30sIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9LCBwYXJlbnRXaW5kb3cgPSAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3cuZ2V0UGFyZW50Q29tcG9uZW50V2luZG93KSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIHBhcmVudCBjb21wb25lbnQgd2luZG93IHRvIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZyhcInNlbmRfdG9fcGFyZW50X1wiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3NyYzIuc2VuZCkocGFyZW50V2luZG93LCBuYW1lLCBkYXRhLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46ICgwLCBfd2luZG93LmdldFBhcmVudERvbWFpbikoKVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuc2V0V2luZG93cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93Ll9fYWN0aXZlWm9pZENvbXBvbmVudF9fKSB0aHJvdyB0aGlzLmNvbXBvbmVudC5jcmVhdGVFcnJvcihcIkNhbiBub3QgYXR0YWNoIG11bHRpcGxlIGNvbXBvbmVudHMgdG8gdGhlIHNhbWUgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuX19hY3RpdmVab2lkQ29tcG9uZW50X18gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfd2luZG93LmdldFBhcmVudENvbXBvbmVudFdpbmRvdykoKSkgdGhyb3cgdGhpcy5jb21wb25lbnQuY3JlYXRlRXJyb3IoXCJDYW4gbm90IGZpbmQgcGFyZW50IHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudE1ldGEgPSAoMCwgX3dpbmRvdy5nZXRDb21wb25lbnRNZXRhKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50TWV0YS50YWcgIT09IHRoaXMuY29tcG9uZW50LnRhZykgdGhyb3cgdGhpcy5jb21wb25lbnQuY3JlYXRlRXJyb3IoXCJQYXJlbnQgaXMgXCIgKyBjb21wb25lbnRNZXRhLnRhZyArIFwiIC0gY2FuIG5vdCBhdHRhY2ggXCIgKyB0aGlzLmNvbXBvbmVudC50YWcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndhdGNoRm9yQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS53YXRjaEZvckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQuY2hlY2tDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVBdXRvUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge30sIF9yZWY0JHdpZHRoID0gX3JlZjQud2lkdGgsIHdpZHRoID0gdm9pZCAwID09PSBfcmVmNCR3aWR0aCB8fCBfcmVmNCR3aWR0aCwgX3JlZjQkaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWY0JGhlaWdodCB8fCBfcmVmNCRoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hGb3JSZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBdXRvUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9ICExLCBoZWlnaHQgPSAhMSwgYXV0b1Jlc2l6ZSA9IHRoaXMuYXV0b1Jlc2l6ZSB8fCB0aGlzLmNvbXBvbmVudC5hdXRvUmVzaXplO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gYXV0b1Jlc2l6ZSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGF1dG9SZXNpemUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBCb29sZWFuKGF1dG9SZXNpemUud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gQm9vbGVhbihhdXRvUmVzaXplLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXV0b1Jlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGF1dG9SZXNpemUuZWxlbWVudCA/ICgwLCBfbGliLmdldEVsZW1lbnQpKGF1dG9SZXNpemUuZWxlbWVudCkgOiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRSAoOXwxMClcXC4vKSA/IGRvY3VtZW50LmJvZHkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS53YXRjaEZvclJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcywgX2dldEF1dG9SZXNpemUgPSB0aGlzLmdldEF1dG9SZXNpemUoKSwgd2lkdGggPSBfZ2V0QXV0b1Jlc2l6ZS53aWR0aCwgaGVpZ2h0ID0gX2dldEF1dG9SZXNpemUuaGVpZ2h0LCBlbGVtZW50ID0gX2dldEF1dG9SZXNpemUuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh3aWR0aCB8fCBoZWlnaHQpICYmIHRoaXMuY29udGV4dCAhPT0gX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLlBPUFVQICYmICF0aGlzLndhdGNoaW5nRm9yUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhdGNoaW5nRm9yUmVzaXplID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2xpYi5kb2N1bWVudFJlYWR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfbGliLmRpbWVuc2lvbnNNYXRjaFZpZXdwb3J0KShlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkgcmV0dXJuIF90aGlzNS5yZXNpemVUb0VsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5jeWNsZSkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5vbkRpbWVuc2lvbnNDaGFuZ2UpKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1LnJlc2l6ZVRvRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnNldFByb3BzKHByb3BzLCBfdGhpczYub3JpZ2luLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNy5jb21wb25lbnQubG9nKFwicmVzaXplXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogKDAsIF9saWIuc3RyaW5naWZ5KSh3aWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAoMCwgX2xpYi5zdHJpbmdpZnkpKGhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzNy5jb250ZXh0ICE9PSBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVApIHJldHVybiBfdGhpczcuc2VuZFRvUGFyZW50KF9jb25zdGFudHMuUE9TVF9NRVNTQUdFLlJFU0laRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5yZXNpemVUb0VsZW1lbnQgPSBmdW5jdGlvbihlbCwgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzOCA9IHRoaXMsIHdpZHRoID0gX3JlZjUud2lkdGgsIGhlaWdodCA9IF9yZWY1LmhlaWdodCwgaGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrZXIgPSAoMCwgX2xpYi50cmFja0RpbWVuc2lvbnMpKGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZGltZW5zaW9ucyA9IHRyYWNrZXIuY2hlY2soKS5kaW1lbnNpb25zLCBfaXRlcmF0b3IyID0gaGlzdG9yeSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2k0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gX2l0ZXJhdG9yMltfaTQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNCA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gX3JlZjYsIHdpZHRoTWF0Y2ggPSAhd2lkdGggfHwgc2l6ZS53aWR0aCA9PT0gZGltZW5zaW9ucy53aWR0aCwgaGVpZ2h0TWF0Y2ggPSAhaGVpZ2h0IHx8IHNpemUuaGVpZ2h0ID09PSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoTWF0Y2ggJiYgaGVpZ2h0TWF0Y2gpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4LnJlc2l6ZSh3aWR0aCA/IGRpbWVuc2lvbnMud2lkdGggOiBudWxsLCBoZWlnaHQgPyBkaW1lbnNpb25zLmhlaWdodCA6IG51bGwpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2VyLmNoZWNrKCkuY2hhbmdlZCkgcmV0dXJuIHJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ISURFKS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuU0hPVykudGhlbihfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLnVzZXJDbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZShfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuVVNFUl9DTE9TRUQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5DSElMRF9DQUxMO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5sb2coXCJjbG9zZV9jaGlsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuQ0xPU0UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuQ0hFQ0tfQ0xPU0UsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2NsaWVudC5mbHVzaCkoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZyhcImZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaW5naWZpZWRFcnJvciA9ICgwLCBfbGliLnN0cmluZ2lmeUVycm9yKShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5sb2dFcnJvcihcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBzdHJpbmdpZmllZEVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBzdHJpbmdpZmllZEVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oX2xpYi5ub29wKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBDaGlsZENvbXBvbmVudDtcbiAgICAgICAgICAgIH0oX2Jhc2UuQmFzZUNvbXBvbmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2NoaWxkL3Byb3BzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMubm9ybWFsaXplQ2hpbGRQcm9wID0gbm9ybWFsaXplQ2hpbGRQcm9wO1xuICAgICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVDaGlsZFByb3BzID0gZnVuY3Rpb24oY29tcG9uZW50LCBwcm9wcywgb3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdKSB8fCBhcmd1bWVudHNbM10sIHJlc3VsdCA9IHt9LCBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhwcm9wcyksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfa2V5ID0gX3JlZiwgcHJvcCA9IGNvbXBvbmVudC5nZXRQcm9wKF9rZXkpLCB2YWx1ZSA9IHByb3BzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3AgfHwgIXByb3Auc2FtZURvbWFpbiB8fCBvcmlnaW4gPT09ICgwLCBfc3JjLmdldERvbWFpbikod2luZG93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W19rZXldID0gbm9ybWFsaXplQ2hpbGRQcm9wKGNvbXBvbmVudCwgcHJvcHMsIF9rZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgJiYgcHJvcC5hbGlhcyAmJiAhcmVzdWx0W3Byb3AuYWxpYXNdICYmIChyZXN1bHRbcHJvcC5hbGlhc10gPSB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkKSBmb3IgKHZhciBfaXRlcmF0b3IyID0gY29tcG9uZW50LmdldFByb3BOYW1lcygpLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGtleSkgfHwgKHJlc3VsdFtrZXldID0gbm9ybWFsaXplQ2hpbGRQcm9wKGNvbXBvbmVudCwgcHJvcHMsIGtleSwgcHJvcHNba2V5XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVDaGlsZFByb3AoY29tcG9uZW50LCBwcm9wcywga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gY29tcG9uZW50LmdldFByb3Aoa2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcCA/IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5jaGlsZERlY29yYXRlID8gcHJvcC5jaGlsZERlY29yYXRlKHZhbHVlKSA6IHZhbHVlIDogY29tcG9uZW50Lmxvb3NlUHJvcHMgPyB2YWx1ZSA6IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuQ29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9jbGFzcywgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9LCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIiksIF9jaGlsZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvY2hpbGQvaW5kZXguanNcIiksIF9wYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L3BhcmVudC9pbmRleC5qc1wiKSwgX2RlbGVnYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9kZWxlZ2F0ZS9pbmRleC5qc1wiKSwgX3dpbmRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvd2luZG93LmpzXCIpLCBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSwgX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpLCBfdmFsaWRhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC92YWxpZGF0ZS5qc1wiKSwgX3RlbXBsYXRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3RlbXBsYXRlcy9pbmRleC5qc1wiKSwgX3Byb3BzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvcHJvcHMuanNcIik7XG4gICAgICAgICAgICB2YXIgZHJpdmVycyA9IHtcbiAgICAgICAgICAgICAgICBhbmd1bGFyOiBfaW5kZXguYW5ndWxhcixcbiAgICAgICAgICAgICAgICBhbmd1bGFyMjogX2luZGV4LmFuZ3VsYXIyLFxuICAgICAgICAgICAgICAgIGdsaW1tZXI6IF9pbmRleC5nbGltbWVyLFxuICAgICAgICAgICAgICAgIHJlYWN0OiBfaW5kZXgucmVhY3QsXG4gICAgICAgICAgICAgICAgdnVlOiBfaW5kZXgudnVlLFxuICAgICAgICAgICAgICAgIHNjcmlwdDogX2luZGV4LnNjcmlwdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChleHBvcnRzLkNvbXBvbmVudCA9IChmdW5jdGlvbih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuICAgICAgICAgICAgICAgIChcInZhbHVlXCIgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSAmJiAoZGVzYy53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgICAgICB9LCBkZXNjKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiB2b2lkIDAgIT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KChfY2xhc3MgPSBmdW5jdGlvbihfQmFzZUNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbihzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBzdXBlckNsYXNzICYmIG51bGwgIT09IHN1cGVyQ2xhc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgfShDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBmdW5jdGlvbihzZWxmLCBjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3ZhbGlkYXRlLnZhbGlkYXRlKShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcInRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImRlZmF1bHRMb2dMZXZlbFwiLCBcImluZm9cIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJhbGxvd2VkUGFyZW50RG9tYWluc1wiLCBfY29uc3RhbnRzLldJTERDQVJEKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuc2V0TG9nTGV2ZWwpKF90aGlzLmRlZmF1bHRMb2dMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50c1tfdGhpcy50YWddKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJuYW1lXCIsIF90aGlzLnRhZy5yZXBsYWNlKC8tL2csIFwiX1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJ1aWx0aW5Qcm9wcyA9ICgwLCBfcHJvcHMuZ2V0SW50ZXJuYWxQcm9wcykoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMgPSBvcHRpb25zLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnByb3BzIHx8IChfdGhpcy5sb29zZVByb3BzID0gITApO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiZGltZW5zaW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcInNjcm9sbGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImxpc3RlbkZvclJlc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcInZlcnNpb25cIiwgXCJsYXRlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJkZWZhdWx0RW52XCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiYnVpbGRVcmxcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJ1cmxcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJkb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJicmlkZ2VVcmxcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJicmlkZ2VEb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJhdHRyaWJ1dGVzXCIsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImNvbnRleHRzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3B1cDogITFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJkZWZhdWx0Q29udGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImF1dG9SZXNpemVcIiwgITEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiY29udGFpbmVyVGVtcGxhdGVcIiwgX3RlbXBsYXRlcy5kZWZhdWx0Q29udGFpbmVyVGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwicHJlcmVuZGVyVGVtcGxhdGVcIiwgX3RlbXBsYXRlcy5kZWZhdWx0UHJlcmVuZGVyVGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwidmFsaWRhdGVcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJ1bnNhZmVSZW5kZXJUb1wiLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudC5jb21wb25lbnRzW190aGlzLnRhZ10gPSBfdGhpcztcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXJEcml2ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyQ2hpbGQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuRGVsZWdhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldFByb3BOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzKSwgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXModGhpcy5idWlsdGluUHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgLTEgPT09IHByb3BzLmluZGV4T2Yoa2V5KSAmJiBwcm9wcy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRQcm9wID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wc1tuYW1lXSB8fCB0aGlzLmJ1aWx0aW5Qcm9wc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVnaXN0ZXJEcml2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJpdmVyQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhkcml2ZXJzKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJpdmVyTmFtZSA9IF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgIT09IGRyaXZlck5hbWUuaW5kZXhPZihcIl9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2xvYiA9IGRyaXZlcnNbZHJpdmVyTmFtZV0uZ2xvYmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYiAmJiB0aGlzLmRyaXZlcihkcml2ZXJOYW1lLCBnbG9iKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5kcml2ZXIgPSBmdW5jdGlvbihuYW1lLCBkZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkcml2ZXJzW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBkcml2ZXIgZm9yIGZyYW1ld29yazogXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcml2ZXJDYWNoZVtuYW1lXSB8fCAodGhpcy5kcml2ZXJDYWNoZVtuYW1lXSA9IGRyaXZlcnNbbmFtZV0ucmVnaXN0ZXIodGhpcywgZGVwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlckNhY2hlW25hbWVdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckNoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIuaXNDaGlsZCgpKSByZXR1cm4gbmV3IF9jaGlsZC5DaGlsZENvbXBvbmVudChfdGhpczIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUubGlzdGVuRGVsZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc3JjLm9uKShfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5BTExPV19ERUxFR0FURSArIFwiX1wiICsgdGhpcy5uYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc3JjLm9uKShfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ERUxFR0FURSArIFwiX1wiICsgdGhpcy5uYW1lLCBmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYzLnNvdXJjZSwgb3JpZ2luID0gX3JlZjMub3JpZ2luLCBkYXRhID0gX3JlZjMuZGF0YSwgZG9tYWluID0gX3RoaXMzLmdldERvbWFpbihudWxsLCBkYXRhLmVudiB8fCBfdGhpczMuZGVmYXVsdEVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBkb21haW4gdG8gYWxsb3cgcmVtb3RlIHJlbmRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMzLm1hdGNoRG9tYWluKShkb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVuZGVyIGZyb20gXCIgKyBvcmlnaW4gKyBcIiAtIGV4cGVjdGVkIFwiICsgZG9tYWluLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gX3RoaXMzLmRlbGVnYXRlKHNvdXJjZSwgZGF0YS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiBkZWxlZ2F0ZS5nZXRPdmVycmlkZXMoZGF0YS5jb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuY2FuUmVuZGVyVG8gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc3JjLnNlbmQpKHdpbiwgX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuQUxMT1dfREVMRUdBVEUgKyBcIl9cIiArIHRoaXMubmFtZSkudGhlbihmdW5jdGlvbihfcmVmNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0VmFsaWREb21haW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKSh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHRoaXMuZG9tYWluICYmIGRvbWFpbiA9PT0gdGhpcy5kb21haW4pIHJldHVybiBkb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWlucyA9IHRoaXMuZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbnMgJiYgXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gZG9tYWlucyA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvbWFpbnMpKSAmJiAhKGRvbWFpbnMgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBPYmplY3Qua2V5cyhkb21haW5zKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yM1tfaTMrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2kzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIiAhPT0gX3JlZjUgJiYgZG9tYWluID09PSBkb21haW5zW19yZWY1XSkgcmV0dXJuIGRvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24odXJsLCBlbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRoaXMuZ2V0Rm9yRW52KHRoaXMuZG9tYWluLCBlbnYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluID0gdGhpcy5nZXRWYWxpZERvbWFpbih1cmwpKSByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW52VXJsID0gdGhpcy5nZXRGb3JFbnYodGhpcy51cmwsIGVudik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnZVcmwgPyAoMCwgX3NyYzMuZ2V0RG9tYWluRnJvbVVybCkoZW52VXJsKSA6IHVybCA/ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKSh1cmwpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRCcmlkZ2VVcmwgPSBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9yRW52KHRoaXMuYnJpZGdlVXJsLCBlbnYpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRGb3JFbnYgPSBmdW5jdGlvbihpdGVtLCBlbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtIHx8IGl0ZW0gaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW52IHx8IChlbnYgPSB0aGlzLmRlZmF1bHRFbnYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudikgcmV0dXJuIGVudiAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpICYmIGl0ZW1bZW52XSA/IGl0ZW1bZW52XSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRCcmlkZ2VEb21haW4gPSBmdW5jdGlvbihlbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyaWRnZURvbWFpbiA9IHRoaXMuZ2V0Rm9yRW52KHRoaXMuYnJpZGdlRG9tYWluLCBlbnYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnJpZGdlRG9tYWluKSByZXR1cm4gYnJpZGdlRG9tYWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnJpZGdlVXJsID0gdGhpcy5nZXRCcmlkZ2VVcmwoZW52KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyaWRnZVVybCA/ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKShicmlkZ2VVcmwpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRVcmwgPSBmdW5jdGlvbihlbnYsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLmdldEZvckVudih0aGlzLnVybCwgZW52KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybCkgcmV0dXJuIHVybDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRVcmwpIHJldHVybiB0aGlzLmJ1aWxkVXJsKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCB1cmxcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmlzWm9pZENvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF93aW5kb3cuaXNab2lkQ29tcG9uZW50V2luZG93KSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pc0NoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3dpbmRvdy5pc1pvaWRDb21wb25lbnRXaW5kb3cpKCkgJiYgKDAsIF93aW5kb3cuZ2V0Q29tcG9uZW50TWV0YSkoKS50YWcgPT09IHRoaXMudGFnO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFwiW1wiICsgKHRhZyB8fCB0aGlzLnRhZykgKyBcIl0gXCIgKyBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHByb3BzLCBjb250ZXh0LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3BhcmVudC5QYXJlbnRDb21wb25lbnQodGhpcywgdGhpcy5nZXRSZW5kZXJDb250ZXh0KGNvbnRleHQsIGVsZW1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24oc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX2RlbGVnYXRlLkRlbGVnYXRlQ29tcG9uZW50KHRoaXMsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnZhbGlkYXRlUmVuZGVyQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgIXRoaXMuY29udGV4dHNbY29udGV4dF0pIHRocm93IG5ldyBFcnJvcihcIltcIiArIHRoaXMudGFnICsgXCJdIENhbiBub3QgcmVuZGVyIHRvIFwiICsgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCAmJiBjb250ZXh0ID09PSBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuSUZSQU1FKSB0aHJvdyBuZXcgRXJyb3IoXCJbXCIgKyB0aGlzLnRhZyArIFwiXSBDb250ZXh0IHR5cGUgXCIgKyBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuSUZSQU1FICsgXCIgcmVxdWlyZXMgYW4gZWxlbWVudCBzZWxlY3RvclwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdENvbnRleHQpIHJldHVybiB0aGlzLmRlZmF1bHRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0c1tfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuSUZSQU1FXSkgcmV0dXJuIF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRzW19jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUF0pIHJldHVybiBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVA7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGRlZmF1bHQgY29udGV4dFwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmVuZGVyQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5nZXREZWZhdWx0Q29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVuZGVyQ29udGV4dChjb250ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3BhcmVudC5QYXJlbnRDb21wb25lbnQoX3RoaXM0LCBfdGhpczQuZ2V0UmVuZGVyQ29udGV4dChudWxsLCBlbGVtZW50KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVySWZyYW1lID0gZnVuY3Rpb24ocHJvcHMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudChfdGhpczUsIF90aGlzNS5nZXRSZW5kZXJDb250ZXh0KF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUUsIGVsZW1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW5kZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJQb3B1cCA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3BhcmVudC5QYXJlbnRDb21wb25lbnQoX3RoaXM2LCBfdGhpczYuZ2V0UmVuZGVyQ29udGV4dChfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVApLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclRvID0gZnVuY3Rpb24od2luLCBwcm9wcywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9wYXJlbnQuUGFyZW50Q29tcG9uZW50KF90aGlzNywgX3RoaXM3LmdldFJlbmRlckNvbnRleHQobnVsbCwgZWxlbWVudCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlclRvKHdpbiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJJZnJhbWVUbyA9IGZ1bmN0aW9uKHdpbiwgcHJvcHMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudChfdGhpczgsIF90aGlzOC5nZXRSZW5kZXJDb250ZXh0KF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUUsIGVsZW1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW5kZXJUbyh3aW4sIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyUG9wdXBUbyA9IGZ1bmN0aW9uKHdpbiwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudChfdGhpczksIF90aGlzOS5nZXRSZW5kZXJDb250ZXh0KF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlclRvKHdpbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5wcmVyZW5kZXIgPSBmdW5jdGlvbihwcm9wcywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgX3BhcmVudC5QYXJlbnRDb21wb25lbnQodGhpcywgdGhpcy5nZXRSZW5kZXJDb250ZXh0KG51bGwsIGVsZW1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnByZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGlubmVyUHJvcHMsIGlubmVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyUHJvcHMgJiYgaW5zdGFuY2UudXBkYXRlUHJvcHMoaW5uZXJQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlcihpbm5lckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRvOiBmdW5jdGlvbih3aW4sIGlubmVyUHJvcHMsIGlubmVyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyUHJvcHMgJiYgaW5zdGFuY2UudXBkYXRlUHJvcHMoaW5uZXJQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlclRvKHdpbiwgaW5uZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgaHRtbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuaHRtbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgaHRtbCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmh0bWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5pbmZvKSh0aGlzLm5hbWUsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUubG9nV2FybmluZyA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLndhcm4pKHRoaXMubmFtZSwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2dFcnJvciA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmVycm9yKSh0aGlzLm5hbWUsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5nZXRCeVRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50LmNvbXBvbmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICAgICAgICB9KF9iYXNlLkJhc2VDb21wb25lbnQpKS5wcm90b3R5cGUsIFwiZ2V0UHJvcE5hbWVzXCIsIFsgX2xpYi5tZW1vaXplIF0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJnZXRQcm9wTmFtZXNcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9jbGFzcykpLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3Byb3BzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SW50ZXJuYWxQcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVudjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW06ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0RW52O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtOiAhMFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2dMZXZlbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW06ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TG9nTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVybDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW06ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9vcDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnk6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25FbnRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9vcDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnk6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICExXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uUmVuZGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBub29wOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9vcDogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25UaW1lb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vaXplOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikgcmV0dXJuIHRoaXMucHJvcHMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzaWZ5OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIHZhciBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy90eXBlcy5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3RlbXBsYXRlcy9jb21wb25lbnQuanN4XCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdFByZXJlbmRlclRlbXBsYXRlID0gZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciBqc3hEb20gPSBfcmVmLmpzeERvbTtcbiAgICAgICAgICAgICAgICByZXR1cm4ganN4RG9tKFwiaHRtbFwiLCBudWxsLCBqc3hEb20oXCJoZWFkXCIsIG51bGwsIGpzeERvbShcInN0eWxlXCIsIG51bGwsIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCwgYm9keSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGlubmVyIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXgtaGVpZ2h0OiA2MHZtaW47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heC13aWR0aDogNjB2bWluO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDQwcHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0MHB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDUwJTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogNTAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgei1pbmRleDogMTA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGlubmVyIC5sb2FkZXIge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDNweCBzb2xpZCByZ2JhKDAsIDAsIDAsIC4yKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXRvcC1jb2xvcjogcmdiYSgzMywgMTI4LCAxOTIsIDAuOCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogcm90YXRpb24gLjdzIGluZmluaXRlIGxpbmVhcjtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgQGtleWZyYW1lcyByb3RhdGlvbiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20ge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNTlkZWcpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBcIikpLCBqc3hEb20oXCJib2R5XCIsIG51bGwsIGpzeERvbShcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcInNwaW5uZXJcIlxuICAgICAgICAgICAgICAgIH0sIGpzeERvbShcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBcImxvYWRlclwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJsb2FkZXJcIlxuICAgICAgICAgICAgICAgIH0pKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvdGVtcGxhdGVzL2NvbnRhaW5lci5qc3hcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0Q29udGFpbmVyVGVtcGxhdGUgPSBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX3JlZi5pZCwgdGFnID0gX3JlZi50YWcsIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIENMQVNTID0gX3JlZi5DTEFTUywgb3V0bGV0ID0gX3JlZi5vdXRsZXQsIGpzeERvbSA9IF9yZWYuanN4RG9tLCBfcmVmJGRpbWVuc2lvbnMgPSBfcmVmLmRpbWVuc2lvbnMsIHdpZHRoID0gX3JlZiRkaW1lbnNpb25zLndpZHRoLCBoZWlnaHQgPSBfcmVmJGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBqc3hEb20oXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBDTEFTUy5aT0lEICsgXCIgXCIgKyBDTEFTUy5aT0lEICsgXCItdGFnLVwiICsgdGFnICsgXCIgXCIgKyBDTEFTUy5aT0lEICsgXCItY29udGV4dC1cIiArIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9LCBqc3hEb20oXCJzdHlsZVwiLCBudWxsLCBcIlxcbiAgICAgICAgICAgICAgICAgICAgI1wiICsgaWQgKyBcIiwgI1wiICsgaWQgKyBcIiA+IC5cIiArIENMQVNTLk9VVExFVCArIFwiIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogXCIgKyB3aWR0aCArIFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyBoZWlnaHQgKyBcIjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICNcIiArIGlkICsgXCIgPiAuXCIgKyBDTEFTUy5PVVRMRVQgKyBcIiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICNcIiArIGlkICsgXCIgPiAuXCIgKyBDTEFTUy5PVVRMRVQgKyBcIiA+IGlmcmFtZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IC4ycyBlYXNlLWluLW91dDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICNcIiArIGlkICsgXCIgPiAuXCIgKyBDTEFTUy5PVVRMRVQgKyBcIiA+IGlmcmFtZS5cIiArIENMQVNTLlZJU0lCTEUgKyBcIiB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICNcIiArIGlkICsgXCIgPiAuXCIgKyBDTEFTUy5PVVRMRVQgKyBcIiA+IGlmcmFtZS5cIiArIENMQVNTLklOVklTSUJMRSArIFwiIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcIiksIG91dGxldCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC90ZW1wbGF0ZXMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9jb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC90ZW1wbGF0ZXMvY29udGFpbmVyLmpzeFwiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb250YWluZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRhaW5lcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvdGVtcGxhdGVzL2NvbXBvbmVudC5qc3hcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfY29tcG9uZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb21wb25lbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC92YWxpZGF0ZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjcmVkIG9wdGlvbnMgdG8gYmUgcGFzc2VkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy50YWcgfHwgIW9wdGlvbnMudGFnLm1hdGNoKC9eW2EtejAtOS1dKyQvKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcHRpb25zLnRhZzogXCIgKyBvcHRpb25zLnRhZyk7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvcHMgJiYgXCJvYmplY3RcIiAhPT0gX3R5cGVvZihvcHRpb25zLnByb3BzKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy5wcm9wcyB0byBiZSBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb3BzKSBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhvcHRpb25zLnByb3BzKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9yZWYsIHByb3AgPSBvcHRpb25zLnByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3AgfHwgXCJvYmplY3RcIiAhPT0gKHZvaWQgMCA9PT0gcHJvcCA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHByb3ApKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy5wcm9wcy5cIiArIGtleSArIFwiIHRvIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcC50eXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm9wLnR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9jb25zdGFudHMuUFJPUF9UWVBFU19MSVNULmluZGV4T2YocHJvcC50eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgcHJvcC50eXBlIHRvIGJlIG9uZSBvZiBcIiArIF9jb25zdGFudHMuUFJPUF9UWVBFU19MSVNULmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5yZXF1aXJlZCAmJiBwcm9wLmRlZikgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZWQgcHJvcCBjYW4gbm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpbWVuc2lvbnMgJiYgISgwLCBfbGliLmlzUHgpKG9wdGlvbnMuZGltZW5zaW9ucy53aWR0aCkgJiYgISgwLCBfbGliLmlzUGVyYykob3B0aW9ucy5kaW1lbnNpb25zLndpZHRoKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy5kaW1lbnNpb25zLndpZHRoIHRvIGJlIGEgcHggb3IgJSBzdHJpbmcgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpbWVuc2lvbnMgJiYgISgwLCBfbGliLmlzUHgpKG9wdGlvbnMuZGltZW5zaW9ucy5oZWlnaHQpICYmICEoMCwgX2xpYi5pc1BlcmMpKG9wdGlvbnMuZGltZW5zaW9ucy5oZWlnaHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLmRpbWVuc2lvbnMuaGVpZ2h0IHRvIGJlIGEgcHggb3IgJSBzdHJpbmcgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRleHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRleHRzLnBvcHVwKSB0aHJvdyBuZXcgRXJyb3IoXCJQb3B1cHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIC0tIHBsZWFzZSB1c2UgdGhlIGZ1bGwgem9pZC5qcyBidWlsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYW55RW5hYmxlZCA9ICExLCBfaXRlcmF0b3IyID0gT2JqZWN0LmtleXMob3B0aW9ucy5jb250ZXh0cyksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFU19MSVNULmluZGV4T2YoY29udGV4dCkpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbnRleHQgdHlwZTogXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmNvbnRleHRzICYmIG9wdGlvbnMuY29udGV4dHNbY29udGV4dF0gfHwgb3B0aW9ucy5jb250ZXh0cyAmJiB2b2lkIDAgPT09IG9wdGlvbnMuY29udGV4dHNbY29udGV4dF0pICYmIChhbnlFbmFibGVkID0gITApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW55RW5hYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGV4dCB0eXBlIGlzIGVuYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX2NvbnN0YW50cy5DT05URVhUX1RZUEVTX0xJU1QuaW5kZXhPZihvcHRpb25zLmRlZmF1bHRDb250ZXh0KSkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY29udGV4dCB0eXBlOiBcIiArIChvcHRpb25zLmRlZmF1bHRDb250ZXh0IHx8IFwidW5rbm93blwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRleHRzICYmIG9wdGlvbnMuZGVmYXVsdENvbnRleHQgJiYgIW9wdGlvbnMuY29udGV4dHNbb3B0aW9ucy5kZWZhdWx0Q29udGV4dF0pIHRocm93IG5ldyBFcnJvcihcIkRpc2FsbG93ZWQgZGVmYXVsdCBjb250ZXh0IHR5cGU6IFwiICsgKG9wdGlvbnMuZGVmYXVsdENvbnRleHQgfHwgXCJ1bmtub3duXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsICYmIG9wdGlvbnMuYnVpbGRVcmwpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcGFzcyBib3RoIG9wdGlvbnMudXJsIGFuZCBvcHRpb25zLmJ1aWxkVXJsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRFbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIG9wdGlvbnMuZGVmYXVsdEVudikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMuZGVmYXVsdEVudiB0byBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmJ1aWxkVXJsICYmIFwib2JqZWN0XCIgIT09IF90eXBlb2Yob3B0aW9ucy51cmwpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnVybCB0byBiZSBhbiBvYmplY3QgbWFwcGluZyBlbnYtPnVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2Yob3B0aW9ucy51cmwpICYmICFvcHRpb25zLnVybFtvcHRpb25zLmRlZmF1bHRFbnZdKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB1cmwgZm91bmQgZm9yIGRlZmF1bHQgZW52OiBcIiArIG9wdGlvbnMuZGVmYXVsdEVudik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVybCAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdEVudikgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIG9wdGlvbnMuZGVmYXVsdEVudiB3aXRoIGVudi0+dXJsIG1hcHBpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBPYmplY3Qua2V5cyhvcHRpb25zLnVybCksIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnYgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51cmxbZW52XSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXJsIHNwZWNpZmllZCBmb3IgZW52OiBcIiArIGVudik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlcmVuZGVyVGVtcGxhdGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyVGVtcGxhdGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvZGVsZWdhdGUvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5EZWxlZ2F0ZUNvbXBvbmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCIgaW4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvUHJvcHMgJiYgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcyAmJiBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9iYXNlID0gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIikpLCBfcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvZHJpdmVycy5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLkRlbGVnYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24oX0Jhc2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0oRGVsZWdhdGVDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEZWxlZ2F0ZUNvbXBvbmVudChjb21wb25lbnQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBEZWxlZ2F0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IGZ1bmN0aW9uKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZikgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW4uc2V0KFwic291cmNlXCIsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBvcHRpb25zLnByb3BzLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IG9wdGlvbnMucHJvcHMuZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U6IG9wdGlvbnMucHJvcHMub25DbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheTogb3B0aW9ucy5wcm9wcy5vbkRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmdldFByb3AocHJvcE5hbWUpLmFsbG93RGVsZWdhdGUgJiYgKF90aGlzLnByb3BzW3Byb3BOYW1lXSA9IG9wdGlvbnMucHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMub3ZlcnJpZGVzLmZvY3VzLmNhbGwoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lGb2N1c092ZXJyaWRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBfbGliLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQ2xvc2UgPSBvcHRpb25zLm92ZXJyaWRlcy51c2VyQ2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdldERvbWFpbiA9IG9wdGlvbnMub3ZlcnJpZGVzLmdldERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBvcHRpb25zLm92ZXJyaWRlcy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub24gPSBvcHRpb25zLm92ZXJyaWRlcy5vbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlT3ZlcnJpZGVzID0gX2RyaXZlcnMuUkVOREVSX0RSSVZFUlNbb3B0aW9ucy5jb250ZXh0XS5kZWxlZ2F0ZU92ZXJyaWRlcywgX2l0ZXJhdG9yMiA9IE9iamVjdC5rZXlzKGRlbGVnYXRlT3ZlcnJpZGVzKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc1trZXldID0gX3BhcmVudC5QYXJlbnRDb21wb25lbnQucHJvdG90eXBlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRXaW5kb3dOYW1lID0gb3B0aW9ucy5jaGlsZFdpbmRvd05hbWU7XG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnQuUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckFjdGl2ZUNvbXBvbmVudC5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud2F0Y2hGb3JDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERlbGVnYXRlQ29tcG9uZW50LnByb3RvdHlwZS53YXRjaEZvckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMub25DbG9zZVdpbmRvdykodGhpcy5zb3VyY2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiLCBjbG9zZVdpbmRvd0xpc3RlbmVyLmNhbmNlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxlZ2F0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3ZlcnJpZGVzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVPdmVycmlkZXMgPSBfZHJpdmVycy5SRU5ERVJfRFJJVkVSU1tjb250ZXh0XS5kZWxlZ2F0ZU92ZXJyaWRlcywgb3ZlcnJpZGVzID0ge30sIHNlbGYgPSB0aGlzLCBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnQuUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZVtrZXldLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMoZGVsZWdhdGVPdmVycmlkZXMpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImJyZWFrXCIgPT09IF9sb29wKCkpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxlZ2F0ZUNvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhbi5hbGwoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEZWxlZ2F0ZUNvbXBvbmVudCwgWyB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJkcml2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IG5vdCBzZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2RyaXZlcnMuUkVOREVSX0RSSVZFUlNbdGhpcy5jb250ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbGVnYXRlQ29tcG9uZW50O1xuICAgICAgICAgICAgfShfYmFzZS5CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBvbmVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcGFyZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2NoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jaGlsZC9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jaGlsZCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L3BhcmVudC9kcml2ZXJzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuUkVOREVSX0RSSVZFUlMgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpLCBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSwgX3dpbmRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvd2luZG93LmpzXCIpLCBSRU5ERVJfRFJJVkVSUyA9IGV4cG9ydHMuUkVOREVSX0RSSVZFUlMgPSB7fTtcbiAgICAgICAgICAgIFJFTkRFUl9EUklWRVJTW19jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUVdID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzYWJsZTogITEsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGU6ICEwLFxuICAgICAgICAgICAgICAgIGFsbG93UmVzaXplOiAhMCxcbiAgICAgICAgICAgICAgICBvcGVuT25DbGljazogITEsXG4gICAgICAgICAgICAgICAgbmVlZHNCcmlkZ2U6ICExLFxuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLCBhdHRyaWJ1dGVzID0gdGhpcy5jb21wb25lbnQuYXR0cmlidXRlcy5pZnJhbWUgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lID0gKDAsIF9saWIuaWZyYW1lKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNoaWxkV2luZG93TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxpbmc6IHRoaXMuY29tcG9uZW50LnNjcm9sbGluZyA/IFwieWVzXCIgOiBcIm5vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFsgX2NvbnN0YW50cy5DTEFTU19OQU1FUy5DT01QT05FTlRfRlJBTUUsIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuSU5WSVNJQkxFIF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLmF3YWl0RnJhbWVXaW5kb3cpKHRoaXMuaWZyYW1lKS50aGVuKGZ1bmN0aW9uKGZyYW1lV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53aW5kb3cgPSBmcmFtZVdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXRlY3RDbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vbkNsb3NlKF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5DTE9TRV9ERVRFQ1RFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlmcmFtZVdhdGNoZXIgPSAoMCwgX2xpYi53YXRjaEVsZW1lbnRGb3JDbG9zZSkoX3RoaXMuaWZyYW1lLCBkZXRlY3RDbG9zZSksIGVsZW1lbnRXYXRjaGVyID0gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpYi53YXRjaEVsZW1lbnRGb3JDbG9zZSkoX3RoaXMuZWxlbWVudCwgZGV0ZWN0Q2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95V2luZG93XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZVdhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFdhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMyLmNsZWFuVXBXaW5kb3cpKF90aGlzLndpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLndpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmRlc3Ryb3lFbGVtZW50KShfdGhpcy5pZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcywgYXR0cmlidXRlcyA9IHRoaXMuY29tcG9uZW50LmF0dHJpYnV0ZXMuaWZyYW1lIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXJlbmRlcklmcmFtZSA9ICgwLCBfbGliLmlmcmFtZSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX19wcmVyZW5kZXJfX1wiICsgdGhpcy5jaGlsZFdpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsaW5nOiB0aGlzLmNvbXBvbmVudC5zY3JvbGxpbmcgPyBcInllc1wiIDogXCJub1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBbIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuUFJFUkVOREVSX0ZSQU1FLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLlZJU0lCTEUgXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuYXdhaXRGcmFtZVdpbmRvdykodGhpcy5wcmVyZW5kZXJJZnJhbWUpLnRoZW4oZnVuY3Rpb24ocHJlcmVuZGVyRnJhbWVXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5wcmVyZW5kZXJXaW5kb3cgPSBwcmVyZW5kZXJGcmFtZVdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lQcmVyZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5wcmVyZW5kZXJJZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuZGVzdHJveUVsZW1lbnQpKF90aGlzMi5wcmVyZW5kZXJJZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMyLnByZXJlbmRlcklmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hQcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuYWRkQ2xhc3MpKHRoaXMucHJlcmVuZGVySWZyYW1lLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLklOVklTSUJMRSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLnJlbW92ZUNsYXNzKSh0aGlzLnByZXJlbmRlcklmcmFtZSwgX2NvbnN0YW50cy5DTEFTU19OQU1FUy5WSVNJQkxFKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuYWRkQ2xhc3MpKHRoaXMuaWZyYW1lLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLlZJU0lCTEUpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5yZW1vdmVDbGFzcykodGhpcy5pZnJhbWUsIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuSU5WSVNJQkxFKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5wcmVyZW5kZXJJZnJhbWUgJiYgKDAsIF9saWIuZGVzdHJveUVsZW1lbnQpKF90aGlzMy5wcmVyZW5kZXJJZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVPdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95Q29tcG9uZW50OiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lDb250YWluZXI6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQ29udGFpbmVyRXZlbnRzOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZXJlbmRlclRlbXBsYXRlOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSZWFkeTogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q29udGFpbmVyOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDb21wb25lbnQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBoaWRlQ29tcG9uZW50OiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICByZXNpemU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZFVybDogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBoaWphY2tTdWJtaXQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hQcmVyZW5kZXI6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGVtcGxhdGU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTCxcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbnRhaW5lckZyYW1lOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIGdldE91dGxldDogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX09SSUdJTkFMLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmdW5jdGlvbihvcmlnaW5hbCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczQuY2xlYW4uc2V0KFwid2luZG93XCIsICgwLCBfc3JjMy5maW5kRnJhbWVCeU5hbWUpKCgwLCBfd2luZG93LmdldFBhcmVudENvbXBvbmVudFdpbmRvdykoKSwgX3RoaXM0LmNoaWxkV2luZG93TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzNC53aW5kb3cpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHBhcmVudCBjb21wb25lbnQgaWZyYW1lIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gKDAsIF9saWIudG9DU1MpKHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICgwLCBfbGliLnRvQ1NTKSh3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gKDAsIF9saWIudG9DU1MpKGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKDAsIF9saWIudG9DU1MpKGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5zaG93RWxlbWVudCkodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5oaWRlRWxlbWVudCkodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvYWRVcmw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgMDtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuUGFyZW50Q29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9jbGFzcywgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9LCBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCIgaW4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvUHJvcHMgJiYgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcyAmJiBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpLCBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCIpLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIiksIF93aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L3dpbmRvdy5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvZHJpdmVycy5qc1wiKSwgX3ZhbGlkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvdmFsaWRhdGUuanNcIiksIF9wcm9wcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3Byb3BzLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuICAgICAgICAgICAgICAgIChcInZhbHVlXCIgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSAmJiAoZGVzYy53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgICAgICB9LCBkZXNjKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiB2b2lkIDAgIT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbGliLmdsb2JhbC5wcm9wcyA9IF9saWIuZ2xvYmFsLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgX2xpYi5nbG9iYWwud2luZG93cyA9IF9saWIuZ2xvYmFsLndpbmRvd3MgfHwge307XG4gICAgICAgICAgICAoZXhwb3J0cy5QYXJlbnRDb21wb25lbnQgPSAoX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcigoX2NsYXNzID0gZnVuY3Rpb24oX0Jhc2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0oUGFyZW50Q29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUGFyZW50Q29tcG9uZW50KGNvbXBvbmVudCwgY29udGV4dCwgX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBQYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBmdW5jdGlvbihzZWxmLCBjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlUGFyZW50RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmxvZ0xldmVsICYmICgwLCBfbGliLnNldExvZ0xldmVsKShfdGhpcy5wcm9wcy5sb2dMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkV2luZG93TmFtZSA9IF90aGlzLmJ1aWxkQ2hpbGRXaW5kb3dOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRvOiB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyQWN0aXZlQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5sb2coXCJjb25zdHJ1Y3RfcGFyZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53YXRjaEZvclVubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkluaXQgPSBuZXcgX3NyYzMuWmFsZ29Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uSW5pdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXMsIGxvYWRVcmwgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdKSB8fCBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUluaXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuY29tcG9uZW50LmxvZyhcInJlbmRlcl9cIiArIF90aGlzMi5jb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3RoaXMyLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVXJsOiAoMCwgX2xpYi5zdHJpbmdpZnkpKGxvYWRVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXNrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3Mub25SZW5kZXIgPSBfdGhpczIucHJvcHMub25SZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmdldERvbWFpbiA9IF90aGlzMi5nZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmVsZW1lbnRSZWFkeSA9IF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHJldHVybiBfdGhpczIuZWxlbWVudFJlYWR5KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuQ29udGFpbmVyID0gdGFza3MuZWxlbWVudFJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5vcGVuQ29udGFpbmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zaG93Q29udGFpbmVyID0gdGFza3Mub3BlbkNvbnRhaW5lci50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc2hvd0NvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuUHJlcmVuZGVyID0gdGFza3Mub3BlbkNvbnRhaW5lci50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub3BlblByZXJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zd2l0Y2hQcmVyZW5kZXIgPSBfc3JjMy5aYWxnb1Byb21pc2UuYWxsKFsgdGFza3Mub3BlblByZXJlbmRlciwgX3RoaXMyLm9uSW5pdCBdKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc3dpdGNoUHJlcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLm9wZW4gPSBfdGhpczIuZHJpdmVyLm9wZW5PbkNsaWNrID8gX3RoaXMyLm9wZW4oKSA6IHRhc2tzLm9wZW5Db250YWluZXIudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubGlzdGVuID0gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHRhc2tzLmdldERvbWFpbiwgdGFza3Mub3BlbiBdKS50aGVuKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5saXN0ZW4oX3RoaXMyLndpbmRvdywgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3Mud2F0Y2hGb3JDbG9zZSA9IHRhc2tzLm9wZW4udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLndhdGNoRm9yQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubGlua0RvbWFpbiA9IF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyB0YXNrcy5nZXREb21haW4sIHRhc2tzLm9wZW4gXSkudGhlbihmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBfcmVmM1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NyYy5icmlkZ2UgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluKSByZXR1cm4gX3NyYy5icmlkZ2UubGlua1VybChfdGhpczIud2luZG93LCBkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMi5odG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUgPSB0YXNrcy5vcGVuUHJlcmVuZGVyLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zaG93Q29tcG9uZW50ID0gdGFza3MuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zaG93Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuQnJpZGdlID0gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHRhc2tzLmdldERvbWFpbiwgdGFza3Mub3BlbiBdKS50aGVuKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWY0WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub3BlbkJyaWRnZShcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4gPyBkb21haW4gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5odG1sKSB0YXNrcy5sb2FkSFRNTCA9IHRhc2tzLm9wZW4udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRIVE1MKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAobG9hZFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmJ1aWxkVXJsID0gX3RoaXMyLmJ1aWxkVXJsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubG9hZFVybCA9IF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyB0YXNrcy5idWlsZFVybCwgdGFza3Mub3BlbiwgdGFza3MubGlua0RvbWFpbiwgdGFza3MubGlzdGVuLCB0YXNrcy5vcGVuLCB0YXNrcy5vcGVuQnJpZGdlLCB0YXNrcy5jcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZSBdKS50aGVuKGZ1bmN0aW9uKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmNVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5sb2FkVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucnVuVGltZW91dCA9IHRhc2tzLmxvYWRVcmwudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5ydW5UaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmhhc2godGFza3MpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3V0bGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRsZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5hZGRDbGFzcykob3V0bGV0LCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLk9VVExFVCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnZhbGlkYXRlUGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSAoMCwgX3NyYzIuZ2V0RG9tYWluKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikodGhpcy5jb21wb25lbnQuYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikpIHRocm93IG5ldyBfZXJyb3IuUmVuZGVyRXJyb3IoXCJDYW4gbm90IGJlIHJlbmRlcmVkIGJ5IGRvbWFpbjogXCIgKyBkb21haW4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJUbyA9IGZ1bmN0aW9uKHdpbiwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5SW5pdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuIF90aGlzMy5yZW5kZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5pc1NhbWVUb3BXaW5kb3cpKHdpbmRvdywgd2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgcmVuZGVyVG8gYW4gYWRqYWNlbnQgZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBlbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHBhc3NlZCB0byByZW5kZXJUbyBtdXN0IGJlIGEgc3RyaW5nIHNlbGVjdG9yLCBnb3QgXCIgKyAodm9pZCAwID09PSBlbGVtZW50ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZWxlbWVudCkpICsgXCIgXCIgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5jaGVja0FsbG93UmVuZGVyVG8od2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5jb21wb25lbnQubG9nKFwicmVuZGVyX1wiICsgX3RoaXMzLmNvbnRleHQgKyBcIl90b193aW5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICgwLCBfbGliLnN0cmluZ2lmeSkoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3RoaXMzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmNoaWxkV2luZG93TmFtZSA9IF90aGlzMy5idWlsZENoaWxkV2luZG93TmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG86IHdpblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczMuZGVsZWdhdGUod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMucmVuZGVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUucHJlZmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Lmh0bWwgPSBfdGhpczQuYnVpbGRVcmwoKS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5wcmVmZXRjaFBhZ2UpKHVybCkudGhlbihmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJhc2UgaHJlZj1cIicgKyAoXCJcIiArIHVybC5zcGxpdChcIi9cIikuc2xpY2UoMCwgMykuam9pbihcIi9cIikpICsgJ1wiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKyBodG1sICsgXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2NyaXB0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCAnXCIgKyAoXCIvXCIgKyB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDMpLmpvaW4oXCIvXCIpKSArIFwiJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICA8XFwvc2NyaXB0PlxcbiAgICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmxvYWRIVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXM1Lmh0bWwpIHRocm93IG5ldyBFcnJvcihcIkh0bWwgbm90IHByZWZldGNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1Lmh0bWwudGhlbihmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLndyaXRlVG9XaW5kb3cpKF90aGlzNS53aW5kb3csIGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5jaGVja0FsbG93UmVuZGVyVG8gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHRocm93IHRoaXMuY29tcG9uZW50LmNyZWF0ZUVycm9yKFwiTXVzdCBwYXNzIHdpbmRvdyB0byByZW5kZXJUb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIuaXNTYW1lRG9tYWluKSh3aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gKDAsIF9zcmMyLmdldERvbWFpbikoKSwgZG9tYWluID0gdGhpcy5jb21wb25lbnQuZ2V0RG9tYWluKG51bGwsIHRoaXMucHJvcHMuZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGRvbWFpbiB0byBhbGxvdyByZW1vdGUgcmVuZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIubWF0Y2hEb21haW4pKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZW5kZXIgcmVtb3RlbHkgdG8gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIC0gY2FuIG9ubHkgcmVuZGVyIHRvIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckFjdGl2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LmFjdGl2ZUNvbXBvbmVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5hY3RpdmVDb21wb25lbnRzLnNwbGljZShQYXJlbnRDb21wb25lbnQuYWN0aXZlQ29tcG9uZW50cy5pbmRleE9mKF90aGlzNiksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50UGFyZW50UmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJUb1dpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogd2luZG93O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0ID09PSBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVApIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuT1BFTkVSXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJUb1dpbmRvdyA9PT0gd2luZG93KSByZXR1cm4gKDAsIF9zcmMyLmlzVG9wKSh3aW5kb3cpID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlRPUFxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlBBUkVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAoMCwgX3NyYzIuZ2V0RGlzdGFuY2VGcm9tVG9wKSh3aW5kb3cpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICAgICAgX2xpYi5nbG9iYWwud2luZG93c1t1aWRdID0gd2luZG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJlZ2lzdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9saWIuZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuR0xPQkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmVuZGVyUGFyZW50UmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJUb1dpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogd2luZG93O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyVG9XaW5kb3cgPT09IHdpbmRvdykgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50UGFyZW50UmVmKHJlbmRlclRvV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9ICgwLCBfbGliLnVuaXF1ZUlEKSgpO1xuICAgICAgICAgICAgICAgICAgICBfbGliLmdsb2JhbC53aW5kb3dzW3VpZF0gPSByZW5kZXJUb1dpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfbGliLmdsb2JhbC53aW5kb3dzW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLkdMT0JBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ2hpbGRXaW5kb3dOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNiRyZW5kZXJUbyA9IChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9KS5yZW5kZXJUbywgcmVuZGVyVG8gPSB2b2lkIDAgPT09IF9yZWY2JHJlbmRlclRvID8gd2luZG93IDogX3JlZjYkcmVuZGVyVG8sIHNhbWVEb21haW4gPSAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9zcmMyLmlzU2FtZURvbWFpbikocmVuZGVyVG8pLCB1aWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKSwgdGFnID0gdGhpcy5jb21wb25lbnQudGFnLCBzUHJvcHMgPSAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9saWIuc2VyaWFsaXplRnVuY3Rpb25zKSh0aGlzLmdldFByb3BzRm9yQ2hpbGQoKSksIGNvbXBvbmVudFBhcmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50UGFyZW50UmVmKHJlbmRlclRvKSwgcmVuZGVyUGFyZW50ID0gdGhpcy5nZXRSZW5kZXJQYXJlbnRSZWYocmVuZGVyVG8pLCBwcm9wcyA9ICFzYW1lRG9tYWluICYmICF0aGlzLmNvbXBvbmVudC51bnNhZmVSZW5kZXJUbyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5VSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5JTklUSUFMX1BST1BTLlJBVyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnR5cGUgPT09IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5VSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIuZ2xvYmFsLnByb3BzW3VpZF0gPSBKU09OLnN0cmluZ2lmeShzUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2xpYi5nbG9iYWwucHJvcHNbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3dpbmRvdy5idWlsZENoaWxkV2luZG93TmFtZSkodGhpcy5jb21wb25lbnQubmFtZSwgdGhpcy5jb21wb25lbnQudmVyc2lvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFBhcmVudDogY29tcG9uZW50UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyUGFyZW50OiByZW5kZXJQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNlbmRUb1BhcmVudCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3dpbmRvdy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cpKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZmluZCBwYXJlbnQgY29tcG9uZW50IHdpbmRvdyB0byBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5sb2coXCJzZW5kX3RvX3BhcmVudF9cIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zcmMuc2VuZCkoKDAsIF93aW5kb3cuZ2V0UGFyZW50Q29tcG9uZW50V2luZG93KSgpLCBuYW1lLCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46ICgwLCBfd2luZG93LmdldFBhcmVudERvbWFpbikoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdKSB8fCBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVQcm9wcykodGhpcy5jb21wb25lbnQsIHByb3BzLCByZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZhbGlkYXRlICYmIHRoaXMuY29tcG9uZW50LnZhbGlkYXRlKHRoaXMuY29tcG9uZW50LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSB0aGlzLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5leHRlbmQpKHRoaXMucHJvcHMsICgwLCBfcHJvcHMubm9ybWFsaXplUHJvcHMpKHRoaXMuY29tcG9uZW50LCB0aGlzLCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5idWlsZFVybCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcywgcHJvcFVybCA9IHRoaXMucHJvcHMudXJsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHByb3BVcmwsICgwLCBfcHJvcHMucHJvcHNUb1F1ZXJ5KShfZXh0ZW5kcyh7fSwgdGhpcy5jb21wb25lbnQucHJvcHMsIHRoaXMuY29tcG9uZW50LmJ1aWx0aW5Qcm9wcyksIHRoaXMucHJvcHMpIF0pLnRoZW4oZnVuY3Rpb24oX3JlZjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmN1swXSwgcXVlcnkgPSBfcmVmN1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmwgJiYgIV90aGlzNy5jb21wb25lbnQuZ2V0VmFsaWREb21haW4odXJsKSA/IHVybCA6IF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybCB8fCBfdGhpczcuY29tcG9uZW50LmdldFVybChfdGhpczcucHJvcHMuZW52LCBfdGhpczcucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihmaW5hbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lnhjb21wb25lbnQgPSBcIjFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuZXh0ZW5kVXJsKShmaW5hbFVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgucHJvcHMudXJsO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF90aGlzOC5jb21wb25lbnQuZ2V0RG9tYWluKHVybCwgX3RoaXM4LnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluIHx8IChfdGhpczguY29tcG9uZW50LmJ1aWxkVXJsID8gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4LmNvbXBvbmVudC5idWlsZFVybChfdGhpczgucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihidWlsdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczguY29tcG9uZW50LmdldERvbWFpbihidWlsdFVybCwgX3RoaXM4LnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBkb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UHJvcHNGb3JDaGlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmOCwgcHJvcCA9IHRoaXMuY29tcG9uZW50LmdldFByb3Aoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgJiYgITEgPT09IHByb3Auc2VuZFRvQ2hpbGQgfHwgKHJlc3VsdFtrZXldID0gdGhpcy5wcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BzKHByb3BzLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uSW5pdC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzOS5jaGlsZEV4cG9ydHMpIHJldHVybiBfdGhpczkuY2hpbGRFeHBvcnRzLnVwZGF0ZVByb3BzKF90aGlzOS5nZXRQcm9wc0ZvckNoaWxkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgZXhwb3J0cyB3ZXJlIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5vcGVuQnJpZGdlID0gZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NyYy5icmlkZ2UgJiYgX3RoaXMxMC5kcml2ZXIubmVlZHNCcmlkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNCcmlkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogX3RoaXMxMC53aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiAmJiAobmVlZHNCcmlkZ2VQYXJhbXMuZG9tYWluID0gZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNCcmlkZ2UgPSBfc3JjLmJyaWRnZS5uZWVkc0JyaWRnZShuZWVkc0JyaWRnZVBhcmFtcyksIGJyaWRnZVVybCA9IF90aGlzMTAuY29tcG9uZW50LmdldEJyaWRnZVVybChfdGhpczEwLnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyaWRnZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmwgPSAoMCwgX2xpYi5leHRlbmRVcmwpKGJyaWRnZVVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBfdGhpczEwLmNvbXBvbmVudC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJpZGdlRG9tYWluID0gX3RoaXMxMC5jb21wb25lbnQuZ2V0QnJpZGdlRG9tYWluKF90aGlzMTAucHJvcHMuZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFicmlkZ2VEb21haW4pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGRvbWFpbiBmb3IgYnJpZGdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVlZHNCcmlkZ2UgPyBfc3JjLmJyaWRnZS5vcGVuQnJpZGdlKGJyaWRnZVVybCwgYnJpZGdlRG9tYWluKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0JyaWRnZSAmJiBkb21haW4gJiYgIV9zcmMuYnJpZGdlLmhhc0JyaWRnZShkb21haW4sIGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkJyaWRnZSB1cmwgbmVlZGVkIHRvIHJlbmRlciBcIiArIF90aGlzMTAuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczExLmNvbXBvbmVudC5sb2coXCJvcGVuX1wiICsgX3RoaXMxMS5jb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZTogX3RoaXMxMS5jaGlsZFdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTEuZHJpdmVyLm9wZW4uY2FsbChfdGhpczExKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLm9wZW5QcmVyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczEyLmNvbXBvbmVudC5wcmVyZW5kZXJUZW1wbGF0ZSkgcmV0dXJuIF90aGlzMTIuZHJpdmVyLm9wZW5QcmVyZW5kZXIuY2FsbChfdGhpczEyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnN3aXRjaFByZXJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTMucHJlcmVuZGVyV2luZG93ICYmIF90aGlzMTMuZHJpdmVyLnN3aXRjaFByZXJlbmRlcikgcmV0dXJuIF90aGlzMTMuZHJpdmVyLnN3aXRjaFByZXJlbmRlci5jYWxsKF90aGlzMTMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZWxlbWVudFJlYWR5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuZWxlbWVudFJlYWR5KShlbGVtZW50KS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubG9nKFwiZGVsZWdhdGVfXCIgKyB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHRoaXMucHJvcHMudWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogdGhpcy5wcm9wcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogdGhpcy5wcm9wcy5vbkNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25EaXNwbGF5OiB0aGlzLnByb3BzLm9uRGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB9LCBfaXRlcmF0b3IyID0gdGhpcy5jb21wb25lbnQuZ2V0UHJvcE5hbWVzKCksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gX3JlZjk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5nZXRQcm9wKHByb3BOYW1lKS5hbGxvd0RlbGVnYXRlICYmIChwcm9wc1twcm9wTmFtZV0gPSB0aGlzLnByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gKDAsIF9zcmMuc2VuZCkod2luLCBfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ERUxFR0FURSArIFwiX1wiICsgdGhpcy5jb21wb25lbnQubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW52OiB0aGlzLnByb3BzLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRXaW5kb3dOYW1lOiB0aGlzLmNoaWxkV2luZG93TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC51c2VyQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RG9tYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE0LmdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKF9yZWYxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTQuY2xlYW4ucmVnaXN0ZXIoZGF0YS5kZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWxlZ2F0ZSByZW5kZXJpbmcuIFBvc3NpYmx5IHRoZSBjb21wb25lbnQgaXMgbm90IGxvYWRlZCBpbiB0aGUgdGFyZ2V0IHdpbmRvdy5cXG5cXG5cIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIuc3RyaW5naWZ5RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgb3ZlcnJpZGVzID0gdGhpcy5kcml2ZXIuZGVsZWdhdGVPdmVycmlkZXMsIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjExLCB2YWwgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTCkgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IF90aGlzMTRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTRba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE1ID0gdGhpcywgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IGRhdGEub3ZlcnJpZGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSkgcmV0dXJuIG92ZXJyaWRlLmFwcGx5KF90aGlzMTUsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwpIHJldHVybiB2YWwob3JpZ2luYWwsIG92ZXJyaWRlKS5hcHBseShfdGhpczE1LCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZGVsZ2F0ZSB0byBiZSBDQUxMX09SSUdJTkFMLCBDQUxMX0RFTEVHQVRFLCBvciBmYWN0b3J5IG1ldGhvZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3AyOiBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9sb29wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgX2xvb3AyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTYgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMyLm9uQ2xvc2VXaW5kb3cpKHRoaXMud2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTYuY29tcG9uZW50LmxvZyhcImRldGVjdF9jbG9zZV9jaGlsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE2LnByb3BzLm9uQ2xvc2UoX2NvbnN0YW50cy5DTE9TRV9SRUFTT05TLkNMT1NFX0RFVEVDVEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiLCBjbG9zZVdpbmRvd0xpc3RlbmVyLmNhbmNlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yVW5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE3ID0gdGhpcywgb251bmxvYWQgPSAoMCwgX2xpYi5vbmNlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTcuY29tcG9uZW50LmxvZyhcIm5hdmlnYXRlX2F3YXlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2NsaWVudC5mbHVzaCkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTcuZGVzdHJveUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdW5sb2FkV2luZG93TGlzdGVuZXIgPSAoMCwgX2xpYi5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFwidW5sb2FkXCIsIG9udW5sb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lVbmxvYWRXaW5kb3dMaXN0ZW5lclwiLCB1bmxvYWRXaW5kb3dMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5sb2FkVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczE4LmNvbXBvbmVudC5sb2coXCJsb2FkX3VybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdChcIiNcIilbMF0gPT09IHVybC5zcGxpdChcIiNcIilbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3F1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfbGliLmV4dGVuZFVybCkodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX3F1ZXJ5ID0ge30sIF9xdWVyeVsoMCwgX2xpYi51bmlxdWVJRCkoKV0gPSBcIjFcIiwgX3F1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTguZHJpdmVyLmxvYWRVcmwuY2FsbChfdGhpczE4LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlqYWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnRhcmdldCA9IHRoaXMuY2hpbGRXaW5kb3dOYW1lO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5ydW5UaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE5ID0gdGhpcywgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaWQgPSB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTkuY29tcG9uZW50LmxvZyhcInRpbWVkX291dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IF90aGlzMTkuY29tcG9uZW50LmNyZWF0ZUVycm9yKFwiTG9hZGluZyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dCArIFwiIG1pbGxpc2Vjb25kc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczE5Lm9uSW5pdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTkucHJvcHMub25UaW1lb3V0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMxOS50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMTI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3JlZjEyID0ge30pW19jb25zdGFudHMuUE9TVF9NRVNTQUdFLklOSVRdID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRXhwb3J0cyA9IGRhdGEuZXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Jbml0LnJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB0aGlzLmdldFByb3BzRm9yQ2hpbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5DTE9TRV0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZGF0YS5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCBfcmVmMTJbX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuQ0hFQ0tfQ0xPU0VdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlZjEyW19jb25zdGFudHMuUE9TVF9NRVNTQUdFLlJFU0laRV0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIwLmRyaXZlci5hbGxvd1Jlc2l6ZSkgcmV0dXJuIF90aGlzMjAucmVzaXplKGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBfcmVmMTJbX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuT05SRVNJWkVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50LnRyaWdnZXIoXCJyZXNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ISURFXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5TSE9XXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5FUlJPUl0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGRhdGEuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlZjEyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIxID0gdGhpcywgX3JlZjEzJHdhaXRGb3JUcmFuc2l0ID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge30pLndhaXRGb3JUcmFuc2l0aW9uLCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHZvaWQgMCA9PT0gX3JlZjEzJHdhaXRGb3JUcmFuc2l0IHx8IF9yZWYxMyR3YWl0Rm9yVHJhbnNpdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmNvbXBvbmVudC5sb2coXCJyZXNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogKDAsIF9saWIuc3RyaW5naWZ5KShoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAoMCwgX2xpYi5zdHJpbmdpZnkpKHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmRyaXZlci5yZXNpemUuY2FsbChfdGhpczIxLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWl0Rm9yVHJhbnNpdGlvbiAmJiAoX3RoaXMyMS5lbGVtZW50IHx8IF90aGlzMjEuaWZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmVsZW1lbnQgJiYgKG92ZXJmbG93ID0gKDAsIF9saWIuc2V0T3ZlcmZsb3cpKF90aGlzMjEuZWxlbWVudCwgXCJoaWRkZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5lbGVtZW50U3RvcHBlZE1vdmluZykoX3RoaXMyMS5lbGVtZW50IHx8IF90aGlzMjEuaWZyYW1lKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyAmJiBvdmVyZmxvdy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciAmJiAoMCwgX2xpYi5oaWRlRWxlbWVudCkodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcml2ZXIuaGlkZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyICYmICgwLCBfbGliLnNob3dFbGVtZW50KSh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlci5zaG93LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjIgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMyLm9uQ2xvc2VXaW5kb3cpKHRoaXMud2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMjIudXNlckNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJlZ2lzdGVyKGNsb3NlV2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUudXNlckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5VU0VSX0NMT1NFRCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIzID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyMy5jb21wb25lbnQubG9nKFwiY2xvc2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMjMuZXZlbnQudHJpZ2dlck9uY2UoX2NvbnN0YW50cy5FVkVOVFMuQ0xPU0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjMucHJvcHMub25DbG9zZShyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyBfdGhpczIzLmNsb3NlQ29tcG9uZW50KCksIF90aGlzMjMuY2xvc2VDb250YWluZXIoKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI0ID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyNC5ldmVudC50cmlnZ2VyT25jZShfY29uc3RhbnRzLkVWRU5UUy5DTE9TRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNC5wcm9wcy5vbkNsb3NlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIF90aGlzMjQuY2xvc2VDb21wb25lbnQocmVhc29uKSwgX3RoaXMyNC5oaWRlQ29udGFpbmVyKCkgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNC5kZXN0cm95Q29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI1LmNsZWFuLnJ1bihcImRlc3Ryb3lDb250YWluZXJFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI1LmNsZWFuLnJ1bihcImRlc3Ryb3lDb250YWluZXJUZW1wbGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI2ID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEwsIHdpbiA9IHRoaXMud2luZG93O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI2LmNhbmNlbENvbnRhaW5lckV2ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyNi5ldmVudC50cmlnZ2VyT25jZShfY29uc3RhbnRzLkVWRU5UUy5DTE9TRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5wcm9wcy5vbkNsb3NlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5oaWRlQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5kZXN0cm95Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI2LmNoaWxkRXhwb3J0cyAmJiBfdGhpczI2LmNvbnRleHQgPT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUCAmJiAhKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NyYzIuaXNXaW5kb3dDbG9zZWQpKHdpbikgJiYgX3RoaXMyNi5jaGlsZEV4cG9ydHMuY2xvc2UoKS5jYXRjaChfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJ1bihcImRlc3Ryb3lVbmxvYWRXaW5kb3dMaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5ydW4oXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5ydW4oXCJkZXN0cm95Q29udGFpbmVyRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJ1bihcImRlc3Ryb3lXaW5kb3dcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNob3dDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjcgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczI3LnByb3BzLm9uRGlzcGxheSkgcmV0dXJuIF90aGlzMjcucHJvcHMub25EaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyNy5jb250YWluZXIpIHJldHVybiAoMCwgX2xpYi5zaG93QW5kQW5pbWF0ZSkoX3RoaXMyNy5jb250YWluZXIsIF9jb25zdGFudHMuQU5JTUFUSU9OX05BTUVTLlNIT1dfQ09OVEFJTkVSLCBfdGhpczI3LmNsZWFuLnJlZ2lzdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNob3dDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczI4LnByb3BzLm9uRGlzcGxheSkgcmV0dXJuIF90aGlzMjgucHJvcHMub25EaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyOC5lbGVtZW50KSByZXR1cm4gKDAsIF9saWIuc2hvd0FuZEFuaW1hdGUpKF90aGlzMjguZWxlbWVudCwgX2NvbnN0YW50cy5BTklNQVRJT05fTkFNRVMuU0hPV19DT01QT05FTlQsIF90aGlzMjguY2xlYW4ucmVnaXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyOSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjkuY29udGFpbmVyID8gKDAsIF9saWIuYW5pbWF0ZUFuZEhpZGUpKF90aGlzMjkuY29udGFpbmVyLCBfY29uc3RhbnRzLkFOSU1BVElPTl9OQU1FUy5ISURFX0NPTlRBSU5FUiwgX3RoaXMyOS5jbGVhbi5yZWdpc3RlcikgOiBfc3JjMy5aYWxnb1Byb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzMCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzAuZWxlbWVudCA/ICgwLCBfbGliLmFuaW1hdGVBbmRIaWRlKShfdGhpczMwLmVsZW1lbnQsIF9jb25zdGFudHMuQU5JTUFUSU9OX05BTUVTLkhJREVfQ09NUE9ORU5ULCBfdGhpczMwLmNsZWFuLnJlZ2lzdGVyKSA6IF9zcmMzLlphbGdvUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2luZG93IHx8ICgwLCBfc3JjMi5pc1dpbmRvd0Nsb3NlZCkodGhpcy53aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3aW5kb3cgdG8gZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZyhcImZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzEuY29tcG9uZW50LnByZXJlbmRlclRlbXBsYXRlID8gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzMS5wcmVyZW5kZXJJZnJhbWUgPyAoMCwgX2xpYi5hd2FpdEZyYW1lTG9hZCkoX3RoaXMzMS5wcmVyZW5kZXJJZnJhbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMxLnByZXJlbmRlcldpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IF90aGlzMzEucHJlcmVuZGVyV2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi53cml0ZUVsZW1lbnRUb1dpbmRvdykod2luLCBfdGhpczMxLnJlbmRlclRlbXBsYXRlKF90aGlzMzEuY29tcG9uZW50LnByZXJlbmRlclRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc3hEb206IF9saWIuanN4RG9tLmJpbmQoZG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogX3NyYzMuWmFsZ29Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMzIgPSB0aGlzLCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgX3JlZjE0ID0gdGhpcy5jb21wb25lbnQuZGltZW5zaW9ucyB8fCB7fSwgX3JlZjE0JHdpZHRoID0gX3JlZjE0LndpZHRoLCB3aWR0aCA9IHZvaWQgMCA9PT0gX3JlZjE0JHdpZHRoID8gX2NvbnN0YW50cy5ERUZBVUxUX0RJTUVOU0lPTlMuV0lEVEggKyBcInB4XCIgOiBfcmVmMTQkd2lkdGgsIF9yZWYxNCRoZWlnaHQgPSBfcmVmMTQuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWYxNCRoZWlnaHQgPyBfY29uc3RhbnRzLkRFRkFVTFRfRElNRU5TSU9OUy5IRUlHSFQgKyBcInB4XCIgOiBfcmVmMTQkaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX2NvbnN0YW50cy5DTEFTU19OQU1FUy5aT0lEICsgXCItXCIgKyB0aGlzLmNvbXBvbmVudC50YWcgKyBcIi1cIiArIHRoaXMucHJvcHMudWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHJlbmRlcmVyLl9feGRvbWFpbl9fID8gbnVsbCA6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRoaXMuY29tcG9uZW50LnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxldDogdGhpcy5nZXRPdXRsZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENMQVNTOiBfY29uc3RhbnRzLkNMQVNTX05BTUVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgQU5JTUFUSU9OOiBfY29uc3RhbnRzLkFOSU1BVElPTl9OQU1FUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTlRFWFQ6IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEVWRU5UOiBfY29uc3RhbnRzLkVWRU5UUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMyLnVzZXJDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzMi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBqc3hEb206IF9saWIuanN4RG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLm9wZW5Db250YWluZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbCA9IGVsZW1lbnQgPyAoMCwgX2xpYi5nZXRFbGVtZW50KShlbGVtZW50KSA6IGRvY3VtZW50LmJvZHkpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIG9wZW4gY29udGFpbmVyIGludG9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzMy5jb21wb25lbnQuY29udGFpbmVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMzMy5yZW5kZXJUZW1wbGF0ZShfdGhpczMzLmNvbXBvbmVudC5jb250YWluZXJUZW1wbGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5hcHBlbmRDaGlsZCkoZWwsIF90aGlzMzMuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzMy5kcml2ZXIucmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5lbGVtZW50ID0gX3RoaXMzMy5nZXRPdXRsZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMzMy5lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIHJlbmRlciBjb21wb25lbnQgaW50b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q29udGFpbmVyVGVtcGxhdGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzMuY29udGFpbmVyICYmIF90aGlzMzMuY29udGFpbmVyLnBhcmVudE5vZGUgJiYgX3RoaXMzMy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczMzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczMzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMzMy5kcml2ZXIucmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcihcImNvbnRhaW5lclRlbXBsYXRlIG5lZWRlZCB0byByZW5kZXIgXCIgKyBfdGhpczMzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuY2FuY2VsQ29udGFpbmVyRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucnVuKFwiZGVzdHJveUNvbnRhaW5lckV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMzQuY2xlYW4uaGFzVGFza3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzQuY29tcG9uZW50LmxvZyhcImRlc3Ryb3lcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9jbGllbnQuZmx1c2gpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzQuY2xlYW4uYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS50cnlJbml0ID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkobWV0aG9kKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzUub25Jbml0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzUub25Jbml0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMzYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzYuaGFuZGxlZEVycm9ycyA9IF90aGlzMzYuaGFuZGxlZEVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX3RoaXMzNi5oYW5kbGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzYuaGFuZGxlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzNi5vbkluaXQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMzYucHJvcHMub25FcnJvcikgcmV0dXJuIF90aGlzMzYucHJvcHMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCB3aGlsZSBoYW5kbGluZyBlcnJvcjpcXG5cXG4gXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSArIFwiXFxuXFxuXCIgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGliLnN0cmluZ2lmeUVycm9yKShlcnJFcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMzNi5wcm9wcy5vbkVycm9yKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LmRlc3Ryb3lBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzdWx0cyA9IFtdOyBQYXJlbnRDb21wb25lbnQuYWN0aXZlQ29tcG9uZW50cy5sZW5ndGg7ICkgcmVzdWx0cy5wdXNoKFBhcmVudENvbXBvbmVudC5hY3RpdmVDb21wb25lbnRzWzBdLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oX2xpYi5ub29wKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhQYXJlbnRDb21wb25lbnQsIFsge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwiZHJpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kcml2ZXJzLlJFTkRFUl9EUklWRVJTW3RoaXMuY29udGV4dF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJlbnRDb21wb25lbnQ7XG4gICAgICAgICAgICB9KF9iYXNlLkJhc2VDb21wb25lbnQpKS5wcm90b3R5cGUsIFwiZ2V0T3V0bGV0XCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZ2V0T3V0bGV0XCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicHJlZmV0Y2hcIiwgWyBfbGliLm1lbW9pemVkIF0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJwcmVmZXRjaFwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImxvYWRIVE1MXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibG9hZEhUTUxcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJidWlsZFVybFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImJ1aWxkVXJsXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlblwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm9wZW5cIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJvcGVuUHJlcmVuZGVyXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlblByZXJlbmRlclwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN3aXRjaFByZXJlbmRlclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN3aXRjaFByZXJlbmRlclwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY2xvc2VcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjbG9zZUNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlQ29udGFpbmVyXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZGVzdHJveUNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImRlc3Ryb3lDb250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjbG9zZUNvbXBvbmVudFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlQ29tcG9uZW50XCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd0NvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3dDb250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzaG93Q29tcG9uZW50XCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd0NvbXBvbmVudFwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhpZGVDb250YWluZXJcIiwgWyBfbGliLm1lbW9pemVkIF0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJoaWRlQ29udGFpbmVyXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaGlkZUNvbXBvbmVudFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhpZGVDb21wb25lbnRcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZVwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNyZWF0ZVByZXJlbmRlclRlbXBsYXRlXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlbkNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm9wZW5Db250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9jbGFzcykpLmFjdGl2ZUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3Byb3BzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZVByb3AgPSBub3JtYWxpemVQcm9wO1xuICAgICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMocHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKS5pbmRleE9mKGtleSkgPyByZXN1bHRba2V5XSA9IG5vcm1hbGl6ZVByb3AoY29tcG9uZW50LCBpbnN0YW5jZSwgcHJvcHMsIGtleSwgcHJvcHNba2V5XSkgOiByZXN1bHRba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjb21wb25lbnQuZ2V0UHJvcE5hbWVzKCksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfa2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3BzLmhhc093blByb3BlcnR5KF9rZXkpIHx8IGluc3RhbmNlLnByb3BzICYmIGluc3RhbmNlLnByb3BzLmhhc093blByb3BlcnR5KF9rZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplUHJvcChjb21wb25lbnQsIGluc3RhbmNlLCBwcm9wcywgX2tleSwgcHJvcHNbX2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBub3JtYWxpemVkUHJvcCAmJiAocmVzdWx0W19rZXldID0gbm9ybWFsaXplZFByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcm9wc1RvUXVlcnkgPSBmdW5jdGlvbihwcm9wc0RlZiwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLmFsbChPYmplY3Qua2V5cyhwcm9wcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzRGVmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wKSByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHByb3AucXVlcnlQYXJhbSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS5hbGwoWyBmdW5jdGlvbihwcm9wLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVBhcmFtID8gcHJvcC5xdWVyeVBhcmFtKHZhbHVlKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHByb3AucXVlcnlQYXJhbSA/IHByb3AucXVlcnlQYXJhbSA6IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0ocHJvcCwga2V5LCB2YWx1ZSksIGZ1bmN0aW9uKHByb3AsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBwcm9wLnF1ZXJ5VmFsdWUgPyBwcm9wLnF1ZXJ5VmFsdWUodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3AsIDAsIHZhbHVlKSBdKS50aGVuKGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSBfcmVmM1swXSwgcXVlcnlWYWx1ZSA9IF9yZWYzWzFdLCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiYm9vbGVhblwiID09IHR5cGVvZiBxdWVyeVZhbHVlKSByZXN1bHQgPSBcIjFcIjsgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmVzdWx0ID0gcXVlcnlWYWx1ZS50b1N0cmluZygpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gcXVlcnlWYWx1ZSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHF1ZXJ5VmFsdWUpKSAmJiBudWxsICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJqc29uXCIgIT09IHByb3Auc2VyaWFsaXphdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBfbGliLmRvdGlmeSkocXVlcnlWYWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMocmVzdWx0KSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdGtleSA9IF9yZWY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZG90a2V5XSA9IHJlc3VsdFtkb3RrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShxdWVyeVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFwibnVtYmVyXCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgKHJlc3VsdCA9IHF1ZXJ5VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1txdWVyeVBhcmFtXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVQcm9wKGNvbXBvbmVudCwgaW5zdGFuY2UsIHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBjb21wb25lbnQuZ2V0UHJvcChrZXkpLCByZXN1bHRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAhKHJlc3VsdFZhbHVlID0gcHJvcC52YWx1ZSA/IHByb3AudmFsdWUgOiAhcHJvcC5kZWYgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gdmFsdWUgJiYgdm9pZCAwICE9PSB2YWx1ZSAmJiBcIlwiICE9PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KHZhbHVlKSA/IHZhbHVlIDogcHJvcC5kZWYuY2FsbChjb21wb25lbnQsIHByb3BzKSkgJiYgcHJvcC5hbGlhcyAmJiBwcm9wc1twcm9wLmFsaWFzXSAmJiAocmVzdWx0VmFsdWUgPSBwcm9wc1twcm9wLmFsaWFzXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9ICExO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmRlY29yYXRlICYmIG51bGwgIT09IHJlc3VsdFZhbHVlICYmIHZvaWQgMCAhPT0gcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0VmFsdWUgPSBwcm9wLmRlY29yYXRlLmNhbGwoaW5zdGFuY2UsIHJlc3VsdFZhbHVlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoXCJib29sZWFuXCIgPT09IHR5cGUpIHJlc3VsdFZhbHVlID0gQm9vbGVhbihyZXN1bHRWYWx1ZSk7IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFZhbHVlICYmIHByb3Aubm9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VmFsdWUgPSBfbGliLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZGVjb3JhdGVkICYmIHByb3AuZGVjb3JhdGUgJiYgKHJlc3VsdFZhbHVlID0gcHJvcC5kZWNvcmF0ZS5jYWxsKGluc3RhbmNlLCBfbGliLm5vb3AsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFZhbHVlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gcmVzdWx0VmFsdWUuYmluZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmRlbm9kZWlmeSAmJiAocmVzdWx0VmFsdWUgPSAoMCwgX2xpYi5kZW5vZGVpZnkpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnByb21pc2lmeSAmJiAocmVzdWx0VmFsdWUgPSAoMCwgX2xpYi5wcm9taXNpZnkpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSByZXN1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmxvZyhcImNhbGxfcHJvcF9cIiArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC5vbmNlICYmIChyZXN1bHRWYWx1ZSA9ICgwLCBfbGliLm9uY2UpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLm1lbW9pemUgJiYgKHJlc3VsdFZhbHVlID0gKDAsIF9saWIubWVtb2l6ZSkocmVzdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBcInN0cmluZ1wiID09PSB0eXBlIHx8IFwib2JqZWN0XCIgPT09IHR5cGUgfHwgXCJudW1iZXJcIiA9PT0gdHlwZSAmJiB2b2lkIDAgIT09IHJlc3VsdFZhbHVlICYmIChyZXN1bHRWYWx1ZSA9IHBhcnNlSW50KHJlc3VsdFZhbHVlLCAxMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3ZhbGlkYXRlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlUHJvcCA9IHZhbGlkYXRlUHJvcDtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdKSB8fCBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wcyA9IHByb3BzIHx8IHt9KS5lbnYgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihjb21wb25lbnQudXJsKSAmJiAhY29tcG9uZW50LnVybFtwcm9wcy5lbnZdKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVudjogXCIgKyBwcm9wcy5lbnYpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9yZWYsIHByb3AgPSBjb21wb25lbnQuZ2V0UHJvcChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5hbGlhcyAmJiBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wLmFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcC5hbGlhc107XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbcHJvcC5hbGlhc107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldIHx8IChwcm9wc1trZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhwcm9wcyksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfa2V5ID0gX3JlZjIsIF9wcm9wID0gY29tcG9uZW50LmdldFByb3AoX2tleSksIF92YWx1ZSA9IHByb3BzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBfcHJvcCAmJiB2YWxpZGF0ZVByb3AoX3Byb3AsIF9rZXksIF92YWx1ZSwgcHJvcHMsIHJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXkyID0gX3JlZjMsIF9wcm9wMiA9IGNvbXBvbmVudC5nZXRQcm9wKF9rZXkyKSwgX3ZhbHVlMiA9IHByb3BzW19rZXkyXTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3AyICYmICFwcm9wcy5oYXNPd25Qcm9wZXJ0eShfa2V5MikgJiYgdmFsaWRhdGVQcm9wKF9wcm9wMiwgX2tleTIsIF92YWx1ZTIsIHByb3BzLCByZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcChwcm9wLCBrZXksIHZhbHVlLCBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZCA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbNF0pIHx8IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdm9pZCAwICE9PSB2YWx1ZSAmJiBcIlwiICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdmFsdWUudGhlbiB8fCAhcHJvcC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSBwcm9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB2YWx1ZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3AgaXMgbm90IG9mIHR5cGUgZnVuY3Rpb246IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gcHJvcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHZhbHVlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcCBpcyBub3Qgb2YgdHlwZSBzdHJpbmc6IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gcHJvcC50eXBlKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzZXJpYWxpemUgcHJvcDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIm51bWJlclwiID09PSBwcm9wLnR5cGUgJiYgaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wIGlzIG5vdCBhIG51bWJlcjogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwcm9wLnZhbGlkYXRlICYmIHZhbHVlICYmIHByb3AudmFsaWRhdGUodmFsdWUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWlyZWQgJiYgITEgIT09IHByb3AucmVxdWlyZWQgJiYgIXByb3AuaGFzT3duUHJvcGVydHkoXCJkZWZcIikpIHRocm93IG5ldyBFcnJvcihcIlByb3AgaXMgcmVxdWlyZWQ6IFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvd2luZG93LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UGFyZW50UmVuZGVyV2luZG93ID0gZXhwb3J0cy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cgPSBleHBvcnRzLmdldENvbXBvbmVudE1ldGEgPSBleHBvcnRzLmlzWm9pZENvbXBvbmVudFdpbmRvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuYnVpbGRDaGlsZFdpbmRvd05hbWUgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRvbWFpbiA9ICgwLCBfc3JjLmdldERvbWFpbikod2luZG93KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZE5hbWUgPSBub3JtYWxpemUobmFtZSksIGVuY29kZWRWZXJzaW9uID0gbm9ybWFsaXplKHZlcnNpb24pLCBlbmNvZGVkT3B0aW9ucyA9IChzdHIgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgXG4gICAgICAgICAgICAgICAgX2hpQmFzZTIuZGVmYXVsdC5lbmNvZGUoc3RyKS5yZXBsYWNlKC9cXD0vZywgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0cjtcbiAgICAgICAgICAgICAgICBpZiAoIWVuY29kZWROYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5hbWU6IFwiICsgbmFtZSArIFwiIC0gbXVzdCBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghZW5jb2RlZFZlcnNpb24pIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbjogXCIgKyB2ZXJzaW9uICsgXCIgLSBtdXN0IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJ4Y29tcG9uZW50XCIsIGVuY29kZWROYW1lLCBlbmNvZGVkVmVyc2lvbiwgZW5jb2RlZE9wdGlvbnMsIFwiXCIgXS5qb2luKFwiX19cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRQYXJlbnREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TWV0YSgpLmRvbWFpbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfcmVmMy53aWR0aCwgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0LCB4ID0gMCwgeSA9IDA7XG4gICAgICAgICAgICAgICAgd2lkdGggJiYgKHdpbmRvdy5vdXRlcldpZHRoID8geCA9IE1hdGgucm91bmQoKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMikgKyB3aW5kb3cuc2NyZWVuWCA6IHdpbmRvdy5zY3JlZW4ud2lkdGggJiYgKHggPSBNYXRoLnJvdW5kKCh3aW5kb3cuc2NyZWVuLndpZHRoIC0gd2lkdGgpIC8gMikpKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgJiYgKHdpbmRvdy5vdXRlckhlaWdodCA/IHkgPSBNYXRoLnJvdW5kKCh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMikgKyB3aW5kb3cuc2NyZWVuWSA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICYmICh5ID0gTWF0aC5yb3VuZCgod2luZG93LnNjcmVlbi5oZWlnaHQgLSBoZWlnaHQpIC8gMikpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb2JqLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9oaUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvaGktYmFzZTMyL3NyYy9iYXNlMzIuanNcIiksIF9oaUJhc2UyID0gKG9iaiA9IF9oaUJhc2UpICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICAgICAgfSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlteYS16MC05QS1aXSt8W15hLXowLTlBLVpdKyQvZywgXCJcIikucmVwbGFjZSgvW15hLXowLTlBLVpdKy9nLCBcIl9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmlzWm9pZENvbXBvbmVudFdpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXdpbmRvdy5uYW1lICYmIFwieGNvbXBvbmVudFwiID09PSB3aW5kb3cubmFtZS5zcGxpdChcIl9fXCIpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZ2V0Q29tcG9uZW50TWV0YSA9IGV4cG9ydHMuZ2V0Q29tcG9uZW50TWV0YSA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93Lm5hbWUpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZ2V0IGNvbXBvbmVudCBtZXRhIHdpdGhvdXQgd2luZG93IG5hbWVcIik7XG4gICAgICAgICAgICAgICAgdmFyIF93aW5kb3ckbmFtZSRzcGxpdDIgPSB3aW5kb3cubmFtZS5zcGxpdChcIl9fXCIpLCB6b2lkY29tcCA9IF93aW5kb3ckbmFtZSRzcGxpdDJbMF0sIG5hbWUgPSBfd2luZG93JG5hbWUkc3BsaXQyWzFdLCB2ZXJzaW9uID0gX3dpbmRvdyRuYW1lJHNwbGl0MlsyXSwgZW5jb2RlZE9wdGlvbnMgPSBfd2luZG93JG5hbWUkc3BsaXQyWzNdO1xuICAgICAgICAgICAgICAgIGlmIChcInhjb21wb25lbnRcIiAhPT0gem9pZGNvbXApIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgcmVuZGVyZWQgYnkgem9pZCAtIGdvdCBcIiArIHpvaWRjb21wKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyLCBjb21wb25lbnRNZXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1ldGEgPSBKU09OLnBhcnNlKChzdHIgPSBlbmNvZGVkT3B0aW9ucywgX2hpQmFzZTIuZGVmYXVsdC5kZWNvZGUoc3RyLnRvVXBwZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVjb2RlIGNvbXBvbmVudC1tZXRhOiBcIiArIGVuY29kZWRPcHRpb25zICsgXCIgXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1ldGEubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50TWV0YS52ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKC9fL2csIFwiLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50TWV0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93QnlSZWYoX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBfcmVmLnJlZiwgdWlkID0gX3JlZi51aWQsIGRpc3RhbmNlID0gX3JlZi5kaXN0YW5jZSwgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJlZiA9PT0gX2NvbnN0YW50cy5XSU5ET1dfUkVGRVJFTkNFUy5PUEVORVIgPyByZXN1bHQgPSAoMCwgX3NyYy5nZXRPcGVuZXIpKHdpbmRvdykgOiByZWYgPT09IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuVE9QID8gcmVzdWx0ID0gKDAsIFxuICAgICAgICAgICAgICAgIF9zcmMuZ2V0VG9wKSh3aW5kb3cpIDogcmVmID09PSBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlBBUkVOVCAmJiAocmVzdWx0ID0gZGlzdGFuY2UgPyAoMCwgXG4gICAgICAgICAgICAgICAgX3NyYy5nZXROdGhQYXJlbnRGcm9tVG9wKSh3aW5kb3csIGRpc3RhbmNlKSA6ICgwLCBfc3JjLmdldFBhcmVudCkod2luZG93KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9PT0gX2NvbnN0YW50cy5XSU5ET1dfUkVGRVJFTkNFUy5HTE9CQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gKDAsIF9zcmMuZ2V0QW5jZXN0b3IpKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9ICgwLCBfc3JjLmdldEFsbEZyYW1lc0luV2luZG93KShhbmNlc3RvciksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9yZWYyLCBnbG9iYWwgPSAoMCwgX2xpYi5nbG9iYWxGb3IpKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsICYmIGdsb2JhbC53aW5kb3dzICYmIGdsb2JhbC53aW5kb3dzW3VpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB3aW5kb3cgYnkgcmVmXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmdldFBhcmVudENvbXBvbmVudFdpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNZXRhID0gZ2V0Q29tcG9uZW50TWV0YSgpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50TWV0YSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBnZXQgcGFyZW50IGNvbXBvbmVudCB3aW5kb3cgLSB3aW5kb3cgbm90IHJlbmRlcmVkIGJ5IHpvaWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0J5UmVmKGNvbXBvbmVudE1ldGEuY29tcG9uZW50UGFyZW50KTtcbiAgICAgICAgICAgIH0pLCBleHBvcnRzLmdldFBhcmVudFJlbmRlcldpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNZXRhID0gZ2V0Q29tcG9uZW50TWV0YSgpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50TWV0YSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBnZXQgcGFyZW50IGNvbXBvbmVudCB3aW5kb3cgLSB3aW5kb3cgbm90IHJlbmRlcmVkIGJ5IHpvaWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0J5UmVmKGNvbXBvbmVudE1ldGEucmVuZGVyUGFyZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbnN0YW50cy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgWk9JRCA9IGV4cG9ydHMuWk9JRCA9IFwiem9pZFwiLCBQUk9QX1RZUEVTID0gKGV4cG9ydHMuX19aT0lEX18gPSBcIl9fXCIgKyBaT0lEICsgXCJfX1wiLCBcbiAgICAgICAgICAgIGV4cG9ydHMuUE9TVF9NRVNTQUdFID0ge1xuICAgICAgICAgICAgICAgIElOSVQ6IFpPSUQgKyBcIl9pbml0XCIsXG4gICAgICAgICAgICAgICAgUFJPUFM6IFpPSUQgKyBcIl9wcm9wc1wiLFxuICAgICAgICAgICAgICAgIFBST1BfQ0FMTEJBQ0s6IFpPSUQgKyBcIl9wcm9wX2NhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgQ0xPU0U6IFpPSUQgKyBcIl9jbG9zZVwiLFxuICAgICAgICAgICAgICAgIENIRUNLX0NMT1NFOiBaT0lEICsgXCJfY2hlY2tfY2xvc2VcIixcbiAgICAgICAgICAgICAgICBSRURJUkVDVDogWk9JRCArIFwiX3JlZGlyZWN0XCIsXG4gICAgICAgICAgICAgICAgUkVTSVpFOiBaT0lEICsgXCJfcmVzaXplXCIsXG4gICAgICAgICAgICAgICAgT05SRVNJWkU6IFpPSUQgKyBcIl9vbnJlc2l6ZVwiLFxuICAgICAgICAgICAgICAgIERFTEVHQVRFOiBaT0lEICsgXCJfZGVsZWdhdGVcIixcbiAgICAgICAgICAgICAgICBBTExPV19ERUxFR0FURTogWk9JRCArIFwiX2FsbG93X2RlbGVnYXRlXCIsXG4gICAgICAgICAgICAgICAgRVJST1I6IFpPSUQgKyBcIl9lcnJvclwiLFxuICAgICAgICAgICAgICAgIEhJREU6IFpPSUQgKyBcIl9oaWRlXCIsXG4gICAgICAgICAgICAgICAgU0hPVzogWk9JRCArIFwiX3Nob3dcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5QUk9QX1RZUEVTID0ge1xuICAgICAgICAgICAgICAgIFNUUklORzogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBPQkpFQ1Q6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBCT09MRUFOOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBOVU1CRVI6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH0pLCBDT05URVhUX1RZUEVTID0gKGV4cG9ydHMuSU5JVElBTF9QUk9QUyA9IHtcbiAgICAgICAgICAgICAgICBSQVc6IFwicmF3XCIsXG4gICAgICAgICAgICAgICAgVUlEOiBcInVpZFwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLldJTkRPV19SRUZFUkVOQ0VTID0ge1xuICAgICAgICAgICAgICAgIE9QRU5FUjogXCJvcGVuZXJcIixcbiAgICAgICAgICAgICAgICBUT1A6IFwidG9wXCIsXG4gICAgICAgICAgICAgICAgUEFSRU5UOiBcInBhcmVudFwiLFxuICAgICAgICAgICAgICAgIEdMT0JBTDogXCJnbG9iYWxcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5QUk9QX1RZUEVTX0xJU1QgPSBPYmplY3Qua2V5cyhQUk9QX1RZUEVTKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBST1BfVFlQRVNba2V5XTtcbiAgICAgICAgICAgIH0pLCBleHBvcnRzLkNPTlRFWFRfVFlQRVMgPSB7XG4gICAgICAgICAgICAgICAgSUZSQU1FOiBcImlmcmFtZVwiLFxuICAgICAgICAgICAgICAgIFBPUFVQOiBcInBvcHVwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwb3J0cy5DTEFTU19OQU1FUyA9IHtcbiAgICAgICAgICAgICAgICBaT0lEOiBcIlwiICsgWk9JRCxcbiAgICAgICAgICAgICAgICBPVVRMRVQ6IFpPSUQgKyBcIi1vdXRsZXRcIixcbiAgICAgICAgICAgICAgICBDT01QT05FTlRfRlJBTUU6IFpPSUQgKyBcIi1jb21wb25lbnQtZnJhbWVcIixcbiAgICAgICAgICAgICAgICBQUkVSRU5ERVJfRlJBTUU6IFpPSUQgKyBcIi1wcmVyZW5kZXItZnJhbWVcIixcbiAgICAgICAgICAgICAgICBWSVNJQkxFOiBaT0lEICsgXCItdmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgIElOVklTSUJMRTogWk9JRCArIFwiLWludmlzaWJsZVwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkVWRU5UUyA9IHtcbiAgICAgICAgICAgICAgICBDTE9TRTogWk9JRCArIFwiLWNsb3NlXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuQVRUUklCVVRFUyA9IHtcbiAgICAgICAgICAgICAgICBJRlJBTUVfUExBQ0VIT0xERVI6IFwiZGF0YS16b2lkLVwiICsgWk9JRCArIFwiLXBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuQU5JTUFUSU9OX05BTUVTID0ge1xuICAgICAgICAgICAgICAgIFNIT1dfQ09OVEFJTkVSOiBaT0lEICsgXCItc2hvdy1jb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBTSE9XX0NPTVBPTkVOVDogWk9JRCArIFwiLXNob3ctY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgSElERV9DT05UQUlORVI6IFpPSUQgKyBcIi1oaWRlLWNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIEhJREVfQ09NUE9ORU5UOiBaT0lEICsgXCItaGlkZS1jb21wb25lbnRcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5FVkVOVF9OQU1FUyA9IHtcbiAgICAgICAgICAgICAgICBDTElDSzogXCJjbGlja1wiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkNMT1NFX1JFQVNPTlMgPSB7XG4gICAgICAgICAgICAgICAgUEFSRU5UX0NBTEw6IFwicGFyZW50X2NhbGxcIixcbiAgICAgICAgICAgICAgICBDSElMRF9DQUxMOiBcImNoaWxkX2NhbGxcIixcbiAgICAgICAgICAgICAgICBDTE9TRV9ERVRFQ1RFRDogXCJjbG9zZV9kZXRlY3RlZFwiLFxuICAgICAgICAgICAgICAgIFVTRVJfQ0xPU0VEOiBcInVzZXJfY2xvc2VkXCIsXG4gICAgICAgICAgICAgICAgUEFSRU5UX0NMT1NFX0RFVEVDVEVEOiBcInBhcmVudF9jbG9zZV9kZXRlY3RlZFwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkNPTlRFWFRfVFlQRVNfTElTVCA9IE9iamVjdC5rZXlzKENPTlRFWFRfVFlQRVMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OVEVYVF9UWVBFU1trZXldO1xuICAgICAgICAgICAgfSksIGV4cG9ydHMuREVMRUdBVEUgPSB7XG4gICAgICAgICAgICAgICAgQ0FMTF9PUklHSU5BTDogXCJjYWxsX29yaWdpbmFsXCIsXG4gICAgICAgICAgICAgICAgQ0FMTF9ERUxFR0FURTogXCJjYWxsX2RlbGVnYXRlXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuV0lMRENBUkQgPSBcIipcIiwgZXhwb3J0cy5ERUZBVUxUX0RJTUVOU0lPTlMgPSB7XG4gICAgICAgICAgICAgICAgV0lEVEg6IDMwMCxcbiAgICAgICAgICAgICAgICBIRUlHSFQ6IDE1MFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmd1bGFyID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmd1bGFyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYW5ndWxhcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihjb21wb25lbnQsIG5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZy5tb2R1bGUoY29tcG9uZW50LnRhZywgW10pLmRpcmVjdGl2ZSgoMCwgX2xpYi5kYXNoZXJpemVUb0NhbWVsKShjb21wb25lbnQudGFnKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB7fSwgX2l0ZXJhdG9yID0gY29tcG9uZW50LmdldFByb3BOYW1lcygpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtfcmVmXSA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lmxvb3NlUHJvcHMgJiYgKHNjb3BlLnByb3BzID0gXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsgXCIkc2NvcGVcIiwgXCIkZWxlbWVudFwiLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubG9vc2VQcm9wcyAmJiAhJHNjb3BlLnByb3BzKSB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYW5ndWxhciBiaW5kaW5ncyB0byB3b3JrLCBwcm9wIGRlZmluaXRpb25zIG11c3QgYmUgcGFzc2VkIHRvIHpvaWQuY3JlYXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubG9nKFwiaW5zdGFudGlhdGVfYW5ndWxhcl9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3BlUHJvcHMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnByb3BzKSBzY29wZVByb3BzID0gJHNjb3BlLnByb3BzOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhzY29wZSksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gJHNjb3BlW2tleV0gJiYgKHNjb3BlUHJvcHNba2V5XSA9ICRzY29wZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVQcm9wcyA9ICgwLCBfbGliLnJlcGxhY2VPYmplY3QpKHNjb3BlUHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiJGFwcGx5XCIgIT09ICRzY29wZS4kcm9vdC4kJHBoYXNlICYmIFwiJGRpZ2VzdFwiICE9PSAkc2NvcGUuJHJvb3QuJCRwaGFzZSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KGdldFByb3BzKCksIG51bGwsICRlbGVtZW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcigkZWxlbWVudFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlUHJvcHMoZ2V0UHJvcHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuYW5ndWxhcjIgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLmFuZ3VsYXIyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oem9pZCwgX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgQW5ndWxhckNvbXBvbmVudCA9IF9yZWYuQ29tcG9uZW50LCBOZ01vZHVsZSA9IF9yZWYuTmdNb2R1bGUsIEVsZW1lbnRSZWYgPSBfcmVmLkVsZW1lbnRSZWYsIE5nWm9uZSA9IF9yZWYuTmdab25lO1xuICAgICAgICAgICAgICAgICAgICB6b2lkLmxvZyhcImluaXRpYWxpemluZyBhbmd1bGFyMiBjb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLnJlcGxhY2VPYmplY3QpKF9leHRlbmRzKHt9LCBjb21wb25lbnQuaW50ZXJuYWxQcm9wcywgY29tcG9uZW50LnByb3BzKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcywgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuem9uZS5ydW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBDb21wb25lbnRJbnN0YW5jZSA9IEFuZ3VsYXJDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHpvaWQudGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogWyBcInByb3BzXCIgXVxuICAgICAgICAgICAgICAgICAgICB9KS5DbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogWyBFbGVtZW50UmVmLCBOZ1pvbmUsIGZ1bmN0aW9uKGVsZW1lbnRSZWYsIHpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgcGFyZW50ID0gem9pZC5pbml0KGdldFByb3BzKHRoaXMpLCBudWxsLCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVuZGVyKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nT25DaGFuZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC51cGRhdGVQcm9wcyhnZXRQcm9wcyh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmdNb2R1bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbIENvbXBvbmVudEluc3RhbmNlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbIENvbXBvbmVudEluc3RhbmNlIF1cbiAgICAgICAgICAgICAgICAgICAgfSkuQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2VtYmVyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvZHJpdmVycy9nbGltbWVyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nbGltbWVyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oY29tcG9uZW50LCBHbGltbWVyQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfR2xpbW1lckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShfY2xhc3MsIF9HbGltbWVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgX2NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZiwgY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBfR2xpbW1lckNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzcy5wcm90b3R5cGUuZGlkSW5zZXJ0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXIoX2V4dGVuZHMoe30sIHRoaXMuYXJncyksIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfShHbGltbWVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2RyaXZlcnMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9zY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy9zY3JpcHQuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfc2NyaXB0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zY3JpcHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvcmVhY3QuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcmVhY3QpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF92dWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy92dWUuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92dWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2FuZ3VsYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy9hbmd1bGFyLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2FuZ3VsYXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2FuZ3VsYXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2VtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvZW1iZXIuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZW1iZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtYmVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9nbGltbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvZ2xpbW1lci5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9nbGltbWVyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbGltbWVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9hbmd1bGFyMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIyLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2FuZ3VsYXIyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9hbmd1bGFyMltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL3JlYWN0LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMucmVhY3QgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnJlYWN0ID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuUmVhY3QgJiYgd2luZG93LlJlYWN0RE9NKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3Q6IHdpbmRvdy5SZWFjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NOiB3aW5kb3cuUmVhY3RET01cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihjb21wb25lbnQsIF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFJlYWN0ID0gX3JlZi5SZWFjdCwgUmVhY3RET00gPSBfcmVmLlJlYWN0RE9NO1xuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVDbGFzcyA/IGNvbXBvbmVudC5yZWFjdCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5sb2coXCJpbnN0YW50aWF0ZV9yZWFjdF9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUucGFyZW50ICYmIHRoaXMuc3RhdGUucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkgOiBjb21wb25lbnQucmVhY3QgPSBmdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBzdXBlckNsYXNzICYmIG51bGwgIT09IHN1cGVyQ2xhc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KF9jbGFzcywgX1JlYWN0JENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIF9jbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5sb2coXCJpbnN0YW50aWF0ZV9yZWFjdF9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUucGFyZW50ICYmIHRoaXMuc3RhdGUucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQucmVhY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL3NjcmlwdC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZXhwb3J0cy5zY3JpcHQgPSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnQsIGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlcihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUgJiYgXCJzY3JpcHRcIiA9PT0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgJiYgXCJhcHBsaWNhdGlvbi94LWNvbXBvbmVudFwiID09PSBlbGVtZW50LmF0dHJpYnV0ZXMudHlwZS52YWx1ZSAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnICYmIHRhZyA9PT0gY29tcG9uZW50LnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubG9nKFwiaW5zdGFudGlhdGVfc2NyaXB0X2NvbXBvbmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5pbm5lclRleHQgPyBldmFsKFwiKFwiICsgZWxlbWVudC5pbm5lclRleHQgKyBcIilcIikgOiB7fSwgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaGFzIG5vIHBhcmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyKHByb3BzLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzY2FuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKF9yZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgc2Nhbik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvZHJpdmVycy92dWUuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy52dWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnZ1ZSA9IHtcbiAgICAgICAgICAgICAgICBnbG9iYWw6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihjcmVhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdEF0dHJzOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuJGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gY29tcG9uZW50LmluaXQoKDAsIF9saWIuZXh0ZW5kKSh7fSwgdGhpcy4kYXR0cnMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVuZGVyKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMuJGF0dHJzICYmIHRoaXMucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMuJGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9lcnJvci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLlBvcHVwT3BlbkVycm9yID0gUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgICAgICBleHBvcnRzLkludGVncmF0aW9uRXJyb3IgPSBJbnRlZ3JhdGlvbkVycm9yO1xuICAgICAgICAgICAgZXhwb3J0cy5SZW5kZXJFcnJvciA9IFJlbmRlckVycm9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9wdXBPcGVuRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQb3B1cE9wZW5FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBJbnRlZ3JhdGlvbkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSW50ZWdyYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZW5kZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlbmRlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2ludGVyZmFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbnRlcmZhY2UuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfaW50ZXJmYWNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgSU5URVJGQUNFID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB2YXIgbmV3T2JqID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gb2JqKSBmb3IgKHZhciBrZXkgaW4gb2JqKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIChuZXdPYmpba2V5XSA9IG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfShfaW50ZXJmYWNlKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IElOVEVSRkFDRTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9pbnRlcmZhY2UuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5DT05TVEFOVFMgPSBleHBvcnRzLnBvc3RSb2JvdCA9IGV4cG9ydHMuZ2V0Q3VycmVudFNjcmlwdERpciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX2NvbXBvbmVudC5Db21wb25lbnQob3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRCeVRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29tcG9uZW50LkNvbXBvbmVudC5nZXRCeVRhZyh0YWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEN1cnJlbnRTY3JpcHREaXJcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfbGliLmdldEN1cnJlbnRTY3JpcHREaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBvcnRzLmRlc3Ryb3lBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcmVudC5QYXJlbnRDb21wb25lbnQuZGVzdHJveUFsbCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZXJyb3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Vycm9yW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgdmFyIF9wb3N0Um9ib3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIikpLCBfY29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9pbmRleC5qc1wiKSwgX3BhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCIpLCBfQ09OU1RBTlRTID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvYmopIGZvciAodmFyIGtleSBpbiBvYmopIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgKG5ld09ialtrZXldID0gb2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnBvc3RSb2JvdCA9IF9wb3N0Um9ib3QsIGV4cG9ydHMuQ09OU1RBTlRTID0gX0NPTlNUQU5UUztcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvY3NzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNQZXJjID0gaXNQZXJjO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1B4ID0gaXNQeDtcbiAgICAgICAgICAgIGV4cG9ydHMudG9OdW0gPSB0b051bTtcbiAgICAgICAgICAgIGV4cG9ydHMudG9QeCA9IHRvUHg7XG4gICAgICAgICAgICBleHBvcnRzLnRvQ1NTID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHRvUHgodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQZXJjKHZhbCkgPyB2YWwgOiB0b1B4KHZhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wZXJjT2YgPSBwZXJjT2Y7XG4gICAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZURpbWVuc2lvbiA9IGZ1bmN0aW9uKGRpbSwgbWF4KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGRpbSkgcmV0dXJuIGRpbTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQZXJjKGRpbSkpIHJldHVybiBwZXJjT2YobWF4LCBkaW0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1B4KGRpbSkpIHJldHVybiB0b051bShkaW0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgbm9ybWFsaXplIGRpbWVuc2lvbjogXCIgKyBkaW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUGVyYyhzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2Ygc3RyICYmIC9eWzAtOV0rJSQvLnRlc3Qoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUHgoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHN0ciAmJiAvXlswLTldK3B4JC8udGVzdChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdG9OdW0odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goL14oWzAtOV0rKShweHwlKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgbWF0Y2ggY3NzIHZhbHVlIGZyb20gXCIgKyB2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdG9QeCh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9OdW0odmFsKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBlcmNPZihudW0sIHBlcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtICogdG9OdW0ocGVyYykgLyAxMDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvZGVjb3JhdG9ycy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLm1lbW9pemVkID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbWVtb2l6ZWRfXyA9IHRoaXMuX19tZW1vaXplZF9fIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbWVtb2l6ZWRfXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCAodGhpcy5fX21lbW9pemVkX19bbmFtZV0gPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWVtb2l6ZWRfX1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUuZGlzcGxheU5hbWUgPSBuYW1lICsgXCI6bWVtb2l6ZWRcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnByb21pc2UgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkobWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZS5kaXNwbGF5TmFtZSA9IG5hbWUgKyBcIjpwcm9taXNpZmllZFwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2xpYi9kb20uanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gZXhwb3J0cy5kb2N1bWVudFJlYWR5ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0sIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYXBwZW5kQ2hpbGQgPSBhcHBlbmRDaGlsZDtcbiAgICAgICAgICAgIGV4cG9ydHMucXVlcnlTZWxlY3RvckFsbCA9IHF1ZXJ5U2VsZWN0b3JBbGw7XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnRTYWZlID0gZ2V0RWxlbWVudFNhZmU7XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnQgPSBnZXRFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0RvY3VtZW50UmVhZHkgPSBpc0RvY3VtZW50UmVhZHk7XG4gICAgICAgICAgICBleHBvcnRzLmVsZW1lbnRSZWFkeSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gKDAsIF91dGlsLnN0cmluZ2lmeSkoaWQpLCBlbCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSByZXR1cm4gcmVzb2x2ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsID0gZ2V0RWxlbWVudFNhZmUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnBvcHVwID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkgcmV0dXJuIGtleSArIFwiPVwiICsgKDAsIF91dGlsLnN0cmluZ2lmeSkob3B0aW9uc1trZXldKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIixcIiksIHdpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW5kb3cub3Blbih1cmwsIG9wdGlvbnMubmFtZSwgcGFyYW1zLCAhMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBfZXJyb3IuUG9wdXBPcGVuRXJyb3IoXCJDYW4gbm90IG9wZW4gcG9wdXAgd2luZG93IC0gXCIgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IF9lcnJvci5Qb3B1cE9wZW5FcnJvcihcIkNhbiBub3Qgb3BlbiBwb3B1cCB3aW5kb3cgLSBibG9ja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy53cml0ZVRvV2luZG93ID0gd3JpdGVUb1dpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMud3JpdGVFbGVtZW50VG9XaW5kb3cgPSB3cml0ZUVsZW1lbnRUb1dpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMuc2V0U3R5bGUgPSBzZXRTdHlsZTtcbiAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgICAgICBleHBvcnRzLmF3YWl0RnJhbWVMb2FkID0gYXdhaXRGcmFtZUxvYWQ7XG4gICAgICAgICAgICBleHBvcnRzLmF3YWl0RnJhbWVXaW5kb3cgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnJlc29sdmUoZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0RnJhbWVMb2FkKGZyYW1lKS50aGVuKGZ1bmN0aW9uKGxvYWRlZEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkRnJhbWUuY29udGVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2luZG93IGluIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge30sIGVsID0gZ2V0RWxlbWVudChhcmd1bWVudHNbMV0pLCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9LCBzdHlsZSA9IG9wdGlvbnMuc3R5bGUgfHwge30sIGZyYW1lID0gY3JlYXRlRWxlbWVudChcImlmcmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lQm9yZGVyOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93VHJhbnNwYXJlbmN5OiBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICB9LCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgICAgICAgIH0sIHN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogb3B0aW9ucy5odG1sLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkKGZyYW1lKTtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMudXJsIHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFfEVkZ2UvaSkpICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBvcHRpb25zLnVybCB8fCBcImFib3V0OmJsYW5rXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihvYmosIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2NhbkZvckphdmFzY3JpcHQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cikgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLm1hdGNoKC88c2NyaXB0fG9uXFx3K1xccyo9fGphdmFzY3JpcHQ6fGV4cHJlc3Npb25cXHMqXFwofGV2YWxcXCh8bmV3XFxzKkZ1bmN0aW9uLykpIHRocm93IG5ldyBFcnJvcihcIkhUTUwgY29udGFpbnMgcG90ZW50aWFsIGphdmFzY3JpcHQ6IFwiICsgc3RyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VRdWVyeSh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpKVtuYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmZvcm1hdFF1ZXJ5ID0gZm9ybWF0UXVlcnk7XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZFF1ZXJ5ID0gZXh0ZW5kUXVlcnk7XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZFVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5IHx8IHt9LCBoYXNoID0gb3B0aW9ucy5oYXNoIHx8IHt9LCBvcmlnaW5hbFVybCA9IHZvaWQgMCwgb3JpZ2luYWxIYXNoID0gdm9pZCAwLCBfdXJsJHNwbGl0ID0gdXJsLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFVybCA9IF91cmwkc3BsaXRbMF07XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxIYXNoID0gX3VybCRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgX29yaWdpbmFsVXJsJHNwbGl0ID0gb3JpZ2luYWxVcmwuc3BsaXQoXCI/XCIpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVXJsID0gX29yaWdpbmFsVXJsJHNwbGl0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IGV4dGVuZFF1ZXJ5KF9vcmlnaW5hbFVybCRzcGxpdFsxXSwgcXVlcnkpLCBoYXNoU3RyaW5nID0gZXh0ZW5kUXVlcnkob3JpZ2luYWxIYXNoLCBoYXNoKTtcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyAmJiAob3JpZ2luYWxVcmwgPSBvcmlnaW5hbFVybCArIFwiP1wiICsgcXVlcnlTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGhhc2hTdHJpbmcgJiYgKG9yaWdpbmFsVXJsID0gb3JpZ2luYWxVcmwgKyBcIiNcIiArIGhhc2hTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFVybDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmVsZW1lbnRTdG9wcGVkTW92aW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiA1ZTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGdldEVsZW1lbnQoZWxlbWVudCksIHN0YXJ0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGludGVydmFsID0gdm9pZCAwLCB0aW1lciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC50b3AgPT09IGVuZC50b3AgJiYgc3RhcnQuYm90dG9tID09PSBlbmQuYm90dG9tICYmIHN0YXJ0LmxlZnQgPT09IGVuZC5sZWZ0ICYmIHN0YXJ0LnJpZ2h0ID09PSBlbmQucmlnaHQgJiYgc3RhcnQud2lkdGggPT09IGVuZC53aWR0aCAmJiBzdGFydC5oZWlnaHQgPT09IGVuZC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lZCBvdXQgd2FpdGluZyBmb3IgZWxlbWVudCB0byBzdG9wIGFuaW1hdGluZyBhZnRlciBcIiArIHRpbWVvdXQgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRDdXJyZW50RGltZW5zaW9ucyA9IGdldEN1cnJlbnREaW1lbnNpb25zO1xuICAgICAgICAgICAgZXhwb3J0cy5jaGFuZ2VTdHlsZSA9IGZ1bmN0aW9uKGVsLCBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNldE92ZXJmbG93ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IFwiYXV0b1wiLCBfZWwkc3R5bGUgPSBlbC5zdHlsZSwgb3ZlcmZsb3cgPSBfZWwkc3R5bGUub3ZlcmZsb3csIG92ZXJmbG93WCA9IF9lbCRzdHlsZS5vdmVyZmxvd1gsIG92ZXJmbG93WSA9IF9lbCRzdHlsZS5vdmVyZmxvd1k7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSBlbC5zdHlsZS5vdmVyZmxvd1ggPSBlbC5zdHlsZS5vdmVyZmxvd1kgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dYID0gb3ZlcmZsb3dYO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dZID0gb3ZlcmZsb3dZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnRyYWNrRGltZW5zaW9ucyA9IHRyYWNrRGltZW5zaW9ucztcbiAgICAgICAgICAgIGV4cG9ydHMub25EaW1lbnNpb25zQ2hhbmdlID0gZnVuY3Rpb24oZWwsIF9yZWY2KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY2JHdpZHRoID0gX3JlZjYud2lkdGgsIHdpZHRoID0gdm9pZCAwID09PSBfcmVmNiR3aWR0aCB8fCBfcmVmNiR3aWR0aCwgX3JlZjYkaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWY2JGhlaWdodCB8fCBfcmVmNiRoZWlnaHQsIF9yZWY2JGRlbGF5ID0gX3JlZjYuZGVsYXksIGRlbGF5ID0gdm9pZCAwID09PSBfcmVmNiRkZWxheSA/IDUwIDogX3JlZjYkZGVsYXksIF9yZWY2JHRocmVzaG9sZCA9IF9yZWY2LnRocmVzaG9sZCwgdGhyZXNob2xkID0gdm9pZCAwID09PSBfcmVmNiR0aHJlc2hvbGQgPyAwIDogX3JlZjYkdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrZXIgPSB0cmFja0RpbWVuc2lvbnMoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgfSksIGludGVydmFsID0gdm9pZCAwLCByZXNvbHZlciA9ICgwLCBfZm4uZGVib3VuY2UpKGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDQgKiBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RyYWNrZXIkY2hlY2sgPSB0cmFja2VyLmNoZWNrKCksIGNoYW5nZWQgPSBfdHJhY2tlciRjaGVjay5jaGFuZ2VkLCBkaW1lbnNpb25zID0gX3RyYWNrZXIkY2hlY2suZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcihkaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJhY2tlciRjaGVjazIgPSB0cmFja2VyLmNoZWNrKCksIGNoYW5nZWQgPSBfdHJhY2tlciRjaGVjazIuY2hhbmdlZCwgZGltZW5zaW9ucyA9IF90cmFja2VyJGNoZWNrMi5kaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25XaW5kb3dSZXNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRpbWVuc2lvbnNNYXRjaFZpZXdwb3J0ID0gZnVuY3Rpb24oZWwsIF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX3JlZjcud2lkdGgsIGhlaWdodCA9IF9yZWY3LmhlaWdodCwgZGltZW5zaW9ucyA9IGdldEN1cnJlbnREaW1lbnNpb25zKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggJiYgZGltZW5zaW9ucy53aWR0aCAhPT0gd2luZG93LmlubmVyV2lkdGgpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ICYmIGRpbWVuc2lvbnMuaGVpZ2h0ICE9PSB3aW5kb3cuaW5uZXJIZWlnaHQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5iaW5kRXZlbnRzID0gYmluZEV2ZW50cztcbiAgICAgICAgICAgIGV4cG9ydHMuc2V0VmVuZG9yQ1NTID0gc2V0VmVuZG9yQ1NTO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbiAgICAgICAgICAgIGV4cG9ydHMubWFrZUVsZW1lbnRWaXNpYmxlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIsIFwiXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubWFrZUVsZW1lbnRJbnZpc2libGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcInZpc2liaWxpdHlcIiwgU1RZTEUuVklTSUJJTElUWS5ISURERU4sIFNUWUxFLklNUE9SVEFOVCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zaG93RWxlbWVudCA9IHNob3dFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5oaWRlRWxlbWVudCA9IGhpZGVFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5kZXN0cm95RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2hvd0FuZEFuaW1hdGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCBjbGVhbikge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRlKGVsZW1lbnQsIG5hbWUsIGNsZWFuKTtcbiAgICAgICAgICAgICAgICBzaG93RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYW5pbWF0ZUFuZEhpZGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCBjbGVhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRlKGVsZW1lbnQsIG5hbWUsIGNsZWFuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoaWRlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZENsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpIDogLTEgPT09IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuaW5kZXhPZihuYW1lKSAmJiAoZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpIDogLTEgIT09IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuaW5kZXhPZihuYW1lKSAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5hbWUsIFwiXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEN1cnJlbnRTY3JpcHREaXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEbyBub3QgdXNlIHpvaWQuZ2V0Q3VycmVudFNjcmlwdERpcigpIGluIHByb2R1Y3Rpb24gLS0gYnJvd3NlciBzdXBwb3J0IGlzIGxpbWl0ZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYy5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi5cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnROYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlbGVtZW50KSByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQudGFnTmFtZSkgcmV0dXJuIFwiPHVua25vd24+XCI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlkID8gbmFtZSArPSBcIiNcIiArIGVsZW1lbnQuaWQgOiBlbGVtZW50LmNsYXNzTmFtZSAmJiAobmFtZSArPSBcIi5cIiArIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0VsZW1lbnRDbG9zZWQgPSBpc0VsZW1lbnRDbG9zZWQ7XG4gICAgICAgICAgICBleHBvcnRzLndhdGNoRWxlbWVudEZvckNsb3NlID0gZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSAoMCwgX2ZuLm9uY2UpKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpc0VsZW1lbnRDbG9zZWQoZWxlbWVudCkgPyBoYW5kbGVyKCkgOiBpbnRlcnZhbCA9ICgwLCBfdXRpbC5zYWZlSW50ZXJ2YWwpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50Q2xvc2VkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SHR0cFR5cGUgPSBnZXRIdHRwVHlwZTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SFRNTCA9IGdldEhUTUw7XG4gICAgICAgICAgICBleHBvcnRzLmdldENTUyA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIdHRwVHlwZShcInRleHQvY3NzXCIsIHVybCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SHR0cFR5cGUoXCIqLypcIiwgdXJsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnByZWZldGNoUGFnZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIVE1MKHVybCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5maXhTY3JpcHRzID0gZml4U2NyaXB0cztcbiAgICAgICAgICAgIGV4cG9ydHMuanN4RG9tID0gZnVuY3Rpb24obmFtZSwgcHJvcHMsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzICYmIHRoaXMuY3JlYXRlRWxlbWVudCA/IHRoaXMgOiB3aW5kb3cuZG9jdW1lbnQsIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykgaWYgKHByb3AgaW4gSlNYX0VWRU5UUykgZWwuYWRkRXZlbnRMaXN0ZW5lcihKU1hfRVZFTlRTW3Byb3BdLCBwcm9wc1twcm9wXSk7IGVsc2UgaWYgKFwiaW5uZXJIVE1MXCIgPT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gcHJvcHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpeFNjcmlwdHMoZWwsIGRvYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBwcm9wc1twcm9wXSk7XG4gICAgICAgICAgICAgICAgaWYgKFwic3R5bGVcIiA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgY29udGVudCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFwiICsgbmFtZSArIFwiIHRhZyBjb250ZW50IHRvIGJlIHN0cmluZywgZ290IFwiICsgKHZvaWQgMCA9PT0gY29udGVudCA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnRlbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb25seSB0ZXh0IGNvbnRlbnQgZm9yIFwiICsgbmFtZSArIFwiIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoZWwsIGNvbnRlbnQsIGRvYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcImlmcmFtZVwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb25seSBzaW5nbGUgY2hpbGQgbm9kZSBmb3IgaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW4gPSBlbC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGZyYW1lIHRvIGhhdmUgY29udGVudFdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGNvbnRlbnQgPyB3cml0ZVRvV2luZG93KHdpbiwgY29udGVudCkgOiB3cml0ZUVsZW1lbnRUb1dpbmRvdyh3aW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwic2NyaXB0XCIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGNvbnRlbnQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcIiArIG5hbWUgKyBcIiB0YWcgY29udGVudCB0byBiZSBzdHJpbmcsIGdvdCBcIiArICh2b2lkIDAgPT09IGNvbnRlbnQgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb250ZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9ubHkgdGV4dCBjb250ZW50IGZvciBcIiArIG5hbWUgKyBcIiB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZChlbCwgdGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBhcHBlbmRDaGlsZChlbCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIiksIF9mbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvZm4uanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi91dGlsLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2FmZShpZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQgfHwgbnVsbCAhPT0gZWxlbWVudCAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBlbGVtZW50ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZWxlbWVudCkpICYmIDEgPT09IGVsZW1lbnQubm9kZVR5cGUgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihlbGVtZW50LnN0eWxlKSAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfShpZCkpIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiAoZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEVsZW1lbnQoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGVsZW1lbnQ6IFwiICsgKDAsIF91dGlsLnN0cmluZ2lmeSkoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuZG9jdW1lbnRSZWFkeSA9IG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcImNvbXBsZXRlXCIgPT09IHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlKSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJjb21wbGV0ZVwiID09PSB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50UmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29tcGxldGVcIiA9PT0gd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZVRvV2luZG93KHdpbiwgaHRtbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC53cml0ZShodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24gPSBcImphdmFzY3JpcHQ6IGRvY3VtZW50Lm9wZW4oKTsgZG9jdW1lbnQud3JpdGUoXCIgKyBKU09OLnN0cmluZ2lmeShodG1sKSArIFwiKTsgZG9jdW1lbnQuY2xvc2UoKTtcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyMikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUVsZW1lbnRUb1dpbmRvdyh3aW4sIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJodG1sXCIgIT09IHRhZykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBiZSBodG1sLCBnb3QgXCIgKyB0YWcpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRvY3VtZW50RWxlbWVudCA9IHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IGRvY3VtZW50RWxlbWVudC5jaGlsZHJlbiAmJiBkb2N1bWVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyApIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChkb2N1bWVudEVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIGZvciAoO2VsLmNoaWxkcmVuLmxlbmd0aDsgKSBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0U3R5bGUoZWwsIHN0eWxlVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVNoZWV0ID8gZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gc3R5bGVUZXh0IDogZWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHN0eWxlVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBcImRpdlwiLCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgY29udGFpbmVyID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUgJiYgKDAsIF91dGlsLmV4dGVuZCkoZWxlbWVudC5zdHlsZSwgb3B0aW9ucy5zdHlsZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGFzcyAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVNoZWV0ICYmIHNldFN0eWxlKGVsZW1lbnQsIG9wdGlvbnMuc3R5bGVTaGVldCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyICYmIGFwcGVuZENoaWxkKGNvbnRhaW5lciwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHRtbCkgaWYgKFwiaWZyYW1lXCIgPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhZWxlbWVudC5jb250ZW50V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJJZnJhbWUgaHRtbCBjYW4gbm90IGJlIHdyaXR0ZW4gdW5sZXNzIGNvbnRhaW5lciBwcm92aWRlZCBhbmQgaWZyYW1lIGluIERPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUb1dpbmRvdyhlbGVtZW50LmNvbnRlbnRXaW5kb3csIG9wdGlvbnMuaHRtbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMgPSBuZXcgX3NyYzMuV2Vha01hcCgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXdhaXRGcmFtZUxvYWQoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXRGcmFtZUxvYWRQcm9taXNlcy5oYXMoZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcHJvbWlzZSA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuZ2V0KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wcm9taXNlKSByZXR1cm4gX3Byb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3NyYy5saW5rRnJhbWVXaW5kb3cpKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuY29udGVudFdpbmRvdyA/IHJlc29sdmUoZnJhbWUpIDogcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuc2V0KGZyYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJzZVF1ZXJ5ID0gZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gKDAsIF9mbi5tZW1vaXplKShmdW5jdGlvbihxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nKSByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gcXVlcnlTdHJpbmcuaW5kZXhPZihcIj1cIikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcGFyc2UgcXVlcnkgc3RyaW5nIHBhcmFtczogXCIgKyBxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBxdWVyeVN0cmluZy5zcGxpdChcIiZcIiksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICAocGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpKVswXSAmJiBwYWlyWzFdICYmIChwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdFF1ZXJ5KCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC51cmxFbmNvZGUpKGtleSkgKyBcIj1cIiArICgwLCBfdXRpbC51cmxFbmNvZGUpKG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiJlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZFF1ZXJ5KG9yaWdpbmFsUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcyAmJiBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID8gZm9ybWF0UXVlcnkoX2V4dGVuZHMoe30sIHBhcnNlUXVlcnkob3JpZ2luYWxRdWVyeSksIHByb3BzKSkgOiBvcmlnaW5hbFF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYWNrRGltZW5zaW9ucyhlbCwgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjUkd2lkdGggPSBfcmVmNS53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWY1JHdpZHRoIHx8IF9yZWY1JHdpZHRoLCBfcmVmNSRoZWlnaHQgPSBfcmVmNS5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZjUkaGVpZ2h0IHx8IF9yZWY1JGhlaWdodCwgX3JlZjUkdGhyZXNob2xkID0gX3JlZjUudGhyZXNob2xkLCB0aHJlc2hvbGQgPSB2b2lkIDAgPT09IF9yZWY1JHRocmVzaG9sZCA/IDAgOiBfcmVmNSR0aHJlc2hvbGQsIGN1cnJlbnREaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkOiBmdW5jdGlvbihvbmUsIHR3bywgX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0JHdpZHRoID0gX3JlZjQud2lkdGgsIHdpZHRoID0gdm9pZCAwID09PSBfcmVmNCR3aWR0aCB8fCBfcmVmNCR3aWR0aCwgX3JlZjQkaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWY0JGhlaWdodCB8fCBfcmVmNCRoZWlnaHQsIF9yZWY0JHRocmVzaG9sZCA9IF9yZWY0LnRocmVzaG9sZCwgdGhyZXNob2xkID0gdm9pZCAwID09PSBfcmVmNCR0aHJlc2hvbGQgPyAwIDogX3JlZjQkdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEod2lkdGggJiYgTWF0aC5hYnMob25lLndpZHRoIC0gdHdvLndpZHRoKSA+IHRocmVzaG9sZCkgfHwgISEoaGVpZ2h0ICYmIE1hdGguYWJzKG9uZS5oZWlnaHQgLSB0d28uaGVpZ2h0KSA+IHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShjdXJyZW50RGltZW5zaW9ucywgbmV3RGltZW5zaW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IG5ld0RpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudCwgZXZlbnROYW1lcywgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSAoMCwgX2ZuLm9uY2UpKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gZXZlbnROYW1lcywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgPyBfaXRlcmF0b3I0IDogX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjQubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBfcmVmODtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKDAsIF9mbi5vbmNlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gZXZlbnROYW1lcywgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k1ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/IF9pdGVyYXRvcjUgOiBfaXRlcmF0b3I1W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pNS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF9yZWY5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWyBcIndlYmtpdFwiLCBcIm1velwiLCBcIm1zXCIsIFwib1wiIF07XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRWZW5kb3JDU1MoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGNhcGl0YWxpemVkTmFtZSA9ICgwLCBfdXRpbC5jYXBpdGFsaXplRmlyc3RMZXR0ZXIpKG5hbWUpLCBfaXRlcmF0b3I2ID0gVkVORE9SX1BSRUZJWEVTLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTYgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNiA9IF9pc0FycmF5NiA/IF9pdGVyYXRvcjYgOiBfaXRlcmF0b3I2W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k2ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYxMCA9IF9pdGVyYXRvcjZbX2k2KytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTAgPSBfaTYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IF9yZWYxMDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtcIlwiICsgcHJlZml4ICsgY2FwaXRhbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBDU1NSdWxlID0gd2luZG93LkNTU1J1bGUsIEtFWUZSQU1FU19SVUxFID0gQ1NTUnVsZS5LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLldFQktJVF9LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLk1PWl9LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLk9fS0VZRlJBTUVTX1JVTEUgfHwgQ1NTUnVsZS5NU19LRVlGUkFNRVNfUlVMRTtcbiAgICAgICAgICAgIHZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWyBcImFuaW1hdGlvbnN0YXJ0XCIsIFwid2Via2l0QW5pbWF0aW9uU3RhcnRcIiwgXCJvQW5pbWF0aW9uU3RhcnRcIiwgXCJNU0FuaW1hdGlvblN0YXJ0XCIgXSwgQU5JTUFUSU9OX0VORF9FVkVOVFMgPSBbIFwiYW5pbWF0aW9uZW5kXCIsIFwid2Via2l0QW5pbWF0aW9uRW5kXCIsIFwib0FuaW1hdGlvbkVuZFwiLCBcIk1TQW5pbWF0aW9uRW5kXCIgXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgbmFtZSwgY2xlYW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogMWUzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsIHx8ICFmdW5jdGlvbihlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzaGVldHMgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1J1bGVzID0gc3R5bGVzaGVldHNbaV0uY3NzUnVsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NSdWxlcykgZm9yICh2YXIgaiA9IDA7IGogPCBjc3NSdWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1J1bGUgPSBjc3NSdWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NSdWxlICYmIGNzc1J1bGUudHlwZSA9PT0gS0VZRlJBTUVTX1JVTEUgJiYgY3NzUnVsZS5uYW1lID09PSBuYW1lKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH0oZWwsIG5hbWUpKSByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3RhcnRlZCA9ICExLCBzdGFydFRpbWVvdXQgPSB2b2lkIDAsIGVuZFRpbWVvdXQgPSB2b2lkIDAsIHN0YXJ0RXZlbnQgPSB2b2lkIDAsIGVuZEV2ZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVuZG9yQ1NTKGVsLCBcImFuaW1hdGlvbk5hbWVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChlbmRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRFdmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50ID0gYmluZEV2ZW50cyhlbCwgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGVsICYmIGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N0YXJ0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudCA9IGJpbmRFdmVudHMoZWwsIEFOSU1BVElPTl9FTkRfRVZFTlRTLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZWwgJiYgZXZlbnQuYW5pbWF0aW9uTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZXZlbnQuYW5pbWF0aW9uTmFtZSAmJiBldmVudC5hbmltYXRpb25OYW1lICE9PSBuYW1lID8gcmVqZWN0KFwiRXhwZWN0ZWQgYW5pbWF0aW9uIG5hbWUgdG8gYmUgXCIgKyBuYW1lICsgXCIsIGZvdW5kIFwiICsgZXZlbnQuYW5pbWF0aW9uTmFtZSkgOiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRWZW5kb3JDU1MoZWwsIFwiYW5pbWF0aW9uTmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiAmJiBjbGVhbihjbGVhblVwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBTVFlMRSA9IHtcbiAgICAgICAgICAgICAgICBESVNQTEFZOiB7XG4gICAgICAgICAgICAgICAgICAgIE5PTkU6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBCTE9DSzogXCJibG9ja1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBWSVNJQklMSVRZOiB7XG4gICAgICAgICAgICAgICAgICAgIFZJU0lCTEU6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBISURERU46IFwiaGlkZGVuXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIElNUE9SVEFOVDogXCJpbXBvcnRhbnRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBTVFlMRS5ESVNQTEFZLk5PTkUsIFNUWUxFLklNUE9SVEFOVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpc0VsZW1lbnRDbG9zZWQoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsIHx8ICFlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SHR0cFR5cGUoY29udGVudFR5cGUsIHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXEub3BlbihcIkdFVFwiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJwcmVmZXRjaCBmYWlsZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SFRNTCh1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SHR0cFR5cGUoXCJ0ZXh0L2h0bWxcIiwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU1hfRVZFTlRTID0ge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IFwiY2xpY2tcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpeFNjcmlwdHMoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB3aW5kb3cuZG9jdW1lbnQsIF9pdGVyYXRvcjcgPSBxdWVyeVNlbGVjdG9yQWxsKGVsLCBcInNjcmlwdFwiKSwgX2lzQXJyYXk3ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I3KSwgX2k3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcgPSBfaXNBcnJheTcgPyBfaXRlcmF0b3I3IDogX2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYxMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNyA+PSBfaXRlcmF0b3I3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaXRlcmF0b3I3W19pNysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjExID0gX2k3LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBfcmVmMTEsIG5ld1NjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQudGV4dCA9IHNjcmlwdC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1NjcmlwdCwgc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2ZuLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICBleHBvcnRzLm9uY2UgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGVkID0gITEsIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5tZW1vaXplID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcInpvaWQ6bWVtb2l6ZVtcIiArICgwLCBfdXRpbC5nZXRPYmplY3RJRCkodmFsKSArIFwiXVwiIDogdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIG5vdCBzZXJpYWxpemFibGUgLS0gY2FuIG5vdCBiZSB1c2VkIHRvIG1lbW9pemVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkgfHwgKHJlc3VsdHNbY2FjaGVLZXldID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDEwMCwgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMsIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWwucmVwbGFjZU9iamVjdCkob2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IFwiX19mdW5jdGlvbl9fXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlc2VyaWFsaXplRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5yZXBsYWNlT2JqZWN0KShvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBmdW5jdGlvbih2YWx1ZSwga2V5LCBmdWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgXCJfX2Z1bmN0aW9uX19cIiA9PT0gdmFsdWUuX190eXBlX18pIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsS2V5OiBmdWxsS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL3V0aWwuanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2dsb2JhbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmdsb2JhbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2xvYmFsRm9yID0gZ2xvYmFsRm9yO1xuICAgICAgICAgICAgZXhwb3J0cy5sb2NhbEdsb2JhbCA9IGxvY2FsR2xvYmFsO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb25zdGFudHMuanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBnbG9iYWxGb3Iod2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjLmlzU2FtZURvbWFpbikod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5bX2NvbnN0YW50cy5fX1pPSURfX10gfHwgKHdpbltfY29uc3RhbnRzLl9fWk9JRF9fXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbltfY29uc3RhbnRzLl9fWk9JRF9fXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsb2NhbEdsb2JhbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsRm9yKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9iYWwpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgbG9jYWwgZ2xvYmFsXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmdsb2JhbCA9IGxvY2FsR2xvYmFsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfZG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9kb20uanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZG9tKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kb21ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2ZuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9mbi5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9mbikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3Byb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL3Byb21pc2UuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcHJvbWlzZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvdXRpbC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF91dGlsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF91dGlsW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2Nzcy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Nzc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfZGVjb3JhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvZGVjb3JhdG9ycy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9kZWNvcmF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kZWNvcmF0b3JzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2xvZ2dlci5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9sb2dnZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2xvZ2dlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZ2xvYmFsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWxba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2xvZ2dlci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obG9nTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9jbGllbnQubG9nTGV2ZWxzLmluZGV4T2YobG9nTGV2ZWwpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvZ0xldmVsOiBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgICAgICBfY2xpZW50LmNvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIF9zcmMuQ09ORklHLkxPR19MRVZFTCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5MT0dfTEVWRUwgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmluZm8gPSBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICAoMCwgX2NsaWVudC5pbmZvKShcInhjX1wiICsgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMud2FybiA9IGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgICgwLCBfY2xpZW50Lndhcm4pKFwieGNfXCIgKyBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgICgwLCBfY2xpZW50LmVycm9yKShcInhjX1wiICsgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2xpYi9wcm9taXNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVub2RlaWZ5ID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPj0gbWV0aG9kLmxlbmd0aCA/IF9zcmMuWmFsZ29Qcm9taXNlLnJlc29sdmUobWV0aG9kLmFwcGx5KHNlbGYsIGFyZ3MpKSA6IG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IG5ldyBFcnJvcihcIlBhc3NlZCBub24tRXJyb3Igb2JqZWN0IGluIGNhbGxiYWNrOiBbIFwiICsgZXJyICsgXCIgXSAtLSBjYWxsYmFja3Mgc2hvdWxkIGVpdGhlciBiZSBjYWxsZWQgd2l0aCBjYWxsYmFjayhuZXcgRXJyb3IoLi4uKSkgb3IgY2FsbGJhY2sobnVsbCwgcmVzdWx0KS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMsIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jeWNsZSA9IGZ1bmN0aW9uIGN5Y2xlKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkobWV0aG9kKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3ljbGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvdXRpbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy51cmxFbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcPy9nLCBcIiUzRlwiKS5yZXBsYWNlKC8mL2csIFwiJTI2XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvXFwrL2csIFwiJTJCXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuY2FtZWxUb0Rhc2hlcml6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRhc2hlcml6ZVRvQ2FtZWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgc291cmNlLmhhc093blByb3BlcnR5KGtleSkgJiYgKG9ialtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdHMucHVzaChvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy51bmlxdWVJRCA9IHVuaXF1ZUlEO1xuICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnlXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gdmFsLnRvU3RyaW5nKCkgOiB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlR2V0ID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihpdGVtLCBwYXRoLCBkZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBkZWY7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdChcIi5cIiksIGkgPSAwOyBpIDwgcGF0aFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpIHx8IG51bGwgPT09IGl0ZW0pIHJldHVybiBkZWY7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtW3BhdGhQYXJ0c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGl0ZW0gPyBkZWYgOiBpdGVtO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2FmZUludGVydmFsID0gc2FmZUludGVydmFsO1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlVGltZW91dCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNhZmVJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aW1lIC09IDEwMCkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkgZm9yICh2YXIgbGVuID0gaXRlbS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIGNhbGxiYWNrKGl0ZW1baV0sIGkpOyBlbHNlIGlmIChcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpKSBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSksIF9sZW4gPSBrZXlzLmxlbmd0aCwgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMucmVwbGFjZU9iamVjdCA9IGZ1bmN0aW9uIHJlcGxhY2VPYmplY3QoaXRlbSwgcmVwbGFjZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxlbmd0aCA9IGl0ZW0ubGVuZ3RoLCByZXN1bHQgPSBbXSwgX2xvb3AgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGkgOiBcIlwiICsgaSwgY2hpbGQgPSBpdGVtW2ldLCB0eXBlID0gdm9pZCAwID09PSBjaGlsZCA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNoaWxkKSwgcmVwbGFjZXIgPSByZXBsYWNlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXBsYWNlcihjaGlsZCwgaSwgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IGNoaWxkID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY2hpbGQpKSAmJiBudWxsICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlcGxhY2VPYmplY3QoY2hpbGQsIHJlcGxhY2VycywgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBfbG9vcChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBfcmV0ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoX3JldCkpKSByZXR1cm4gX3JldC52O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpIHx8IG51bGwgPT09IGl0ZW0pIHRocm93IG5ldyBFcnJvcihcIlBhc3MgYW4gb2JqZWN0IG9yIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JldDMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fSwgX2xvb3AyID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1LZXkgPSBmdWxsS2V5ID8gZnVsbEtleSArIFwiLlwiICsga2V5IDogXCJcIiArIGtleSwgY2hpbGQgPSBpdGVtW2tleV0sIHR5cGUgPSB2b2lkIDAgPT09IGNoaWxkID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY2hpbGQpLCByZXBsYWNlciA9IHJlcGxhY2Vyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZCA9IHJlcGxhY2VyKGNoaWxkLCBrZXksIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gY2hpbGQgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjaGlsZCkpICYmIG51bGwgIT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXBsYWNlT2JqZWN0KGNoaWxkLCByZXBsYWNlcnMsIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaXRlbSkgX2xvb3AyKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gX3JldDMgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihfcmV0MykpKSByZXR1cm4gX3JldDMudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jb3B5UHJvcCA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBuYW1lLCBkZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGFyZ2V0W25hbWVdID0gZGVmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZG90aWZ5ID0gZnVuY3Rpb24gZG90aWZ5KG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIG5ld29iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgXCIuXCIgOiBwcmVmaXg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgdm9pZCAwICE9PSBvYmpba2V5XSAmJiBudWxsICE9PSBvYmpba2V5XSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9ialtrZXldICYmIChvYmpba2V5XSAmJiBBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiBvYmpba2V5XS5sZW5ndGggJiYgb2JqW2tleV0uZXZlcnkoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSB2YWwgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWwpKTtcbiAgICAgICAgICAgICAgICB9KSA/IG5ld29ialtcIlwiICsgcHJlZml4ICsga2V5XSA9IG9ialtrZXldLmpvaW4oXCIsXCIpIDogb2JqW2tleV0gJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihvYmpba2V5XSkgPyBuZXdvYmogPSBkb3RpZnkob2JqW2tleV0sIFwiXCIgKyBwcmVmaXggKyBrZXksIG5ld29iaikgOiBuZXdvYmpbXCJcIiArIHByZWZpeCArIGtleV0gPSBvYmpba2V5XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3b2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0T2JqZWN0SUQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gb2JqIHx8IHZvaWQgMCA9PT0gb2JqIHx8IFwib2JqZWN0XCIgIT09ICh2b2lkIDAgPT09IG9iaiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb2JqKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gb2JqZWN0SURzLmdldChvYmopO1xuICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpZCA9ICh2b2lkIDAgPT09IG9iaiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpICsgXCI6XCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2V4ID0gcmVnZXg7XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2V4QWxsID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXSwgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXgocGF0dGVybiwgc3RyaW5nLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGNoLmVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jb3VudCA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwLCBpdGVtQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc3Vic3RyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtQ291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4gICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2ssIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHN0YWNrKSByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBtZXNzYWdlKSByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZXZlbnRFbWl0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJlZCA9IHt9LCBoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGhhbmRsZXJMaXN0LmluZGV4T2YoaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyTGlzdCkgZm9yICh2YXIgX2l0ZXJhdG9yID0gaGFuZGxlckxpc3QsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaTIgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9oYW5kbGVyID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyT25jZTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyaWdnZXJlZFtldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkW2V2ZW50TmFtZV0gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5pcXVlSUQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzYWZlSW50ZXJ2YWwobWV0aG9kLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcnVuSW50ZXJ2YWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJ1bkludGVydmFsLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmplY3RJRHMgPSBuZXcgKF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKS5XZWFrTWFwKSgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnZXgocGF0dGVybiwgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHBhdHRlcm4gJiYgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKHN0YXJ0KS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5pbmRleCwgbWF0Y2ggPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwczogcmVzdWx0LnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgaW5kZXggKyBtYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1hdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBcIlwiICsgbWF0Y2guc2xpY2UoMCwgc3RhcnQgKyBpbmRleCkgKyB0ZXh0ICsgbWF0Y2guc2xpY2UoaW5kZXggKyBtYXRjaC5sZW5ndGgpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtID8gaXRlbSA6IGl0ZW0gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL3R5cGVzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9em9pZC5mcmFtZS5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvaWQuZnJhbWUuanMubWFwIiwiIWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZSA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBkZWZpbmUgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcInpvaWRcIiwgW10sIGZhY3RvcnkpIDogXCJvYmplY3RcIiA9PSB0eXBlb2YgZXhwb3J0cyA/IGV4cG9ydHMuem9pZCA9IGZhY3RvcnkoKSA6IHJvb3Quem9pZCA9IGZhY3RvcnkoKTtcbn0oXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obW9kdWxlcykge1xuICAgICAgICB2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuICAgICAgICAgICAgdmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuICAgICAgICAgICAgICAgIGk6IG1vZHVsZUlkLFxuICAgICAgICAgICAgICAgIGw6ICExLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4gICAgICAgICAgICBtb2R1bGUubCA9ICEwO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuICAgICAgICB9XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgdmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuZGVmYXVsdDtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIFwiYVwiLCBnZXR0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGdldHRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiAgICB9KHtcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9idWlsZGVycy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmFkZFBheWxvYWRCdWlsZGVyID0gZnVuY3Rpb24oYnVpbGRlcikge1xuICAgICAgICAgICAgICAgIHBheWxvYWRCdWlsZGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkTWV0YUJ1aWxkZXIgPSBmdW5jdGlvbihidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgbWV0YUJ1aWxkZXJzLnB1c2goYnVpbGRlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5hZGRUcmFja2luZ0J1aWxkZXIgPSBmdW5jdGlvbihidWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdCdWlsZGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkSGVhZGVyQnVpbGRlciA9IGZ1bmN0aW9uKGJ1aWxkZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJCdWlsZGVycy5wdXNoKGJ1aWxkZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkQnVpbGRlcnMgPSBleHBvcnRzLnBheWxvYWRCdWlsZGVycyA9IFtdLCBtZXRhQnVpbGRlcnMgPSBleHBvcnRzLm1ldGFCdWlsZGVycyA9IFtdLCB0cmFja2luZ0J1aWxkZXJzID0gZXhwb3J0cy50cmFja2luZ0J1aWxkZXJzID0gW10sIGhlYWRlckJ1aWxkZXJzID0gZXhwb3J0cy5oZWFkZXJCdWlsZGVycyA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2NvbmZpZy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIGluaXRpYWxfc3RhdGVfbmFtZTogXCJpbml0XCIsXG4gICAgICAgICAgICAgICAgZmx1c2hJbnRlcnZhbDogNmU1LFxuICAgICAgICAgICAgICAgIGRlYm91bmNlSW50ZXJ2YWw6IDEwLFxuICAgICAgICAgICAgICAgIHNpemVMaW1pdDogMzAwLFxuICAgICAgICAgICAgICAgIHNpbGVudDogITEsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0OiAhMCxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRDb25zb2xlTG9nOiAhMCxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRJbnRlcnZhbDogNWUzLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRvb0J1c3k6ICExLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRvb0J1c3lUaHJlc2hvbGQ6IDFlNCxcbiAgICAgICAgICAgICAgICBsb2dMZXZlbDogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgYXV0b0xvZzogWyBcIndhcm5cIiwgXCJlcnJvclwiIF0sXG4gICAgICAgICAgICAgICAgbG9nVW5sb2FkOiAhMCxcbiAgICAgICAgICAgICAgICBsb2dQZXJmb3JtYW5jZTogITBcbiAgICAgICAgICAgIH0sIGV4cG9ydHMubG9nTGV2ZWxzID0gWyBcImVycm9yXCIsIFwid2FyblwiLCBcImluZm9cIiwgXCJkZWJ1Z1wiIF07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvaW50ZXJmYWNlLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2ludGVyZmFjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW50ZXJmYWNlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIElOVEVSRkFDRSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG9iaikgZm9yICh2YXIga2V5IGluIG9iaikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiAobmV3T2JqW2tleV0gPSBvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgICAgIH0oX2ludGVyZmFjZSk7XG4gICAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSBJTlRFUkZBQ0U7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvaW5pdC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmluaXQgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLmV4dGVuZCkoX2NvbmZpZy5jb25maWcsIGNvbmYgfHwge30pO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWF0ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpbml0aWF0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5sb2dQZXJmb3JtYW5jZSAmJiAoMCwgX3BlcmZvcm1hbmNlLmluaXRQZXJmb3JtYW5jZSkoKTtcbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5oZWFydGJlYXQgJiYgKDAsIF9wZXJmb3JtYW5jZS5pbml0SGVhcnRCZWF0KSgpO1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnLmNvbmZpZy5sb2dVbmxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKShcIndpbmRvd19iZWZvcmV1bmxvYWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbW1lZGlhdGVGbHVzaCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW5mbykoXCJ3aW5kb3dfdW5sb2FkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIuaW1tZWRpYXRlRmx1c2gpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5mbHVzaEludGVydmFsICYmIHNldEludGVydmFsKF9sb2dnZXIuZmx1c2gsIF9jb25maWcuY29uZmlnLmZsdXNoSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuYmVhdmVyTG9nUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmJlYXZlckxvZ1F1ZXVlLmZvckVhY2goZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9sb2dnZXIubG9nKShwYXlsb2FkLmxldmVsLCBwYXlsb2FkLmV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuYmVhdmVyTG9nUXVldWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2NvbmZpZy5qc1wiKSwgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvdXRpbC5qc1wiKSwgX3BlcmZvcm1hbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3BlcmZvcm1hbmNlLmpzXCIpLCBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2xvZ2dlci5qc1wiKSwgaW5pdGlhdGVkID0gITE7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvaW50ZXJmYWNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2xvZ2dlci5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9sb2dnZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2xvZ2dlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfaW5pdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9pbml0LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2luaXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luaXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3RyYW5zaXRpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3RyYW5zaXRpb25zLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RyYW5zaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90cmFuc2l0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfYnVpbGRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvYnVpbGRlcnMuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfYnVpbGRlcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2J1aWxkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvY29uZmlnLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbmZpZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2xvZ2dlci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnRyYWNrID0gZXhwb3J0cy5mbHVzaCA9IGV4cG9ydHMudHJhY2tpbmcgPSBleHBvcnRzLmJ1ZmZlciA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbihuZXdUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBuZXdUcmFuc3BvcnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcmludCA9IHByaW50O1xuICAgICAgICAgICAgZXhwb3J0cy5pbW1lZGlhdGVGbHVzaCA9IGltbWVkaWF0ZUZsdXNoO1xuICAgICAgICAgICAgZXhwb3J0cy5sb2cgPSBsb2c7XG4gICAgICAgICAgICBleHBvcnRzLnByZWZpeCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZzogZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2coXCJkZWJ1Z1wiLCBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwiaW5mb1wiLCBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdhcm46IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwid2FyblwiLCBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZyhcImVycm9yXCIsIG5hbWUgKyBcIl9cIiArIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2s6IGZ1bmN0aW9uKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHJhY2socGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5kZWJ1ZyA9IGZ1bmN0aW9uKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZyhcImRlYnVnXCIsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmluZm8gPSBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2coXCJpbmZvXCIsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLndhcm4gPSBmdW5jdGlvbihldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2coXCJ3YXJuXCIsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmVycm9yID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nKFwiZXJyb3JcIiwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC91dGlsLmpzXCIpLCBfYnVpbGRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvYnVpbGRlcnMuanNcIiksIF9jb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvY29uZmlnLmpzXCIpLCBidWZmZXIgPSBleHBvcnRzLmJ1ZmZlciA9IFtdLCB0cmFja2luZyA9IGV4cG9ydHMudHJhY2tpbmcgPSBbXTtcbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmIHdpbmRvdy5jb25zb2xlICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2YoY29uc29sZS5sb2cpICYmIFsgXCJsb2dcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCIgXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IHRoaXMuYmluZChjb25zb2xlW21ldGhvZF0sIGNvbnNvbGUpO1xuICAgICAgICAgICAgfSwgRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwpO1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IGZ1bmN0aW9uKGhlYWRlcnMsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF91dGlsLmFqYXgpKFwicG9zdFwiLCBfY29uZmlnLmNvbmZpZy51cmksIGhlYWRlcnMsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSAhMTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gITA7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByaW50KGxldmVsLCBldmVudCwgcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByaW50KGxldmVsLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nTGV2ZWwgPSB3aW5kb3cuTE9HX0xFVkVMIHx8IF9jb25maWcuY29uZmlnLmxvZ0xldmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShfY29uZmlnLmxvZ0xldmVscy5pbmRleE9mKGxldmVsKSA+IF9jb25maWcubG9nTGV2ZWxzLmluZGV4T2YobG9nTGV2ZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZlbnQgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5pc0lFKSgpICYmIChwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKHBheWxvYWQuZXJyb3IgfHwgcGF5bG9hZC53YXJuaW5nKSAmJiBhcmdzLnB1c2goXCJcXG5cXG5cIiwgcGF5bG9hZC5lcnJvciB8fCBwYXlsb2FkLndhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZVtsZXZlbF0gJiYgd2luZG93LmNvbnNvbGVbbGV2ZWxdLmFwcGx5ID8gd2luZG93LmNvbnNvbGVbbGV2ZWxdLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKSA6IHdpbmRvdy5jb25zb2xlLmxvZyAmJiB3aW5kb3cuY29uc29sZS5sb2cuYXBwbHkgJiYgd2luZG93LmNvbnNvbGUubG9nLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGltbWVkaWF0ZUZsdXNoKCkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmJGZpcmVBbmRGb3JnZXQgPSAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fSkuZmlyZUFuZEZvcmdldCwgZmlyZUFuZEZvcmdldCA9IHZvaWQgMCAhPT0gX3JlZiRmaXJlQW5kRm9yZ2V0ICYmIF9yZWYkZmlyZUFuZEZvcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZy5jb25maWcudXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNCdWZmZXIgPSBidWZmZXIubGVuZ3RoLCBoYXNUcmFja2luZyA9IHRyYWNraW5nLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0J1ZmZlciB8fCBoYXNUcmFja2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSB7fSwgX2l0ZXJhdG9yID0gX2J1aWxkZXJzLm1ldGFCdWlsZGVycywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwuZXh0ZW5kKShtZXRhLCBidWlsZGVyKG1ldGEpLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjdXN0b20gbWV0YSBidWlsZGVyOlwiLCBlcnIuc3RhY2sgfHwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge30sIF9pdGVyYXRvcjIgPSBfYnVpbGRlcnMuaGVhZGVyQnVpbGRlcnMsIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYnVpbGRlciA9IF9yZWYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5leHRlbmQpKGhlYWRlcnMsIF9idWlsZGVyKGhlYWRlcnMpLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjdXN0b20gaGVhZGVyIGJ1aWxkZXI6XCIsIGVyci5zdGFjayB8fCBlcnIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHRyYW5zcG9ydChoZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZzogdHJhY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiBmaXJlQW5kRm9yZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuYnVmZmVyID0gYnVmZmVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLnRyYWNraW5nID0gdHJhY2tpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2ZsdXNoID0gKDAsIF91dGlsLnByb21pc2VEZWJvdW5jZSkoaW1tZWRpYXRlRmx1c2gsIF9jb25maWcuY29uZmlnLmRlYm91bmNlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgZXhwb3J0cy5mbHVzaCA9IF9mbHVzaDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVucXVldWUobGV2ZWwsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb25maWcuY29uZmlnLmF1dG9Mb2cuaW5kZXhPZihsZXZlbCkgPiAtMSAmJiBfZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxvZyhsZXZlbCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5wcmVmaXggJiYgKGV2ZW50ID0gX2NvbmZpZy5jb25maWcucHJlZml4ICsgXCJfXCIgKyBldmVudCk7XG4gICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PSB0eXBlb2YgKHBheWxvYWQgPSBwYXlsb2FkIHx8IHt9KSA/IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBheWxvYWRcbiAgICAgICAgICAgICAgICB9IDogcGF5bG9hZCBpbnN0YW5jZW9mIEVycm9yICYmIChwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGF5bG9hZC5zdGFjayB8fCBwYXlsb2FkLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXlsb2FkLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfYnVpbGRlcnMucGF5bG9hZEJ1aWxkZXJzLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBfcmVmNDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbC5leHRlbmQpKHBheWxvYWQsIGJ1aWxkZXIocGF5bG9hZCksICExKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY3VzdG9tIHBheWxvYWQgYnVpbGRlcjpcIiwgZXJyLnN0YWNrIHx8IGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29uZmlnLmNvbmZpZy5zaWxlbnQgfHwgcHJpbnQobGV2ZWwsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoID09PSBfY29uZmlnLmNvbmZpZy5zaXplTGltaXQgPyBlbnF1ZXVlKFwiaW5mb1wiLCBcImxvZ2dlcl9tYXhfYnVmZmVyX2xlbmd0aFwiKSA6IGJ1ZmZlci5sZW5ndGggPCBfY29uZmlnLmNvbmZpZy5zaXplTGltaXQgJiYgZW5xdWV1ZShsZXZlbCwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX3RyYWNrKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2J1aWxkZXJzLnRyYWNraW5nQnVpbGRlcnMsIF9pc0FycmF5NCA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNCksIF9pNCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNCA9IF9pc0FycmF5NCA/IF9pdGVyYXRvcjQgOiBfaXRlcmF0b3I0W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k0ID0gX2l0ZXJhdG9yNC5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBfcmVmNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLmV4dGVuZCkocGF5bG9hZCwgYnVpbGRlcihwYXlsb2FkKSwgITEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGN1c3RvbSB0cmFja2luZyBidWlsZGVyOlwiLCBlcnIuc3RhY2sgfHwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaW50KFwiZGVidWdcIiwgXCJ0cmFja2luZ1wiLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmcucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnRyYWNrID0gX3RyYWNrO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3BlcmZvcm1hbmNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMucmVxVGltZXIgPSBleHBvcnRzLmNsaWVudFRpbWVyID0gdm9pZCAwO1xuICAgICAgICAgICAgZXhwb3J0cy5ub3cgPSBub3c7XG4gICAgICAgICAgICBleHBvcnRzLnJlcVN0YXJ0RWxhcHNlZCA9IHJlcVN0YXJ0RWxhcHNlZDtcbiAgICAgICAgICAgIGV4cG9ydHMuaW5pdEhlYXJ0QmVhdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFydEJlYXRUaW1lciA9IHRpbWVyKCksIGhlYXJ0YmVhdENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwuc2FmZUludGVydmFsKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0TWF4VGhyZXNob2xkICYmIGhlYXJ0YmVhdENvdW50ID4gX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0TWF4VGhyZXNob2xkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhcnRiZWF0Q291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGFwc2VkID0gaGVhcnRCZWF0VGltZXIuZWxhcHNlZCgpLCBsYWcgPSBlbGFwc2VkIC0gX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0SW50ZXJ2YWwsIGhlYXJ0YmVhdFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IGhlYXJ0YmVhdENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsYXBzZWQ6IGVsYXBzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZy5jb25maWcuaGVhcnRiZWF0VG9vQnVzeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFBheWxvYWQubGFnID0gbGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhZyA+PSBfY29uZmlnLmNvbmZpZy5oZWFydGJlYXRUb29CdXN5VGhyZXNob2xkICYmICgwLCBfbG9nZ2VyLmluZm8pKFwidG9vYnVzeVwiLCBoZWFydGJlYXRQYXlsb2FkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vQ29uc29sZTogIV9jb25maWcuY29uZmlnLmhlYXJ0YmVhdENvbnNvbGVMb2dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmluZm8pKFwiaGVhcnRiZWF0XCIsIGhlYXJ0YmVhdFBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub0NvbnNvbGU6ICFfY29uZmlnLmNvbmZpZy5oZWFydGJlYXRDb25zb2xlTG9nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jb25maWcuY29uZmlnLmhlYXJ0YmVhdEludGVydmFsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmluaXRQZXJmb3JtYW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlUGVyZm9ybWFuY2UpIHJldHVybiAoMCwgX2xvZ2dlci5pbmZvKShcIm5vX3BlcmZvcm1hbmNlX2RhdGFcIik7XG4gICAgICAgICAgICAgICAgKDAsIF9idWlsZGVycy5hZGRQYXlsb2FkQnVpbGRlcikoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2xpZW50X2VsYXBzZWQgPSBjbGllbnRUaW1lci5lbGFwc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZVBlcmZvcm1hbmNlICYmIChwYXlsb2FkLnJlcV9lbGFwc2VkID0gcmVxVGltZXIuZWxhcHNlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3V0aWwud2luZG93UmVhZHkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWluZyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBbIFwiY29ubmVjdEVuZFwiLCBcImNvbm5lY3RTdGFydFwiLCBcImRvbUNvbXBsZXRlXCIsIFwiZG9tQ29udGVudExvYWRlZEV2ZW50RW5kXCIsIFwiZG9tQ29udGVudExvYWRlZEV2ZW50U3RhcnRcIiwgXCJkb21JbnRlcmFjdGl2ZVwiLCBcImRvbUxvYWRpbmdcIiwgXCJkb21haW5Mb29rdXBFbmRcIiwgXCJkb21haW5Mb29rdXBTdGFydFwiLCBcImZldGNoU3RhcnRcIiwgXCJsb2FkRXZlbnRFbmRcIiwgXCJsb2FkRXZlbnRTdGFydFwiLCBcIm5hdmlnYXRpb25TdGFydFwiLCBcInJlZGlyZWN0RW5kXCIsIFwicmVkaXJlY3RTdGFydFwiLCBcInJlcXVlc3RTdGFydFwiLCBcInJlc3BvbnNlRW5kXCIsIFwicmVzcG9uc2VTdGFydFwiLCBcInNlY3VyZUNvbm5lY3Rpb25TdGFydFwiLCBcInVubG9hZEV2ZW50RW5kXCIsIFwidW5sb2FkRXZlbnRTdGFydFwiIF0uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWluZ1trZXldID0gcGFyc2VJbnQod2luZG93LnBlcmZvcm1hbmNlLnRpbWluZ1trZXldLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aW1pbmcuY29ubmVjdEVuZCAtIHRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHRpbWluZy5jb25uZWN0RW5kICYmIE9iamVjdC5rZXlzKHRpbWluZykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZSA9IHRpbWluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgJiYgKDAsIF9sb2dnZXIuaW5mbykoXCJ0aW1pbmdfXCIgKyBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50X2VsYXBzZWQ6IHBhcnNlSW50KHRpbWUgLSB0aW1pbmcuY29ubmVjdEVuZCAtIChjbGllbnRUaW1lci5zdGFydFRpbWUgLSBvZmZzZXQpLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxX2VsYXBzZWQ6IHBhcnNlSW50KHRpbWUgLSB0aW1pbmcuY29ubmVjdEVuZCwgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmluZm8pKFwidGltaW5nXCIsIHRpbWluZyk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmluZm8pKFwibWVtb3J5XCIsIHdpbmRvdy5wZXJmb3JtYW5jZS5tZW1vcnkpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKShcIm5hdmlnYXRpb25cIiwgd2luZG93LnBlcmZvcm1hbmNlLm5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllcyAmJiB3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllcygpLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJsaW5rXCIsIFwic2NyaXB0XCIsIFwiaW1nXCIsIFwiY3NzXCIgXS5pbmRleE9mKHJlc291cmNlLmluaXRpYXRvclR5cGUpID4gLTEgJiYgKDAsIF9sb2dnZXIuaW5mbykocmVzb3VyY2UuaW5pdGlhdG9yVHlwZSwgcmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9iZWF2ZXItbG9nZ2VyL2NsaWVudC9jb25maWcuanNcIiksIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvbG9nZ2VyLmpzXCIpLCBfYnVpbGRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvYnVpbGRlcnMuanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3V0aWwuanNcIiksIGVuYWJsZVBlcmZvcm1hbmNlID0gd2luZG93ICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgJiYgcGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5jb25uZWN0RW5kICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgJiYgTWF0aC5hYnMocGVyZm9ybWFuY2Uubm93KCkgLSBEYXRlLm5vdygpKSA+IDFlMyAmJiBwZXJmb3JtYW5jZS5ub3coKSAtIChwZXJmb3JtYW5jZS50aW1pbmcuY29ubmVjdEVuZCAtIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpID4gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vdygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlUGVyZm9ybWFuY2UgPyBwZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0aW1lcihzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSA9IHZvaWQgMCAhPT0gc3RhcnRUaW1lID8gc3RhcnRUaW1lIDogbm93KCksXG4gICAgICAgICAgICAgICAgICAgIGVsYXBzZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG5vdygpIC0gc3RhcnRUaW1lLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlcVN0YXJ0RWxhcHNlZCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlUGVyZm9ybWFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWluZyA9IHdpbmRvdy5wZXJmb3JtYW5jZS50aW1pbmc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aW1pbmcuY29ubmVjdEVuZCAtIHRpbWluZy5uYXZpZ2F0aW9uU3RhcnQsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xpZW50VGltZXIgPSBleHBvcnRzLmNsaWVudFRpbWVyID0gdGltZXIoKSwgcmVxVGltZXIgPSBleHBvcnRzLnJlcVRpbWVyID0gdGltZXIocmVxU3RhcnRFbGFwc2VkKCkpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3RyYW5zaXRpb25zLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gc3RhcnRUcmFuc2l0aW9uO1xuICAgICAgICAgICAgZXhwb3J0cy5lbmRUcmFuc2l0aW9uID0gZW5kVHJhbnNpdGlvbjtcbiAgICAgICAgICAgIGV4cG9ydHMudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHRvU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBlbmRUcmFuc2l0aW9uKHRvU3RhdGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfcGVyZm9ybWFuY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvcGVyZm9ybWFuY2UuanNcIiksIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvbG9nZ2VyLmpzXCIpLCBfYnVpbGRlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvYnVpbGRlcnMuanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3V0aWwuanNcIiksIF9jb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvYmVhdmVyLWxvZ2dlci9jbGllbnQvY29uZmlnLmpzXCIpLCB3aW5kb3dJRCA9ICgwLCBcbiAgICAgICAgICAgIF91dGlsLnVuaXF1ZUlEKSgpLCBwYWdlSUQgPSAoMCwgX3V0aWwudW5pcXVlSUQpKCksIGN1cnJlbnRTdGF0ZSA9IF9jb25maWcuY29uZmlnLmluaXRpYWxfc3RhdGVfbmFtZSwgc3RhcnRUaW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9ICgwLCBfcGVyZm9ybWFuY2Uubm93KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZW5kVHJhbnNpdGlvbih0b1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lID0gc3RhcnRUaW1lIHx8ICgwLCBfcGVyZm9ybWFuY2UucmVxU3RhcnRFbGFwc2VkKSgpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9ICgwLCBfcGVyZm9ybWFuY2Uubm93KSgpLCBlbGFwc2VkVGltZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2b2lkIDAgIT09IHN0YXJ0VGltZSAmJiAoZWxhcHNlZFRpbWUgPSBwYXJzZUludChjdXJyZW50VGltZSAtIHN0YXJ0VGltZSwgMCkpO1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uTmFtZSA9IFwidHJhbnNpdGlvbl9cIiArIGN1cnJlbnRTdGF0ZSArIFwiX3RvX1wiICsgdG9TdGF0ZTtcbiAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci5pbmZvKSh0cmFuc2l0aW9uTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZWxhcHNlZFRpbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAoMCwgX2xvZ2dlci50cmFjaykoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl90aW1lOiBlbGFwc2VkVGltZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICgwLCBfbG9nZ2VyLmltbWVkaWF0ZUZsdXNoKSgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IHRvU3RhdGU7XG4gICAgICAgICAgICAgICAgcGFnZUlEID0gKDAsIF91dGlsLnVuaXF1ZUlEKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIF9idWlsZGVycy5hZGRQYXlsb2FkQnVpbGRlcikoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93SUQ6IHdpbmRvd0lELFxuICAgICAgICAgICAgICAgICAgICBwYWdlSUQ6IHBhZ2VJRFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICgwLCBfYnVpbGRlcnMuYWRkTWV0YUJ1aWxkZXIpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcInVpX1wiICsgY3VycmVudFN0YXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L3V0aWwuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy53aW5kb3dSZWFkeSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oZGVzdCwgc3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXIgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdKSB8fCBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgZGVzdCA9IGRlc3QgfHwge307XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjIHx8IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gc3JjKSBzcmMuaGFzT3duUHJvcGVydHkoaSkgJiYgKCFvdmVyICYmIGRlc3QuaGFzT3duUHJvcGVydHkoaSkgfHwgKGRlc3RbaV0gPSBzcmNbaV0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzU2FtZVByb3RvY29sID0gaXNTYW1lUHJvdG9jb2w7XG4gICAgICAgICAgICBleHBvcnRzLmlzU2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbjtcbiAgICAgICAgICAgIGV4cG9ydHMuYWpheCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9LCBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiB7fSwgX3JlZiRmaXJlQW5kRm9yZ2V0ID0gKGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzRdID8gYXJndW1lbnRzWzRdIDoge30pLmZpcmVBbmRGb3JnZXQsIGZpcmVBbmRGb3JnZXQgPSB2b2lkIDAgIT09IF9yZWYkZmlyZUFuZEZvcmdldCAmJiBfcmVmJGZpcmVBbmRGb3JnZXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBYUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCB3aW5kb3cuQWN0aXZlWE9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhaXNTYW1lRG9tYWluKHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNTYW1lUHJvdG9jb2wodXJsKSkgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFhSZXF1ZXN0ID0gd2luZG93LlhEb21haW5SZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWFJlcXVlc3QoXCJNU1hNTDIuWE1MSFRUUC4zLjBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vcGVuKG1ldGhvZC50b1VwcGVyQ2FzZSgpLCB1cmwsICEwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVxLnNldFJlcXVlc3RIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLCBcIlhNTEh0dHBSZXF1ZXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBoZWFkZXJzKSBoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlck5hbWUpICYmIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIGhlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQgPyByZXNvbHZlKCkgOiByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXEucmVhZHlTdGF0ZSA+IDMgJiYgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXEuc2VuZChKU09OLnN0cmluZ2lmeShkYXRhKS5yZXBsYWNlKC8mL2csIFwiJTI2XCIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnByb21pc2VEZWJvdW5jZSA9IGZ1bmN0aW9uKG1ldGhvZCwgaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVib3VuY2UgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVib3VuY2UudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSBkZWJvdW5jZS5yZXNvbHZlciwgcmVqZWN0b3IgPSBkZWJvdW5jZS5yZWplY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkZWJvdW5jZS5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlLnJlc29sdmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlLnJlamVjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRlYm91bmNlLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzb2x2ZXIsIHJlamVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZS5wcm9taXNlID0gZGVib3VuY2UucHJvbWlzZSB8fCBuZXcgX3NyYy5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZXIsIHJlamVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJvdW5jZS5yZXNvbHZlciA9IHJlc29sdmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVib3VuY2UucmVqZWN0b3IgPSByZWplY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWJvdW5jZS5wcm9taXNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlSW50ZXJ2YWwgPSBmdW5jdGlvbihtZXRob2QsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMudW5pcXVlSUQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ4eHh4eHh4eHh4XCIucmVwbGFjZSgvLi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzSUUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzU2FtZVByb3RvY29sKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IHVybC5zcGxpdChcIi9cIilbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NhbWVEb21haW4odXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdXJsLm1hdGNoKC9odHRwcz86XFwvXFwvW14vXSsvKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW1hdGNoIHx8IG1hdGNoWzBdID09PSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMud2luZG93UmVhZHkgPSBuZXcgX3NyYy5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGRvY3VtZW50ICYmIFwiY29tcGxldGVcIiA9PT0gZG9jdW1lbnQucmVhZHlTdGF0ZSAmJiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW50ZXJmYWNlLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2ludGVyZmFjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW50ZXJmYWNlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIElOVEVSRkFDRSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG9iaikgZm9yICh2YXIga2V5IGluIG9iaikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiAobmV3T2JqW2tleV0gPSBvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgICAgIH0oX2ludGVyZmFjZSk7XG4gICAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSBJTlRFUkZBQ0U7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW50ZXJmYWNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfd2Vha21hcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy93ZWFrbWFwLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2Vha01hcFwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF93ZWFrbWFwLkNyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvbmF0aXZlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuaGFzTmF0aXZlV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LldlYWtNYXApIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5PYmplY3QuZnJlZXplKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3RXZWFrTWFwID0gbmV3IHdpbmRvdy5XZWFrTWFwKCksIHRlc3RLZXkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lk9iamVjdC5mcmVlemUodGVzdEtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RXZWFrTWFwLnNldCh0ZXN0S2V5LCBcIl9fdGVzdHZhbHVlX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9fdGVzdHZhbHVlX19cIiA9PT0gdGVzdFdlYWtNYXAuZ2V0KHRlc3RLZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy91dGlsLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuc2FmZUluZGV4T2YgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL3dlYWttYXAuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX25hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9uYXRpdmUuanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL3V0aWwuanNcIik7XG4gICAgICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGNvdW50ZXIgPSBEYXRlLm5vdygpICUgMWU5O1xuICAgICAgICAgICAgZXhwb3J0cy5Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ3Jvc3NEb21haW5TYWZlV2Vha01hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgQ3Jvc3NEb21haW5TYWZlV2Vha01hcCk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJfX3dlYWttYXBfXCIgKyAoMWU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCkgKyBcIl9fXCIgKyBjb3VudGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9uYXRpdmUuaGFzTmF0aXZlV2Vha01hcCkoKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2Vha21hcCA9IG5ldyB3aW5kb3cuV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBDcm9zc0RvbWFpblNhZmVXZWFrTWFwLnByb3RvdHlwZS5fY2xlYW51cENsb3NlZFdpbmRvd3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd2Vha21hcCA9IHRoaXMud2Vha21hcCwga2V5cyA9IHRoaXMua2V5cywgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjLmlzV2luZG93KSh2YWx1ZSkgJiYgKDAsIF9zcmMuaXNXaW5kb3dDbG9zZWQpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlLmlzU2FmZVRvUmVhZFdyaXRlID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1dpbmRvdykoa2V5KSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKGtleSAmJiBrZXkuc2VsZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwubm9vcCkoa2V5ICYmIGtleVt0aGlzLm5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ3Jvc3NEb21haW5TYWZlV2Vha01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsIGVudHJ5ID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdID0gdmFsdWUgOiBkZWZpbmVQcm9wZXJ0eShrZXksIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogWyBrZXksIHZhbHVlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cywgdmFsdWVzID0gdGhpcy52YWx1ZXMsIGluZGV4ID0gKDAsIF91dGlsLnNhZmVJbmRleE9mKShrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwLmhhcyhrZXkpKSByZXR1cm4gd2Vha21hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsIGluZGV4ID0gKDAsIF91dGlsLnNhZmVJbmRleE9mKShrZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkpIHJldHVybiBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENyb3NzRG9tYWluU2FmZVdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtleSkgdGhyb3cgbmV3IEVycm9yKFwiV2Vha01hcCBleHBlY3RlZCBrZXlcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYWttYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5ICYmIGVudHJ5WzBdID09PSBrZXkgJiYgKGVudHJ5WzBdID0gZW50cnlbMV0gPSB2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLCBpbmRleCA9ICgwLCBfdXRpbC5zYWZlSW5kZXhPZikoa2V5cywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ3Jvc3NEb21haW5TYWZlV2Vha01hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdlYWttYXAuaGFzKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCFlbnRyeSB8fCBlbnRyeVswXSAhPT0ga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09ICgwLCBfdXRpbC5zYWZlSW5kZXhPZikodGhpcy5rZXlzLCBrZXkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIENyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvdXRpbHMuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdXRpbHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3V0aWxzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF90eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL3R5cGVzLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3R5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90eXBlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL3R5cGVzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy91dGlsLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNSZWdleCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy91dGlscy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmlzRmlsZVByb3RvY29sID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdykubG9jYXRpb24ucHJvdG9jb2wgPT09IENPTlNUQU5UUy5GSUxFX1BST1RPQ09MO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNBYm91dFByb3RvY29sID0gaXNBYm91dFByb3RvY29sO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRQYXJlbnQgPSBnZXRQYXJlbnQ7XG4gICAgICAgICAgICBleHBvcnRzLmdldE9wZW5lciA9IGdldE9wZW5lcjtcbiAgICAgICAgICAgIGV4cG9ydHMuY2FuUmVhZEZyb21XaW5kb3cgPSBjYW5SZWFkRnJvbVdpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0QWN0dWFsRG9tYWluID0gZ2V0QWN0dWFsRG9tYWluO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXREb21haW4gPSBnZXREb21haW47XG4gICAgICAgICAgICBleHBvcnRzLmlzQmxhbmtEb21haW4gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbi5sb2NhdGlvbi5ocmVmKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImFib3V0OmJsYW5rXCIgPT09IHdpbi5sb2NhdGlvbi5ocmVmKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzQWN0dWFsbHlTYW1lRG9tYWluID0gaXNBY3R1YWxseVNhbWVEb21haW47XG4gICAgICAgICAgICBleHBvcnRzLmlzU2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbjtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UGFyZW50cyA9IGdldFBhcmVudHM7XG4gICAgICAgICAgICBleHBvcnRzLmlzQW5jZXN0b3JQYXJlbnQgPSBpc0FuY2VzdG9yUGFyZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRGcmFtZXMgPSBnZXRGcmFtZXM7XG4gICAgICAgICAgICBleHBvcnRzLmdldEFsbENoaWxkRnJhbWVzID0gZ2V0QWxsQ2hpbGRGcmFtZXM7XG4gICAgICAgICAgICBleHBvcnRzLmdldFRvcCA9IGdldFRvcDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0QWxsRnJhbWVzSW5XaW5kb3cgPSBnZXRBbGxGcmFtZXNJbldpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMuaXNUb3AgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luID09PSBnZXRUb3Aod2luKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzRnJhbWVXaW5kb3dDbG9zZWQgPSBpc0ZyYW1lV2luZG93Q2xvc2VkO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1dpbmRvd0Nsb3NlZCA9IGlzV2luZG93Q2xvc2VkO1xuICAgICAgICAgICAgZXhwb3J0cy5saW5rRnJhbWVXaW5kb3cgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgICFmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZnJhbWVGcmFtZXMubGVuZ3RoOyBpKyspIGlmIChpc0ZyYW1lV2luZG93Q2xvc2VkKGlmcmFtZUZyYW1lc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZUZyYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVXaW5kb3dzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBpZnJhbWVXaW5kb3dzLmxlbmd0aDsgX2k1KyspIGlmIChpc1dpbmRvd0Nsb3NlZChpZnJhbWVXaW5kb3dzW19pNV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVGcmFtZXMuc3BsaWNlKF9pNSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWVXaW5kb3dzLnNwbGljZShfaTUsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93KSB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWVXaW5kb3dzLnB1c2goZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZUZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRVc2VyQWdlbnQgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHdpbiA9IHdpbiB8fCB3aW5kb3cpLm5hdmlnYXRvci5tb2NrVXNlckFnZW50IHx8IHdpbi5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0RnJhbWVCeU5hbWUgPSBnZXRGcmFtZUJ5TmFtZTtcbiAgICAgICAgICAgIGV4cG9ydHMuZmluZENoaWxkRnJhbWVCeU5hbWUgPSBmaW5kQ2hpbGRGcmFtZUJ5TmFtZTtcbiAgICAgICAgICAgIGV4cG9ydHMuZmluZEZyYW1lQnlOYW1lID0gZnVuY3Rpb24od2luLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZSA9IGdldEZyYW1lQnlOYW1lKHdpbiwgbmFtZSkpIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZENoaWxkRnJhbWVCeU5hbWUoZ2V0VG9wKHdpbikgfHwgd2luLCBuYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzUGFyZW50ID0gZnVuY3Rpb24od2luLCBmcmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZVBhcmVudCA9IGdldFBhcmVudChmcmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lUGFyZW50KSByZXR1cm4gZnJhbWVQYXJlbnQgPT09IHdpbjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3I2ID0gZ2V0RnJhbWVzKHdpbiksIF9pc0FycmF5NiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNiksIF9pOCA9IDAsIF9pdGVyYXRvcjYgPSBfaXNBcnJheTYgPyBfaXRlcmF0b3I2IDogX2l0ZXJhdG9yNltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY2O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k4ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gX2l0ZXJhdG9yNltfaTgrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pOCA9IF9pdGVyYXRvcjYubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY2ID0gX2k4LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEZyYW1lID0gX3JlZjY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEZyYW1lID09PSBmcmFtZSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc09wZW5lciA9IGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50ID09PSBnZXRPcGVuZXIoY2hpbGQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0QW5jZXN0b3IgPSBnZXRBbmNlc3RvcjtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0QW5jZXN0b3JzID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXSwgYW5jZXN0b3IgPSB3aW47XG4gICAgICAgICAgICAgICAgZm9yICg7YW5jZXN0b3I7ICkgKGFuY2VzdG9yID0gZ2V0QW5jZXN0b3IoYW5jZXN0b3IpKSAmJiByZXN1bHRzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNBbmNlc3RvciA9IGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsUGFyZW50ID0gZ2V0QW5jZXN0b3IoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGlmIChhY3R1YWxQYXJlbnQpIHJldHVybiBhY3R1YWxQYXJlbnQgPT09IHBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGlmIChnZXRUb3AoY2hpbGQpID09PSBjaGlsZCkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjcgPSBnZXRGcmFtZXMocGFyZW50KSwgX2lzQXJyYXk3ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I3KSwgX2k5ID0gMCwgX2l0ZXJhdG9yNyA9IF9pc0FycmF5NyA/IF9pdGVyYXRvcjcgOiBfaXRlcmF0b3I3W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTkgPj0gX2l0ZXJhdG9yNy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3I3W19pOSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k5ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjcgPSBfaTkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX3JlZjc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSA9PT0gY2hpbGQpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNQb3B1cCA9IGlzUG9wdXA7XG4gICAgICAgICAgICBleHBvcnRzLmlzSWZyYW1lID0gaXNJZnJhbWU7XG4gICAgICAgICAgICBleHBvcnRzLmlzRnVsbHBhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbighaXNJZnJhbWUoKSAmJiAhaXNQb3B1cCgpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldERpc3RhbmNlRnJvbVRvcCA9IGdldERpc3RhbmNlRnJvbVRvcDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0TnRoUGFyZW50ID0gZ2V0TnRoUGFyZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXROdGhQYXJlbnRGcm9tVG9wID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE50aFBhcmVudCh3aW4sIGdldERpc3RhbmNlRnJvbVRvcCh3aW4pIC0gbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc1NhbWVUb3BXaW5kb3cgPSBmdW5jdGlvbih3aW4xLCB3aW4yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcDEgPSBnZXRUb3Aod2luMSkgfHwgd2luMSwgdG9wMiA9IGdldFRvcCh3aW4yKSB8fCB3aW4yO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AxICYmIHRvcDIpIHJldHVybiB0b3AxID09PSB0b3AyO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB2YXIgYWxsRnJhbWVzMSA9IGdldEFsbEZyYW1lc0luV2luZG93KHdpbjEpLCBhbGxGcmFtZXMyID0gZ2V0QWxsRnJhbWVzSW5XaW5kb3cod2luMik7XG4gICAgICAgICAgICAgICAgaWYgKGFueU1hdGNoKGFsbEZyYW1lczEsIGFsbEZyYW1lczIpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5lcjEgPSBnZXRPcGVuZXIodG9wMSksIG9wZW5lcjIgPSBnZXRPcGVuZXIodG9wMik7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5lcjEgJiYgYW55TWF0Y2goZ2V0QWxsRnJhbWVzSW5XaW5kb3cob3BlbmVyMSksIGFsbEZyYW1lczIpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5lcjIgJiYgYW55TWF0Y2goZ2V0QWxsRnJhbWVzSW5XaW5kb3cob3BlbmVyMiksIGFsbEZyYW1lczEpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubWF0Y2hEb21haW4gPSBmdW5jdGlvbiBtYXRjaERvbWFpbihwYXR0ZXJuLCBvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygb3JpZ2luKSByZXR1cm4gcGF0dGVybiA9PT0gQ09OU1RBTlRTLldJTERDQVJEIHx8IG9yaWdpbiA9PT0gcGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfdXRpbC5pc1JlZ2V4KShvcmlnaW4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfdXRpbC5pc1JlZ2V4KShwYXR0ZXJuKSkgcmV0dXJuICgwLCBfdXRpbC5pc1JlZ2V4KShvcmlnaW4pID8gcGF0dGVybi50b1N0cmluZygpID09PSBvcmlnaW4udG9TdHJpbmcoKSA6ICFBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgQm9vbGVhbihvcmlnaW4ubWF0Y2gocGF0dGVybikpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSByZXR1cm4gQXJyYXkuaXNBcnJheShvcmlnaW4pID8gSlNPTi5zdHJpbmdpZnkocGF0dGVybikgPT09IEpTT04uc3RyaW5naWZ5KG9yaWdpbikgOiAhKDAsIFxuICAgICAgICAgICAgICAgIF91dGlsLmlzUmVnZXgpKG9yaWdpbikgJiYgcGF0dGVybi5zb21lKGZ1bmN0aW9uKHN1YnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoRG9tYWluKHN1YnBhdHRlcm4sIG9yaWdpbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5RG9tYWluUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXR0ZXJuKSA/IFwiKFwiICsgcGF0dGVybi5qb2luKFwiIHwgXCIpICsgXCIpXCIgOiAoMCwgX3V0aWwuaXNSZWdleCkocGF0dGVybikgPyBcIlJlZ0V4cChcIiArIHBhdHRlcm4udG9TdHJpbmcoKSA6IHBhdHRlcm4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldERvbWFpbkZyb21VcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICghdXJsLm1hdGNoKC9eKGh0dHBzP3xtb2NrfGZpbGUpOlxcL1xcLy8pKSByZXR1cm4gZ2V0RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gdXJsO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21haW4gPSBkb21haW4uc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMub25DbG9zZVdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IDFlMywgbWF4dGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogMSAvIDAsIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4dGltZSA8PSAwKSBjbGVhclRpbWVvdXQodGltZW91dCk7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4dGltZSAtPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNoZWNrLCBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzV2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5XaW5kb3cgJiYgb2JqIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnNlbGYgPT09IG9iaikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmoudG9wID09PSBvYmopIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwubm9vcCkob2JqID09IG9iaik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF91dGlsLm5vb3ApKG9iaiAmJiBvYmouX19jcm9zc19kb21haW5fdXRpbHNfd2luZG93X2NoZWNrX18pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy91dGlsLmpzXCIpLCBDT05TVEFOVFMgPSB7XG4gICAgICAgICAgICAgICAgTU9DS19QUk9UT0NPTDogXCJtb2NrOlwiLFxuICAgICAgICAgICAgICAgIEZJTEVfUFJPVE9DT0w6IFwiZmlsZTpcIixcbiAgICAgICAgICAgICAgICBBQk9VVF9QUk9UT0NPTDogXCJhYm91dDpcIixcbiAgICAgICAgICAgICAgICBXSUxEQ0FSRDogXCIqXCJcbiAgICAgICAgICAgIH0sIElFX1dJTl9BQ0NFU1NfRVJST1IgPSBcIkNhbGwgd2FzIHJlamVjdGVkIGJ5IGNhbGxlZS5cXHJcXG5cIjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzQWJvdXRQcm90b2NvbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogd2luZG93KS5sb2NhdGlvbi5wcm90b2NvbCA9PT0gQ09OU1RBTlRTLkFCT1VUX1BST1RPQ09MO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGFyZW50KHdpbikge1xuICAgICAgICAgICAgICAgIGlmICh3aW4pIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4ucGFyZW50ICYmIHdpbi5wYXJlbnQgIT09IHdpbikgcmV0dXJuIHdpbi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0T3BlbmVyKHdpbikge1xuICAgICAgICAgICAgICAgIGlmICh3aW4gJiYgIWdldFBhcmVudCh3aW4pKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwubm9vcCkod2luICYmIHdpbi5sb2NhdGlvbiAmJiB3aW4ubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWN0dWFsRG9tYWluKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHdpbi5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlYWQgd2luZG93IGxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgICAgIGlmICghcHJvdG9jb2wpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgcHJvdG9jb2xcIik7XG4gICAgICAgICAgICAgICAgaWYgKHByb3RvY29sID09PSBDT05TVEFOVFMuRklMRV9QUk9UT0NPTCkgcmV0dXJuIENPTlNUQU5UUy5GSUxFX1BST1RPQ09MICsgXCIvL1wiO1xuICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbCA9PT0gQ09OU1RBTlRTLkFCT1VUX1BST1RPQ09MKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQod2luKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pID8gZ2V0QWN0dWFsRG9tYWluKHBhcmVudCkgOiBDT05TVEFOVFMuQUJPVVRfUFJPVE9DT0wgKyBcIi8vXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdDtcbiAgICAgICAgICAgICAgICBpZiAoIWhvc3QpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgaG9zdFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBcIi8vXCIgKyBob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0RG9tYWluKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBnZXRBY3R1YWxEb21haW4od2luID0gd2luIHx8IHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbWFpbiAmJiB3aW4ubW9ja0RvbWFpbiAmJiAwID09PSB3aW4ubW9ja0RvbWFpbi5pbmRleE9mKENPTlNUQU5UUy5NT0NLX1BST1RPQ09MKSA/IHdpbi5tb2NrRG9tYWluIDogZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNBY3R1YWxseVNhbWVEb21haW4od2luKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW4sIFwibG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmICExID09PSBkZXNjLmVudW1lcmFibGUpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KHdpbikpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEFjdHVhbERvbWFpbih3aW4pID09PSBnZXRBY3R1YWxEb21haW4od2luZG93KSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NhbWVEb21haW4od2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FjdHVhbGx5U2FtZURvbWFpbih3aW4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Fib3V0UHJvdG9jb2wod2luKSAmJiBjYW5SZWFkRnJvbVdpbmRvdyh3aW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXREb21haW4od2luZG93KSA9PT0gZ2V0RG9tYWluKHdpbikpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGFyZW50cyh3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7d2luLnBhcmVudCAhPT0gd2luOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdpbi5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luID0gd2luLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNBbmNlc3RvclBhcmVudChwYXJlbnQsIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkUGFyZW50ID0gZ2V0UGFyZW50KGNoaWxkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRQYXJlbnQgPyBjaGlsZFBhcmVudCA9PT0gcGFyZW50IDogLTEgIT09IGdldFBhcmVudHMoY2hpbGQpLmluZGV4T2YocGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZyYW1lcyh3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGZyYW1lcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW4uZnJhbWVzO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gZnJhbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IGxlbikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMTAwOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBmcmFtZXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZnJhbWUpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRBbGxDaGlsZEZyYW1lcyh3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIF9pdGVyYXRvciA9IGdldEZyYW1lcyh3aW4pLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kyID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gZ2V0QWxsQ2hpbGRGcmFtZXMoZnJhbWUpLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kzKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEZyYW1lID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZEZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VG9wKHdpbikge1xuICAgICAgICAgICAgICAgIGlmICh3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4udG9wKSByZXR1cm4gd2luLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0UGFyZW50KHdpbikgPT09IHdpbikgcmV0dXJuIHdpbjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbmRvdywgd2luKSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luLCB3aW5kb3cpICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gZ2V0QWxsQ2hpbGRGcmFtZXMod2luKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2k0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNCA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pNCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTQgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRvcCkgcmV0dXJuIGZyYW1lLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZXRQYXJlbnQoZnJhbWUpID09PSBmcmFtZSkgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QWxsRnJhbWVzSW5XaW5kb3cod2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IGdldFRvcCh3aW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbGxDaGlsZEZyYW1lcyh0b3ApLmNvbmNhdCh0b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNGcmFtZVdpbmRvd0Nsb3NlZChmcmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGVudFdpbmRvdykgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIGlmICghZnJhbWUucGFyZW50Tm9kZSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBmcmFtZS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiAhKCFkb2MgfHwgIWRvYy5ib2R5IHx8IGRvYy5ib2R5LmNvbnRhaW5zKGZyYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWZyYW1lV2luZG93cyA9IFtdLCBpZnJhbWVGcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzV2luZG93Q2xvc2VkKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd01vY2sgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdKSB8fCBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luLmNsb3NlZCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWVyciB8fCBlcnIubWVzc2FnZSAhPT0gSUVfV0lOX0FDQ0VTU19FUlJPUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93TW9jayAmJiBpc1NhbWVEb21haW4od2luKSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi5tb2NrY2xvc2VkKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luLnBhcmVudCB8fCAhd2luLnRvcCkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWwubm9vcCkod2luID09IHdpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGlmcmFtZUluZGV4ID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH0oaWZyYW1lV2luZG93cywgd2luKTtcbiAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGlmcmFtZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGlmcmFtZUZyYW1lc1tpZnJhbWVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBpc0ZyYW1lV2luZG93Q2xvc2VkKGZyYW1lKSkgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZUJ5TmFtZSh3aW4sIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2luRnJhbWVzID0gZ2V0RnJhbWVzKHdpbiksIF9pdGVyYXRvcjQgPSB3aW5GcmFtZXMsIF9pc0FycmF5NCA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yNCksIF9pNiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID8gX2l0ZXJhdG9yNCA6IF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNiA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k2KytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTYgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pNi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRGcmFtZSA9IF9yZWY0O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbihjaGlsZEZyYW1lKSAmJiBjaGlsZEZyYW1lLm5hbWUgPT09IG5hbWUgJiYgLTEgIT09IHdpbkZyYW1lcy5pbmRleE9mKGNoaWxkRnJhbWUpKSByZXR1cm4gY2hpbGRGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLTEgIT09IHdpbkZyYW1lcy5pbmRleE9mKHdpbi5mcmFtZXNbbmFtZV0pKSByZXR1cm4gd2luLmZyYW1lc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0xICE9PSB3aW5GcmFtZXMuaW5kZXhPZih3aW5bbmFtZV0pKSByZXR1cm4gd2luW25hbWVdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDaGlsZEZyYW1lQnlOYW1lKHdpbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGdldEZyYW1lQnlOYW1lKHdpbiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBnZXRGcmFtZXMod2luKSwgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUgPSBfaXNBcnJheTUgPyBfaXRlcmF0b3I1IDogX2l0ZXJhdG9yNVtTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k3ID49IF9pdGVyYXRvcjUubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2l0ZXJhdG9yNVtfaTcrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNyA9IF9pdGVyYXRvcjUubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY1ID0gX2k3LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lZEZyYW1lID0gZmluZENoaWxkRnJhbWVCeU5hbWUoX3JlZjUsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZWRGcmFtZSkgcmV0dXJuIG5hbWVkRnJhbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QW5jZXN0b3Iod2luKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wZW5lciA9IGdldE9wZW5lcih3aW4gPSB3aW4gfHwgd2luZG93KTtcbiAgICAgICAgICAgICAgICBpZiAob3BlbmVyKSByZXR1cm4gb3BlbmVyO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRQYXJlbnQod2luKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50IHx8IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUG9wdXAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0T3BlbmVyKHdpbmRvdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaXNJZnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZ2V0UGFyZW50KHdpbmRvdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYW55TWF0Y2goY29sbGVjdGlvbjEsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjggPSBjb2xsZWN0aW9uMSwgX2lzQXJyYXk4ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I4KSwgX2kxMCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I4ID0gX2lzQXJyYXk4ID8gX2l0ZXJhdG9yOCA6IF9pdGVyYXRvcjhbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5OCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMTAgPj0gX2l0ZXJhdG9yOC5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaXRlcmF0b3I4W19pMTArK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMTAgPSBfaXRlcmF0b3I4Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmOCA9IF9pMTAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0xID0gX3JlZjgsIF9pdGVyYXRvcjkgPSBjb2xsZWN0aW9uMiwgX2lzQXJyYXk5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I5KSwgX2kxMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOSA9IF9pc0FycmF5OSA/IF9pdGVyYXRvcjkgOiBfaXRlcmF0b3I5W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTExID49IF9pdGVyYXRvcjkubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjlbX2kxMSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTExID0gX2l0ZXJhdG9yOS5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gX2kxMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtMSA9PT0gX3JlZjkpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREaXN0YW5jZUZyb21Ub3AoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZGlzdGFuY2UgPSAwLCBwYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdzsgcGFyZW50OyApIChwYXJlbnQgPSBnZXRQYXJlbnQocGFyZW50KSkgJiYgKGRpc3RhbmNlICs9IDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldE50aFBhcmVudCh3aW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiAxLCBwYXJlbnQgPSB3aW4sIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGdldFBhcmVudChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL2hpLWJhc2UzMi9zcmMvYmFzZTMyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAoZnVuY3Rpb24ocHJvY2VzcywgZ2xvYmFsLCBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18sIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IFwib2JqZWN0XCIgPT09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiB3aW5kb3cgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA/IHdpbmRvdyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAhcm9vdC5ISV9CQVNFMzJfTk9fTk9ERV9KUyAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBwcm9jZXNzID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocHJvY2VzcykpICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICYmIChyb290ID0gZ2xvYmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIENPTU1PTl9KUyA9ICFyb290LkhJX0JBU0UzMl9OT19DT01NT05fSlMgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihtb2R1bGUpICYmIG1vZHVsZS5leHBvcnRzLCBBTUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzXCIpLCBCQVNFMzJfRU5DT0RFX0NIQVIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3XCIuc3BsaXQoXCJcIiksIEJBU0UzMl9ERUNPREVfQ0hBUiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEE6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBCOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgQzogMixcbiAgICAgICAgICAgICAgICAgICAgICAgIEQ6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICBFOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgRjogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEc6IDYsXG4gICAgICAgICAgICAgICAgICAgICAgICBIOiA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgSTogOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEo6IDksXG4gICAgICAgICAgICAgICAgICAgICAgICBLOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEw6IDExLFxuICAgICAgICAgICAgICAgICAgICAgICAgTTogMTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBOOiAxMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIE86IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgUDogMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICBROiAxNixcbiAgICAgICAgICAgICAgICAgICAgICAgIFI6IDE3LFxuICAgICAgICAgICAgICAgICAgICAgICAgUzogMTgsXG4gICAgICAgICAgICAgICAgICAgICAgICBUOiAxOSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFU6IDIwLFxuICAgICAgICAgICAgICAgICAgICAgICAgVjogMjEsXG4gICAgICAgICAgICAgICAgICAgICAgICBXOiAyMixcbiAgICAgICAgICAgICAgICAgICAgICAgIFg6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgWTogMjQsXG4gICAgICAgICAgICAgICAgICAgICAgICBaOiAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDI6IDI2LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzogMjcsXG4gICAgICAgICAgICAgICAgICAgICAgICA0OiAyOCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDU6IDI5LFxuICAgICAgICAgICAgICAgICAgICAgICAgNjogMzAsXG4gICAgICAgICAgICAgICAgICAgICAgICA3OiAzMVxuICAgICAgICAgICAgICAgICAgICB9LCBibG9ja3MgPSBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXSwgdGhyb3dJbnZhbGlkVXRmOCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBwYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLmxlbmd0aCA+IDEwICYmIChwYXJ0aWFsID0gXCIuLi5cIiArIHBhcnRpYWwuc3Vic3RyKC0xMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcIkRlY29kZWQgZGF0YSBpcyBub3QgdmFsaWQgVVRGLTguIE1heWJlIHRyeSBiYXNlMzIuZGVjb2RlLmFzQnl0ZXMoKT8gUGFydGlhbCBkYXRhIGFmdGVyIHJlYWRpbmcgXCIgKyBwb3NpdGlvbiArIFwiIGJ5dGVzOiBcIiArIHBhcnRpYWwgKyBcIiA8LVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9LCBkZWNvZGVBc0J5dGVzID0gZnVuY3Rpb24oYmFzZTMyU3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS9eW0EtWjItNz1dKyQvLnRlc3QoYmFzZTMyU3RyKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlMzIgY2hhcmFjdGVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgYnl0ZXMgPSBbXSwgaW5kZXggPSAwLCBsZW5ndGggPSAoYmFzZTMyU3RyID0gYmFzZTMyU3RyLnJlcGxhY2UoLz0vZywgXCJcIikpLmxlbmd0aCwgaSA9IDAsIGNvdW50ID0gbGVuZ3RoID4+IDMgPDwgMzsgaSA8IGNvdW50OyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY1ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjYgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY4ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2NCA8PCA0IHwgdjUgPj4+IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHY3IDw8IDUgfCB2OCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluID0gbGVuZ3RoIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMiA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDQgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoNSA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYxIDw8IDMgfCB2MiA+Pj4gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjIgPDwgNiB8IHYzIDw8IDEgfCB2NCA+Pj4gNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjQgPDwgNCB8IHY1ID4+PiAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoNyA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY2ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IDI1NSAmICh2MSA8PCAzIHwgdjIgPj4+IDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHYyIDw8IDYgfCB2MyA8PCAxIHwgdjQgPj4+IDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gMjU1ICYgKHY0IDw8IDQgfCB2NSA+Pj4gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAyNTUgJiAodjUgPDwgNyB8IHY2IDw8IDIgfCB2NyA+Pj4gMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIH0sIGRlY29kZSA9IGZ1bmN0aW9uKGJhc2UzMlN0ciwgYXNjaWlPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFzY2lpT25seSkgcmV0dXJuIGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiwgYywgc3RyID0gXCJcIiwgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoLCBpID0gMCwgZm9sbG93aW5nQ2hhcnMgPSAwOyBpIDwgbGVuZ3RoOyApIGlmICgoYiA9IGJ5dGVzW2krK10pIDw9IDEyNykgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYik7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYiA+IDE5MSAmJiBiIDw9IDIyMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDMxICYgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGxvd2luZ0NoYXJzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiIDw9IDIzOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDE1ICYgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbGxvd2luZ0NoYXJzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiIDw9IDI0Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDcgJiBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9sbG93aW5nQ2hhcnMgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZvbGxvd2luZ0NoYXJzOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYiA9IGJ5dGVzW2krK10pIDwgMTI4IHx8IGIgPiAxOTEpICYmIHRocm93SW52YWxpZFV0ZjgoaSwgc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPDw9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjICs9IDYzICYgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID49IDU1Mjk2ICYmIGMgPD0gNTczNDMgJiYgdGhyb3dJbnZhbGlkVXRmOChpLCBzdHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID4gMTExNDExMSAmJiB0aHJvd0ludmFsaWRVdGY4KGksIHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjIDw9IDY1NTM1KSBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIC09IDY1NTM2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgKyAoYyA+PiAxMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTYzMjAgKyAoMTAyMyAmIGMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShkZWNvZGVBc0J5dGVzKGJhc2UzMlN0cikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEvXltBLVoyLTc9XSskLy50ZXN0KGJhc2UzMlN0cikpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTMyIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCBzdHIgPSBcIlwiLCBsZW5ndGggPSBiYXNlMzJTdHIuaW5kZXhPZihcIj1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gbGVuZ3RoICYmIChsZW5ndGggPSBiYXNlMzJTdHIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IGxlbmd0aCA+PiAzIDw8IDM7IGkgPCBjb3VudDsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY2ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2OCA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MSA8PCAzIHwgdjIgPj4+IDIpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHYyIDw8IDYgfCB2MyA8PCAxIHwgdjQgPj4+IDQpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHY0IDw8IDQgfCB2NSA+Pj4gMSkpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjUgPDwgNyB8IHY2IDw8IDIgfCB2NyA+Pj4gMykpICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjcgPDwgNSB8IHY4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluID0gbGVuZ3RoIC0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMiA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MSA8PCAzIHwgdjIgPj4+IDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoNCA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDUgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY0ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2NCA8PCA0IHwgdjUgPj4+IDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoNyA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IEJBU0UzMl9ERUNPREVfQ0hBUltiYXNlMzJTdHIuY2hhckF0KGkrKyldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY2ID0gQkFTRTMyX0RFQ09ERV9DSEFSW2Jhc2UzMlN0ci5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjcgPSBCQVNFMzJfREVDT0RFX0NIQVJbYmFzZTMyU3RyLmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiAodjEgPDwgMyB8IHYyID4+PiAyKSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2MiA8PCA2IHwgdjMgPDwgMSB8IHY0ID4+PiA0KSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSAmICh2NCA8PCA0IHwgdjUgPj4+IDEpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgKHY1IDw8IDcgfCB2NiA8PCAyIHwgdjcgPj4+IDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICAgICAgICAgIH0sIGV4cG9ydHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uKGlucHV0LCBhc2NpaU9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90U3RyaW5nID0gXCJzdHJpbmdcIiAhPSB0eXBlb2YgaW5wdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90U3RyaW5nICYmIGlucHV0LmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlciAmJiAoaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3RTdHJpbmcgPyBmdW5jdGlvbihieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIGJhc2UzMlN0ciA9IFwiXCIsIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aCwgaSA9IDAsIGNvdW50ID0gNSAqIHBhcnNlSW50KGxlbmd0aCAvIDUpOyBpIDwgY291bnQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjIgPDwgNCB8IHYzID4+PiA0KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjMgPDwgMSB8IHY0ID4+PiA3KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjQgPj4+IDIgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjQgPDwgMyB8IHY1ID4+PiA1KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiB2NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPDwgMiAmIDMxXSArIFwiPT09PT09XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMiA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IGJ5dGVzW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPDwgNCAmIDMxXSArIFwiPT09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDMgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YzIDw8IDEgJiAzMV0gKyBcIj09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDQgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBieXRlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBieXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYzIDw8IDEgfCB2NCA+Pj4gNyldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0ID4+PiAyICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0IDw8IDMgJiAzMV0gKyBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTMyU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oaW5wdXQpIDogYXNjaWlPbmx5ID8gZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHYxLCB2MiwgdjMsIHY0LCB2NSwgYmFzZTMyU3RyID0gXCJcIiwgbGVuZ3RoID0gc3RyLmxlbmd0aCwgaSA9IDAsIGNvdW50ID0gNSAqIHBhcnNlSW50KGxlbmd0aCAvIDUpOyBpIDwgY291bnQ7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjIgPDwgNCB8IHYzID4+PiA0KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjMgPDwgMSB8IHY0ID4+PiA3KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjQgPj4+IDIgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjQgPDwgMyB8IHY1ID4+PiA1KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiB2NV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbiA9IGxlbmd0aCAtIGNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPDwgMiAmIDMxXSArIFwiPT09PT09XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMiA9PT0gcmVtYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPDwgNCAmIDMxXSArIFwiPT09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDMgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YzIDw8IDEgJiAzMV0gKyBcIj09PVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDQgPT09IHJlbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UzMlN0ciArPSBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPj4+IDNdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYxIDw8IDIgfCB2MiA+Pj4gNildICsgQkFTRTMyX0VOQ09ERV9DSEFSW3YyID4+PiAxICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYyIDw8IDQgfCB2MyA+Pj4gNCldICsgQkFTRTMyX0VOQ09ERV9DSEFSWzMxICYgKHYzIDw8IDEgfCB2NCA+Pj4gNyldICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0ID4+PiAyICYgMzFdICsgQkFTRTMyX0VOQ09ERV9DSEFSW3Y0IDw8IDMgJiAzMV0gKyBcIj1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTMyU3RyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oaW5wdXQpIDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2MSwgdjIsIHYzLCB2NCwgdjUsIGNvZGUsIGksIGVuZCA9ICExLCBiYXNlMzJTdHIgPSBcIlwiLCBpbmRleCA9IDAsIHN0YXJ0ID0gMCwgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzBdID0gYmxvY2tzWzVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzFdID0gYmxvY2tzWzZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID0gYmxvY2tzWzddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA1OyArK2luZGV4KSBpZiAoKGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCkpIDwgMTI4KSBibG9ja3NbaSsrXSA9IGNvZGU7IGVsc2UgaWYgKGNvZGUgPCAyMDQ4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxOTIgfCBjb2RlID4+IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxMjggfCA2MyAmIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCA1NTI5NiB8fCBjb2RlID49IDU3MzQ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAyMjQgfCBjb2RlID4+IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpKytdID0gMTI4IHwgY29kZSA+PiA2ICYgNjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxMjggfCA2MyAmIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSA2NTUzNiArICgoMTAyMyAmIGNvZGUpIDw8IDEwIHwgMTAyMyAmIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSsrXSA9IDI0MCB8IGNvZGUgPj4gMTg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxMjggfCBjb2RlID4+IDEyICYgNjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2krK10gPSAxMjggfCBjb2RlID4+IDYgJiA2MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSsrXSA9IDEyOCB8IDYzICYgY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSAtIDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9PT0gbGVuZ3RoICYmICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA+IGxlbmd0aCAmJiBpIDwgNiAmJiAoZW5kID0gITApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBibG9ja3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IGJsb2Nrc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NCA9IGJsb2Nrc1szXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2NSA9IGJsb2Nrc1s0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MyA8PCAxIHwgdjQgPj4+IDcpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2NCA+Pj4gMiAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2NCA8PCAzIHwgdjUgPj4+IDUpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmIHY1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoMSA9PT0gaSkgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjEgPDwgMiAmIDMxXSArIFwiPT09PT09XCI7IGVsc2UgaWYgKDIgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA8PCA0ICYgMzFdICsgXCI9PT09XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDMgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGJsb2Nrc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2MyA9IGJsb2Nrc1syXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlMzJTdHIgKz0gQkFTRTMyX0VOQ09ERV9DSEFSW3YxID4+PiAzXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MSA8PCAyIHwgdjIgPj4+IDYpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MiA+Pj4gMSAmIDMxXSArIEJBU0UzMl9FTkNPREVfQ0hBUlszMSAmICh2MiA8PCA0IHwgdjMgPj4+IDQpXSArIEJBU0UzMl9FTkNPREVfQ0hBUlt2MyA8PCAxICYgMzFdICsgXCI9PT1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBibG9ja3NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjMgPSBibG9ja3NbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjQgPSBibG9ja3NbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZTMyU3RyICs9IEJBU0UzMl9FTkNPREVfQ0hBUlt2MSA+Pj4gM10gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjEgPDwgMiB8IHYyID4+PiA2KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjIgPj4+IDEgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjIgPDwgNCB8IHYzID4+PiA0KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbMzEgJiAodjMgPDwgMSB8IHY0ID4+PiA3KV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjQgPj4+IDIgJiAzMV0gKyBCQVNFMzJfRU5DT0RFX0NIQVJbdjQgPDwgMyAmIDMxXSArIFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICghZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UzMlN0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGU6IGRlY29kZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGUuYXNCeXRlcyA9IGRlY29kZUFzQnl0ZXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01NT05fSlMpIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0czsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmJhc2UzMiA9IGV4cG9ydHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBBTUQgJiYgdm9pZCAwICE9PSAoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKSAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICB9KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qc1wiKShtb2R1bGUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvYnJpZGdlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzID0gX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93cyB8fCB7fTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd0lkID0gMDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVR1bm5lbFdpbmRvdyhpZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd3NbaWRdICYmIGRlbGV0ZSBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzW2lkXS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZFR1bm5lbFdpbmRvdyhfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZSwgc291cmNlID0gX3JlZjIuc291cmNlLCBjYW5hcnkgPSBfcmVmMi5jYW5hcnksIHNlbmRNZXNzYWdlID0gX3JlZjIuc2VuZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHVubmVsV2luZG93cyA9IF9nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd3MsIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKHR1bm5lbFdpbmRvd3MpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmLCB0dW5uZWxXaW5kb3cgPSB0dW5uZWxXaW5kb3dzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbGliLm5vb3ApKHR1bm5lbFdpbmRvdy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlVHVubmVsV2luZG93KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkodHVubmVsV2luZG93LnNvdXJjZSkgJiYgZGVsZXRlVHVubmVsV2luZG93KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwudHVubmVsV2luZG93SWQgKz0gMTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzW19nbG9iYWwuZ2xvYmFsLnR1bm5lbFdpbmRvd0lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNhbmFyeTogY2FuYXJ5LFxuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogc2VuZE1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm9wZW5UdW5uZWxUb1BhcmVudCA9IGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLCBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsIGNhbmFyeSA9IF9yZWYzLmNhbmFyeSwgc2VuZE1lc3NhZ2UgPSBfcmVmMy5zZW5kTWVzc2FnZSwgcGFyZW50V2luZG93ID0gKDAsIFxuICAgICAgICAgICAgICAgIF9zcmMuZ2V0UGFyZW50KSh3aW5kb3cpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBwYXJlbnQgd2luZG93IGZvdW5kIHRvIG9wZW4gdHVubmVsIHRvXCIpO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGFkZFR1bm5lbFdpbmRvdyh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBjYW5hcnk6IGNhbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHNlbmRNZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLnNlbmQocGFyZW50V2luZG93LCBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX05BTUVTLk9QRU5fVFVOTkVMLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dW5uZWxXaW5kb3cgPSBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2xvYmFsLmdsb2JhbC50dW5uZWxXaW5kb3dzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0oaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5ub29wKSh0dW5uZWxXaW5kb3cgJiYgdHVubmVsV2luZG93LnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVUdW5uZWxXaW5kb3coaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0dW5uZWxXaW5kb3cgJiYgdHVubmVsV2luZG93LnNvdXJjZSAmJiAhKDAsIF9zcmMuaXNXaW5kb3dDbG9zZWQpKHR1bm5lbFdpbmRvdy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHVubmVsV2luZG93LmNhbmFyeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR1bm5lbFdpbmRvdy5zZW5kTWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvY2hpbGQuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5vcGVuVHVubmVsVG9PcGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlbmVyID0gKDAsIF9zcmMyLmdldE9wZW5lcikod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lciAmJiAoMCwgX2NvbW1vbi5uZWVkc0JyaWRnZSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luOiBvcGVuZXJcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY29tbW9uLnJlZ2lzdGVyUmVtb3RlV2luZG93KShvcGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0UmVtb3RlQnJpZGdlRm9yV2luZG93KG9wZW5lcikudGhlbihmdW5jdGlvbihicmlkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJpZGdlID8gd2luZG93Lm5hbWUgPyBicmlkZ2VbX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdLm9wZW5UdW5uZWxUb1BhcmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHdpbmRvdy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHdpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuYXJ5OiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5ub29wKSh3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiAhd2luZG93LmNsb3NlZCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWNlaXZlTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zcmMuWmFsZ29Qcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjIuc291cmNlLCBvcmlnaW4gPSBfcmVmMi5vcmlnaW4sIGRhdGEgPSBfcmVmMi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBvcGVuZXIpIHRocm93IG5ldyBFcnJvcihcIlNvdXJjZSBkb2VzIG5vdCBtYXRjaCBvcGVuZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY29tbW9uLnJlZ2lzdGVyUmVtb3RlU2VuZE1lc3NhZ2UpKHNvdXJjZSwgb3JpZ2luLCBkYXRhLnNlbmRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9jb21tb24ucmVqZWN0UmVtb3RlU2VuZE1lc3NhZ2UpKG9wZW5lciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogKDAsIF9jb21tb24ucmVqZWN0UmVtb3RlU2VuZE1lc3NhZ2UpKG9wZW5lciwgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWdpc3RlciB3aXRoIG9wZW5lcjogd2luZG93IGRvZXMgbm90IGhhdmUgYSBuYW1lXCIpKSA6ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29tbW9uLnJlamVjdFJlbW90ZVNlbmRNZXNzYWdlKShvcGVuZXIsIG5ldyBFcnJvcihcIkNhbiBub3QgcmVnaXN0ZXIgd2l0aCBvcGVuZXI6IG5vIGJyaWRnZSBmb3VuZCBpbiBvcGVuZXJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpLCBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9jb21tb24uanNcIiksIGF3YWl0UmVtb3RlQnJpZGdlRm9yV2luZG93ID0gKDAsIFxuICAgICAgICAgICAgX2xpYi53ZWFrTWFwTWVtb2l6ZSkoZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9ICgwLCBfc3JjMi5nZXRGcmFtZXMpKHdpbiksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9IF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZnJhbWUgJiYgX2ZyYW1lICE9PSB3aW5kb3cgJiYgKDAsIF9zcmMyLmlzU2FtZURvbWFpbikoX2ZyYW1lKSAmJiBfZnJhbWVbX2NvbmYuQ09OU1RBTlRTLldJTkRPV19QUk9QUy5QT1NUUk9CT1RdKSByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9ICgwLCBfc3JjMi5nZXRGcmFtZUJ5TmFtZSkod2luLCAoMCwgX2NvbW1vbi5nZXRCcmlkZ2VOYW1lKSgoMCwgX3NyYzIuZ2V0RG9tYWluKSgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZyYW1lKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zcmMyLmlzU2FtZURvbWFpbikoZnJhbWUpICYmIGZyYW1lW19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXSA/IGZyYW1lIDogbmV3IF9zcmMuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB2b2lkIDAsIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmICgwLCBfc3JjMi5pc1NhbWVEb21haW4pKGZyYW1lKSAmJiBmcmFtZVtfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMmUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvY29tbW9uLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZG9jdW1lbnRCb2R5UmVhZHkgPSB2b2lkIDA7XG4gICAgICAgICAgICBleHBvcnRzLm5lZWRzQnJpZGdlRm9yQnJvd3NlciA9IG5lZWRzQnJpZGdlRm9yQnJvd3NlcjtcbiAgICAgICAgICAgIGV4cG9ydHMubmVlZHNCcmlkZ2VGb3JXaW4gPSBuZWVkc0JyaWRnZUZvcldpbjtcbiAgICAgICAgICAgIGV4cG9ydHMubmVlZHNCcmlkZ2VGb3JEb21haW4gPSBuZWVkc0JyaWRnZUZvckRvbWFpbjtcbiAgICAgICAgICAgIGV4cG9ydHMubmVlZHNCcmlkZ2UgPSBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQnJpZGdlRm9yQnJvd3NlcigpKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJiAhbmVlZHNCcmlkZ2VGb3JEb21haW4oZG9tYWluLCB3aW4pKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgaWYgKHdpbiAmJiAhbmVlZHNCcmlkZ2VGb3JXaW4od2luKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEJyaWRnZU5hbWUgPSBnZXRCcmlkZ2VOYW1lO1xuICAgICAgICAgICAgZXhwb3J0cy5pc0JyaWRnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHdpbmRvdy5uYW1lICYmIHdpbmRvdy5uYW1lID09PSBnZXRCcmlkZ2VOYW1lKCgwLCBfc3JjMy5nZXREb21haW4pKCkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2lzdGVyUmVtb3RlV2luZG93ID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVtb3RlV2luZG93cy5zZXQod2luLCB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlUHJvbWlzZTogbmV3IF9zcmMyLlphbGdvUHJvbWlzZSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5maW5kUmVtb3RlV2luZG93ID0gZmluZFJlbW90ZVdpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMucmVnaXN0ZXJSZW1vdGVTZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgZG9tYWluLCBzZW5kTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVXaW5kb3cgPSBmaW5kUmVtb3RlV2luZG93KHdpbik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdGVXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgZm91bmQgdG8gcmVnaXN0ZXIgc2VuZE1lc3NhZ2UgdG9cIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlbmRNZXNzYWdlV3JhcHBlciA9IGZ1bmN0aW9uKHJlbW90ZVdpbiwgbWVzc2FnZSwgcmVtb3RlRG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdGVXaW4gIT09IHdpbikgdGhyb3cgbmV3IEVycm9yKFwiUmVtb3RlIHdpbmRvdyBkb2VzIG5vdCBtYXRjaCB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMzLm1hdGNoRG9tYWluKShyZW1vdGVEb21haW4sIGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSBkb21haW4gXCIgKyByZW1vdGVEb21haW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlbW90ZVdpbmRvdy5zZW5kTWVzc2FnZVByb21pc2UucmVzb2x2ZShzZW5kTWVzc2FnZVdyYXBwZXIpO1xuICAgICAgICAgICAgICAgIHJlbW90ZVdpbmRvdy5zZW5kTWVzc2FnZVByb21pc2UgPSBfc3JjMi5aYWxnb1Byb21pc2UucmVzb2x2ZShzZW5kTWVzc2FnZVdyYXBwZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMucmVqZWN0UmVtb3RlU2VuZE1lc3NhZ2UgPSBmdW5jdGlvbih3aW4sIGVycikge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVXaW5kb3cgPSBmaW5kUmVtb3RlV2luZG93KHdpbik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdGVXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgZm91bmQgb24gd2hpY2ggdG8gcmVqZWN0IHNlbmRNZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIHJlbW90ZVdpbmRvdy5zZW5kTWVzc2FnZVByb21pc2UuYXN5bmNSZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNlbmRCcmlkZ2VNZXNzYWdlID0gZnVuY3Rpb24od2luLCBtZXNzYWdlLCBkb21haW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnaW5nQ2hpbGQgPSAoMCwgX3NyYzMuaXNPcGVuZXIpKHdpbmRvdywgd2luKSwgbWVzc2FnaW5nUGFyZW50ID0gKDAsIF9zcmMzLmlzT3BlbmVyKSh3aW4sIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdpbmdDaGlsZCAmJiAhbWVzc2FnaW5nUGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBzZW5kIG1lc3NhZ2VzIHRvIGFuZCBmcm9tIHBhcmVudCBhbmQgcG9wdXAgd2luZG93c1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3RlV2luZG93ID0gZmluZFJlbW90ZVdpbmRvdyh3aW4pO1xuICAgICAgICAgICAgICAgIGlmICghcmVtb3RlV2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgbm90IGZvdW5kIHRvIHNlbmQgbWVzc2FnZSB0b1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3RlV2luZG93LnNlbmRNZXNzYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNlbmRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZW5kTWVzc2FnZSh3aW4sIG1lc3NhZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5lZWRzQnJpZGdlRm9yQnJvd3NlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISEoMCwgX3NyYzMuZ2V0VXNlckFnZW50KSh3aW5kb3cpLm1hdGNoKC9NU0lFfHRyaWRlbnR8ZWRnZVxcLzEyfGVkZ2VcXC8xMy9pKSB8fCAhX2NvbmYuQ09ORklHLkFMTE9XX1BPU1RNRVNTQUdFX1BPUFVQO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbmVlZHNCcmlkZ2VGb3JXaW4od2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoMCwgX3NyYzMuaXNTYW1lVG9wV2luZG93KSh3aW5kb3csIHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBuZWVkc0JyaWRnZUZvckRvbWFpbihkb21haW4sIHdpbikge1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMy5nZXREb21haW4pKCkgIT09ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKShkb21haW4pKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW4gJiYgISgwLCBfc3JjMy5pc1NhbWVEb21haW4pKHdpbikpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRCcmlkZ2VOYW1lKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIHZhciBzYW5pdGl6ZWREb21haW4gPSAoZG9tYWluID0gZG9tYWluIHx8ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKShkb21haW4pKS5yZXBsYWNlKC9bXmEtekEtWjAtOV0rL2csIFwiX1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmYuQ09OU1RBTlRTLkJSSURHRV9OQU1FX1BSRUZJWCArIFwiX1wiICsgc2FuaXRpemVkRG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy5kb2N1bWVudEJvZHlSZWFkeSA9IG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHJldHVybiByZXNvbHZlKHdpbmRvdy5kb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlbW90ZVdpbmRvd3MgPSBfZ2xvYmFsLmdsb2JhbC5yZW1vdGVXaW5kb3dzIHx8IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRSZW1vdGVXaW5kb3cod2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLnJlbW90ZVdpbmRvd3MuZ2V0KHdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfY2hpbGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2NoaWxkLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NoaWxkKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jaGlsZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfY29tbW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9jb21tb24uanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfY29tbW9uKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb21tb25ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3BhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvcGFyZW50LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3BhcmVudCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcGFyZW50W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9icmlkZ2UuanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL2ludGVyZmFjZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm9wZW5CcmlkZ2VcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgub3BlbkJyaWRnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxpbmtVcmxcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgubGlua1VybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzQnJpZGdlXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4LmlzQnJpZGdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmVlZHNCcmlkZ2VcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgubmVlZHNCcmlkZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuZWVkc0JyaWRnZUZvckJyb3dzZXJcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgubmVlZHNCcmlkZ2VGb3JCcm93c2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGFzQnJpZGdlXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lmhhc0JyaWRnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5lZWRzQnJpZGdlRm9yV2luXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2luZGV4Lm5lZWRzQnJpZGdlRm9yV2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmVlZHNCcmlkZ2VGb3JEb21haW5cIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgubmVlZHNCcmlkZ2VGb3JEb21haW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJvcGVuVHVubmVsVG9PcGVuZXJcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXgub3BlblR1bm5lbFRvT3BlbmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVzdHJveUJyaWRnZXNcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW5kZXguZGVzdHJveUJyaWRnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvYnJpZGdlL3BhcmVudC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmhhc0JyaWRnZSA9IGZ1bmN0aW9uKHVybCwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluID0gZG9tYWluIHx8ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKSh1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXNbZG9tYWluXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5vcGVuQnJpZGdlID0gZnVuY3Rpb24odXJsLCBkb21haW4pIHtcbiAgICAgICAgICAgICAgICBkb21haW4gPSBkb21haW4gfHwgKDAsIF9zcmMzLmdldERvbWFpbkZyb21VcmwpKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXNbZG9tYWluXSkgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXNbZG9tYWluXTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VzW2RvbWFpbl0gPSBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMzLmdldERvbWFpbikoKSA9PT0gZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IG9wZW4gYnJpZGdlIG9uIHRoZSBzYW1lIGRvbWFpbiBhcyBjdXJyZW50IGRvbWFpbjogXCIgKyBkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9ICgwLCBfY29tbW9uLmdldEJyaWRnZU5hbWUpKGRvbWFpbiksIGZyYW1lID0gKDAsIF9zcmMzLmdldEZyYW1lQnlOYW1lKSh3aW5kb3csIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHRocm93IG5ldyBFcnJvcihcIkZyYW1lIHdpdGggbmFtZSBcIiArIG5hbWUgKyBcIiBhbHJlYWR5IGV4aXN0cyBvbiBwYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWZyYW1lID0gZnVuY3Rpb24obmFtZSwgdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbGliLmxvZy5kZWJ1ZyhcIk9wZW5pbmcgYnJpZGdlOlwiLCBuYW1lLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImRpc3BsYXk6IG5vbmU7IG1hcmdpbjogMDsgcGFkZGluZzogMDsgYm9yZGVyOiAwcHggbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiZnJhbWVib3JkZXJcIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcImJvcmRlclwiLCBcIjBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwic2Nyb2xsaW5nXCIsIFwibm9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiYWxsb3dUcmFuc3BhcmVuY3lcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIH0obmFtZSwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuYnJpZGdlRnJhbWVzW2RvbWFpbl0gPSBpZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29tbW9uLmRvY3VtZW50Qm9keVJlYWR5LnRoZW4oZnVuY3Rpb24oYm9keSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJyaWRnZSA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKHNvdXJjZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwub24oX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9OQU1FUy5PUEVOX1RVTk5FTCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmLm9yaWdpbiwgZGF0YSA9IF9yZWYuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbiAhPT0gZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJEb21haW4gXCIgKyBkb21haW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBvcmlnaW4gXCIgKyBvcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEubmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiUmVnaXN0ZXIgd2luZG93IGV4cGVjdGVkIHRvIGJlIHBhc3NlZCB3aW5kb3cgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnNlbmRNZXNzYWdlKSB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpc3RlciB3aW5kb3cgZXhwZWN0ZWQgdG8gYmUgcGFzc2VkIHNlbmRNZXNzYWdlIG1ldGhvZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IHdpdGggbmFtZSBcIiArIGRhdGEubmFtZSArIFwiIGRvZXMgbm90IGV4aXN0LCBvciB3YXMgbm90IG9wZW5lZCBieSB0aGlzIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXS5kb21haW4pIHRocm93IG5ldyBFcnJvcihcIldlIGRvIG5vdCBoYXZlIGEgcmVnaXN0ZXJlZCBkb21haW4gZm9yIHdpbmRvdyBcIiArIGRhdGEubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbZGF0YS5uYW1lXS5kb21haW4gIT09IG9yaWdpbikgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaGVkIHJlZ2lzdGVyZWQgd2luZG93IG9yaWdpbiBcIiArIF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZVtkYXRhLm5hbWVdLmRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfY29tbW9uLnJlZ2lzdGVyUmVtb3RlU2VuZE1lc3NhZ2UpKF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZVtkYXRhLm5hbWVdLndpbiwgZG9tYWluLCBkYXRhLnNlbmRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiAhd2luZG93LmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2luRGV0YWlscyA9IF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZVtkYXRhLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luRGV0YWlscykgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlY2VpdmVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogd2luRGV0YWlscy5kb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB3aW5EZXRhaWxzLndpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NyYzIuWmFsZ29Qcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShicmlkZ2UsIGRvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLm9uQ2hpbGRXaW5kb3dSZWFkeSkoYnJpZGdlLCBfY29uZi5DT05GSUcuQlJJREdFX1RJTUVPVVQsIFwiQnJpZGdlIFwiICsgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJyaWRnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dsb2JhbC5nbG9iYWwuYnJpZGdlc1tkb21haW5dO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubGlua1VybCA9IGZ1bmN0aW9uKHdpbiwgdXJsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbk9wdGlvbnMgPSBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbi5nZXQod2luKTtcbiAgICAgICAgICAgICAgICBpZiAod2luT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB3aW5PcHRpb25zLmRvbWFpbiA9ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKSh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2NvbW1vbi5yZWdpc3RlclJlbW90ZVdpbmRvdykod2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5kZXN0cm95QnJpZGdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhfZ2xvYmFsLmdsb2JhbC5icmlkZ2VGcmFtZXMpLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwLCBfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gX3JlZjMsIGZyYW1lID0gX2dsb2JhbC5nbG9iYWwuYnJpZGdlRnJhbWVzW2RvbWFpbl07XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnBhcmVudE5vZGUgJiYgZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZUZyYW1lcyA9IHt9O1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXMgPSB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2luZGV4LmpzXCIpLCBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKSwgX2NvbW1vbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvY29tbW9uLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuYnJpZGdlcyA9IF9nbG9iYWwuZ2xvYmFsLmJyaWRnZXMgfHwge307XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VGcmFtZXMgPSBfZ2xvYmFsLmdsb2JhbC5icmlkZ2VGcmFtZXMgfHwge307XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbiA9IF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5V2luIHx8IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZSA9IF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5TmFtZSB8fCB7fTtcbiAgICAgICAgICAgIHZhciB3aW5kb3dPcGVuID0gd2luZG93Lm9wZW47XG4gICAgICAgICAgICB3aW5kb3cub3BlbiA9IGZ1bmN0aW9uKHVybCwgbmFtZSwgb3B0aW9ucywgbGFzdCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSB1cmw7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiAwID09PSB1cmwuaW5kZXhPZihfY29uZi5DT05TVEFOVFMuTU9DS19QUk9UT0NPTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF91cmwkc3BsaXQgPSB1cmwuc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSBfdXJsJHNwbGl0WzBdO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfdXJsJHNwbGl0WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb21haW4gJiYgKGRvbWFpbiA9ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKShkb21haW4pKTtcbiAgICAgICAgICAgICAgICB2YXIgd2luID0gd2luZG93T3Blbi5jYWxsKHRoaXMsIHVybCwgbmFtZSwgb3B0aW9ucywgbGFzdCk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiB3aW47XG4gICAgICAgICAgICAgICAgdXJsICYmICgwLCBfY29tbW9uLnJlZ2lzdGVyUmVtb3RlV2luZG93KSh3aW4pO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWUpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbk5hbWUgPSBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMzLmlzV2luZG93Q2xvc2VkKShfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbd2luTmFtZV0ud2luKSAmJiBkZWxldGUgX2dsb2JhbC5nbG9iYWwucG9wdXBXaW5kb3dzQnlOYW1lW3dpbk5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiB3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbk9wdGlvbnMgPSBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbi5nZXQod2luKSB8fCBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbbmFtZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIHdpbk9wdGlvbnMubmFtZSA9IHdpbk9wdGlvbnMubmFtZSB8fCBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB3aW5PcHRpb25zLndpbiA9IHdpbk9wdGlvbnMud2luIHx8IHdpbjtcbiAgICAgICAgICAgICAgICAgICAgd2luT3B0aW9ucy5kb21haW4gPSB3aW5PcHRpb25zLmRvbWFpbiB8fCBkb21haW47XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnBvcHVwV2luZG93c0J5V2luLnNldCh3aW4sIHdpbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeU5hbWVbbmFtZV0gPSB3aW5PcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2luO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jbGVhbi5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmNsZWFuVXBXaW5kb3cgPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdFByb21pc2VzID0gX2dsb2JhbC5nbG9iYWwucmVxdWVzdFByb21pc2VzLmdldCh3aW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0UHJvbWlzZXMpIGZvciAodmFyIF9pdGVyYXRvciA9IHJlcXVlc3RQcm9taXNlcywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSBmcm9tIHdpbmRvdyAtIGNsZWFuZWQgdXBcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbiAmJiBfZ2xvYmFsLmdsb2JhbC5wb3B1cFdpbmRvd3NCeVdpbi5kZWxldGUod2luKTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZW1vdGVXaW5kb3dzICYmIF9nbG9iYWwuZ2xvYmFsLnJlbW90ZVdpbmRvd3MuZGVsZXRlKHdpbik7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVxdWVzdFByb21pc2VzLmRlbGV0ZSh3aW4pO1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm1ldGhvZHMuZGVsZXRlKHdpbik7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVhZHlQcm9taXNlcy5kZWxldGUod2luKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIHZhciBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb21wYXQvaWUuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5lbXVsYXRlSUVSZXN0cmljdGlvbnMgPSBmdW5jdGlvbihzb3VyY2VXaW5kb3csIHRhcmdldFdpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmICghX2NvbmYuQ09ORklHLkFMTE9XX1BPU1RNRVNTQUdFX1BPUFVQICYmICExID09PSAoMCwgX3NyYy5pc1NhbWVUb3BXaW5kb3cpKHNvdXJjZVdpbmRvdywgdGFyZ2V0V2luZG93KSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZW5kIGFuZCByZWNlaXZlIHBvc3QgbWVzc2FnZXMgYmV0d2VlbiB0d28gZGlmZmVyZW50IHdpbmRvd3MgKGRpc2FibGVkIHRvIGVtdWxhdGUgSUUpXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29tcGF0L2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfaWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29tcGF0L2llLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2llKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2NvbmZpZy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLkNPTkZJRyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfQUxMT1dFRF9QT1NUX01FU1NBR0UsIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9jb25zdGFudHMuanNcIiksIENPTkZJRyA9IGV4cG9ydHMuQ09ORklHID0ge1xuICAgICAgICAgICAgICAgIEFMTE9XX1BPU1RNRVNTQUdFX1BPUFVQOiAhKFwiX19BTExPV19QT1NUTUVTU0FHRV9QT1BVUF9fXCIgaW4gd2luZG93KSB8fCB3aW5kb3cuX19BTExPV19QT1NUTUVTU0FHRV9QT1BVUF9fLFxuICAgICAgICAgICAgICAgIExPR19MRVZFTDogXCJpbmZvXCIsXG4gICAgICAgICAgICAgICAgQlJJREdFX1RJTUVPVVQ6IDVlMyxcbiAgICAgICAgICAgICAgICBDSElMRF9XSU5ET1dfVElNRU9VVDogNWUzLFxuICAgICAgICAgICAgICAgIEFDS19USU1FT1VUOiAtMSAhPT0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL01TSUUvaSkgPyAyZTMgOiAxZTMsXG4gICAgICAgICAgICAgICAgUkVTX1RJTUVPVVQ6IC0xLFxuICAgICAgICAgICAgICAgIExPR19UT19QQUdFOiAhMSxcbiAgICAgICAgICAgICAgICBBTExPV0VEX1BPU1RfTUVTU0FHRV9NRVRIT0RTOiAoX0FMTE9XRURfUE9TVF9NRVNTQUdFID0ge30sIF9BTExPV0VEX1BPU1RfTUVTU0FHRVtfY29uc3RhbnRzLkNPTlNUQU5UUy5TRU5EX1NUUkFURUdJRVMuUE9TVF9NRVNTQUdFXSA9ICEwLCBcbiAgICAgICAgICAgICAgICBfQUxMT1dFRF9QT1NUX01FU1NBR0VbX2NvbnN0YW50cy5DT05TVEFOVFMuU0VORF9TVFJBVEVHSUVTLkJSSURHRV0gPSAhMCwgX0FMTE9XRURfUE9TVF9NRVNTQUdFW19jb25zdGFudHMuQ09OU1RBTlRTLlNFTkRfU1RSQVRFR0lFUy5HTE9CQUxdID0gITAsIFxuICAgICAgICAgICAgICAgIF9BTExPV0VEX1BPU1RfTUVTU0FHRSksXG4gICAgICAgICAgICAgICAgQUxMT1dfU0FNRV9PUklHSU46ICExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgMCA9PT0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZihfY29uc3RhbnRzLkNPTlNUQU5UUy5GSUxFX1BST1RPQ09MKSAmJiAoQ09ORklHLkFMTE9XX1BPU1RNRVNTQUdFX1BPUFVQID0gITApO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvY29uc3RhbnRzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuQ09OU1RBTlRTID0ge1xuICAgICAgICAgICAgICAgIFBPU1RfTUVTU0FHRV9UWVBFOiB7XG4gICAgICAgICAgICAgICAgICAgIFJFUVVFU1Q6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICBSRVNQT05TRTogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBBQ0s6IFwicG9zdHJvYm90X21lc3NhZ2VfYWNrXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBPU1RfTUVTU0FHRV9BQ0s6IHtcbiAgICAgICAgICAgICAgICAgICAgU1VDQ0VTUzogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIEVSUk9SOiBcImVycm9yXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBPU1RfTUVTU0FHRV9OQU1FUzoge1xuICAgICAgICAgICAgICAgICAgICBNRVRIT0Q6IFwicG9zdHJvYm90X21ldGhvZFwiLFxuICAgICAgICAgICAgICAgICAgICBIRUxMTzogXCJwb3N0cm9ib3RfcmVhZHlcIixcbiAgICAgICAgICAgICAgICAgICAgT1BFTl9UVU5ORUw6IFwicG9zdHJvYm90X29wZW5fdHVubmVsXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFdJTkRPV19UWVBFUzoge1xuICAgICAgICAgICAgICAgICAgICBGVUxMUEFHRTogXCJmdWxscGFnZVwiLFxuICAgICAgICAgICAgICAgICAgICBQT1BVUDogXCJwb3B1cFwiLFxuICAgICAgICAgICAgICAgICAgICBJRlJBTUU6IFwiaWZyYW1lXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFdJTkRPV19QUk9QUzoge1xuICAgICAgICAgICAgICAgICAgICBQT1NUUk9CT1Q6IFwiX19wb3N0Um9ib3RfX1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBTRVJJQUxJWkFUSU9OX1RZUEVTOiB7XG4gICAgICAgICAgICAgICAgICAgIE1FVEhPRDogXCJwb3N0cm9ib3RfbWV0aG9kXCIsXG4gICAgICAgICAgICAgICAgICAgIEVSUk9SOiBcInBvc3Ryb2JvdF9lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICBQUk9NSVNFOiBcInBvc3Ryb2JvdF9wcm9taXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIFpBTEdPX1BST01JU0U6IFwicG9zdHJvYm90X3phbGdvX3Byb21pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgUkVHRVg6IFwicmVnZXhcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgU0VORF9TVFJBVEVHSUVTOiB7XG4gICAgICAgICAgICAgICAgICAgIFBPU1RfTUVTU0FHRTogXCJwb3N0cm9ib3RfcG9zdF9tZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIEJSSURHRTogXCJwb3N0cm9ib3RfYnJpZGdlXCIsXG4gICAgICAgICAgICAgICAgICAgIEdMT0JBTDogXCJwb3N0cm9ib3RfZ2xvYmFsXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIE1PQ0tfUFJPVE9DT0w6IFwibW9jazpcIixcbiAgICAgICAgICAgICAgICBGSUxFX1BST1RPQ09MOiBcImZpbGU6XCIsXG4gICAgICAgICAgICAgICAgQlJJREdFX05BTUVfUFJFRklYOiBcIl9fcG9zdHJvYm90X2JyaWRnZV9fXCIsXG4gICAgICAgICAgICAgICAgUE9TVFJPQk9UX1BST1hZOiBcIl9fcG9zdHJvYm90X3Byb3h5X19cIixcbiAgICAgICAgICAgICAgICBXSUxEQ0FSRDogXCIqXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgUE9TVF9NRVNTQUdFX05BTUVTID0gZXhwb3J0cy5QT1NUX01FU1NBR0VfTkFNRVMgPSB7XG4gICAgICAgICAgICAgICAgTUVUSE9EOiBcInBvc3Ryb2JvdF9tZXRob2RcIixcbiAgICAgICAgICAgICAgICBIRUxMTzogXCJwb3N0cm9ib3RfaGVsbG9cIixcbiAgICAgICAgICAgICAgICBPUEVOX1RVTk5FTDogXCJwb3N0cm9ib3Rfb3Blbl90dW5uZWxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuUE9TVF9NRVNTQUdFX05BTUVTX0xJU1QgPSBPYmplY3Qua2V5cyhQT1NUX01FU1NBR0VfTkFNRVMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUE9TVF9NRVNTQUdFX05BTUVTW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfY29uZmlnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvY29uZmlnLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbmZpZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9jb25zdGFudHMuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfY29uc3RhbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb25zdGFudHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3JlY2VpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9yZWNlaXZlL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3JlY2VpdmUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlY2VpdmVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3NlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9zZW5kL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3NlbmQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NlbmRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2xpc3RlbmVycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL2xpc3RlbmVycy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9saXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2xpc3RlbmVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL2xpc3RlbmVycy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnJlc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVzcG9uc2VMaXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0TGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5hZGRSZXNwb25zZUxpc3RlbmVyID0gZnVuY3Rpb24oaGFzaCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZXNwb25zZUxpc3RlbmVyc1toYXNoXSA9IGxpc3RlbmVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UmVzcG9uc2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2dsb2JhbC5nbG9iYWwucmVzcG9uc2VMaXN0ZW5lcnNbaGFzaF07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5kZWxldGVSZXNwb25zZUxpc3RlbmVyID0gZnVuY3Rpb24oaGFzaCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfZ2xvYmFsLmdsb2JhbC5yZXNwb25zZUxpc3RlbmVyc1toYXNoXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm1hcmtSZXNwb25zZUxpc3RlbmVyRXJyb3JlZCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5lcnJvcmVkUmVzcG9uc2VMaXN0ZW5lcnNbaGFzaF0gPSAhMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oX2dsb2JhbC5nbG9iYWwuZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzW2hhc2hdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFJlcXVlc3RMaXN0ZW5lciA9IGdldFJlcXVlc3RMaXN0ZW5lcjtcbiAgICAgICAgICAgIGV4cG9ydHMuYWRkUmVxdWVzdExpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVxdWVzdExpc3RlbmVyKF9yZWY1LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjUubmFtZSwgd2luID0gX3JlZjUud2luLCBkb21haW4gPSBfcmVmNS5kb21haW47XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gYWRkIHJlcXVlc3QgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsaXN0ZW5lcnNDb2xsZWN0aW9uID0gW10sIF9pdGVyYXRvcjIgPSB3aW4sIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMyA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNiA9IF9pdGVyYXRvcjJbX2kzKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNiA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3JlZjY7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gbGlzdGVuZXJzQ29sbGVjdGlvbiwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2k0ID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjcgPSBfaXRlcmF0b3IzW19pNCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k0ID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjcgPSBfaTQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbExpc3RlbmVyID0gX3JlZjc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbExpc3RlbmVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdLCBfaXRlcmF0b3I0ID0gZG9tYWluLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjQpLCBfaTUgPSAwLCBfaXRlcmF0b3I0ID0gX2lzQXJyYXk0ID8gX2l0ZXJhdG9yNCA6IF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNSA+PSBfaXRlcmF0b3I0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaXRlcmF0b3I0W19pNSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTUgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaTUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZW0gPSBfcmVmODtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saXN0ZW5lcnNDb2xsZWN0aW9uLnB1c2goYWRkUmVxdWVzdExpc3RlbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX2l0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxpc3RlbmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IF9saXN0ZW5lcnNDb2xsZWN0aW9uLCBfaXNBcnJheTUgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjUpLCBfaTYgPSAwLCBfaXRlcmF0b3I1ID0gX2lzQXJyYXk1ID8gX2l0ZXJhdG9yNSA6IF9pdGVyYXRvcjVbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNiA+PSBfaXRlcmF0b3I1Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjVbX2k2KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTYgPSBfaXRlcmF0b3I1Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pNi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsTGlzdGVuZXIgPSBfcmVmOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsTGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdMaXN0ZW5lciA9IGdldFJlcXVlc3RMaXN0ZW5lcih7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbiAmJiB3aW4gIT09IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCB8fCAod2luID0gX2dsb2JhbC5nbG9iYWwuV0lORE9XX1dJTERDQVJEKTtcbiAgICAgICAgICAgICAgICBkb21haW4gPSBkb21haW4gfHwgX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0xpc3RlbmVyKSB0aHJvdyB3aW4gJiYgZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkgKyBcIiBmb3IgXCIgKyAod2luID09PSBfZ2xvYmFsLmdsb2JhbC5XSU5ET1dfV0lMRENBUkQgPyBcIndpbGRjYXJkXCIgOiBcInNwZWNpZmllZFwiKSArIFwiIHdpbmRvd1wiKSA6IHdpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIGZvciBcIiArICh3aW4gPT09IF9nbG9iYWwuZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA/IFwid2lsZGNhcmRcIiA6IFwic3BlY2lmaWVkXCIpICsgXCIgd2luZG93XCIpIDogZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkpIDogbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVycyA9IF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RMaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVMaXN0ZW5lcnMgPSByZXF1ZXN0TGlzdGVuZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBuYW1lTGlzdGVuZXJzID0gbmV3IF9zcmMuV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXJzW25hbWVdID0gbmFtZUxpc3RlbmVycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHdpbkxpc3RlbmVycyA9IG5hbWVMaXN0ZW5lcnMuZ2V0KHdpbik7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5MaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luTGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICAgICAgICAgIG5hbWVMaXN0ZW5lcnMuc2V0KHdpbiwgd2luTGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0ckRvbWFpbiA9IGRvbWFpbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhciByZWdleExpc3RlbmVycyA9IHdpbkxpc3RlbmVyc1tfX0RPTUFJTl9SRUdFWF9fXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhMaXN0ZW5lciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9saWIuaXNSZWdleCkoZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleExpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luTGlzdGVuZXJzW19fRE9NQUlOX1JFR0VYX19dID0gcmVnZXhMaXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXhMaXN0ZW5lcnMucHVzaChyZWdleExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugd2luTGlzdGVuZXJzW3N0ckRvbWFpbl0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbkxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5MaXN0ZW5lcnNbc3RyRG9tYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4gJiYgMCA9PT0gT2JqZWN0LmtleXMod2luTGlzdGVuZXJzKS5sZW5ndGggJiYgbmFtZUxpc3RlbmVycy5kZWxldGUod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleExpc3RlbmVyICYmIHJlZ2V4TGlzdGVuZXJzLnNwbGljZShyZWdleExpc3RlbmVycy5pbmRleE9mKHJlZ2V4TGlzdGVuZXIsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlc3BvbnNlTGlzdGVuZXJzID0gX2dsb2JhbC5nbG9iYWwucmVzcG9uc2VMaXN0ZW5lcnMgfHwge307XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0TGlzdGVuZXJzID0gX2dsb2JhbC5nbG9iYWwucmVxdWVzdExpc3RlbmVycyB8fCB7fTtcbiAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCA9IF9nbG9iYWwuZ2xvYmFsLldJTkRPV19XSUxEQ0FSRCB8fCBuZXcgZnVuY3Rpb24oKSB7fSgpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzID0gX2dsb2JhbC5nbG9iYWwuZXJyb3JlZFJlc3BvbnNlTGlzdGVuZXJzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIF9fRE9NQUlOX1JFR0VYX18gPSBcIl9fZG9tYWluX3JlZ2V4X19cIjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RMaXN0ZW5lcihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsIHdpbiA9IF9yZWYud2luLCBkb21haW4gPSBfcmVmLmRvbWFpbjtcbiAgICAgICAgICAgICAgICB3aW4gPT09IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCAmJiAod2luID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgZG9tYWluID09PSBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQgJiYgKGRvbWFpbiA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBnZXQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZUxpc3RlbmVycyA9IF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVMaXN0ZW5lcnMpIGZvciAodmFyIF9hcnIgPSBbIHdpbiwgX2dsb2JhbC5nbG9iYWwuV0lORE9XX1dJTERDQVJEIF0sIF9pID0gMDsgX2kgPCBfYXJyLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2luUXVhbGlmaWVyID0gX2FycltfaV0sIHdpbkxpc3RlbmVycyA9IHdpblF1YWxpZmllciAmJiBuYW1lTGlzdGVuZXJzLmdldCh3aW5RdWFsaWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5MaXN0ZW5lcnNbZG9tYWluXSkgcmV0dXJuIHdpbkxpc3RlbmVyc1tkb21haW5dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5MaXN0ZW5lcnNbX19ET01BSU5fUkVHRVhfX10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IHdpbkxpc3RlbmVyc1tfX0RPTUFJTl9SRUdFWF9fXSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNCA9IF9yZWYzLCByZWdleCA9IF9yZWY0LnJlZ2V4LCBsaXN0ZW5lciA9IF9yZWY0Lmxpc3RlbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMi5tYXRjaERvbWFpbikocmVnZXgsIGRvbWFpbikpIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5MaXN0ZW5lcnNbX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEXSkgcmV0dXJuIHdpbkxpc3RlbmVyc1tfY29uZi5DT05TVEFOVFMuV0lMRENBUkRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvcmVjZWl2ZS9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5yZWNlaXZlTWVzc2FnZSA9IHJlY2VpdmVNZXNzYWdlO1xuICAgICAgICAgICAgZXhwb3J0cy5tZXNzYWdlTGlzdGVuZXIgPSBtZXNzYWdlTGlzdGVuZXI7XG4gICAgICAgICAgICBleHBvcnRzLmxpc3RlbkZvck1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9saWIuYWRkRXZlbnRMaXN0ZW5lcikod2luZG93LCBcIm1lc3NhZ2VcIiwgbWVzc2FnZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIiksIF90eXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3JlY2VpdmUvdHlwZXMuanNcIik7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWNlaXZlZE1lc3NhZ2VzID0gX2dsb2JhbC5nbG9iYWwucmVjZWl2ZWRNZXNzYWdlcyB8fCBbXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cgfHwgd2luZG93LmNsb3NlZCkgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSByZWNpZXZlZCBpbiBjbG9zZWQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuc291cmNlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSwgb3JpZ2luID0gZXZlbnQub3JpZ2luLCBtZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkTWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZE1lc3NhZ2UgPSAoMCwgX2xpYi5qc29uUGFyc2UpKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkTWVzc2FnZSAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBwYXJzZWRNZXNzYWdlID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocGFyc2VkTWVzc2FnZSkpICYmIG51bGwgIT09IHBhcnNlZE1lc3NhZ2UgJiYgKHBhcnNlZE1lc3NhZ2UgPSBwYXJzZWRNZXNzYWdlW19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXSkgJiYgXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gcGFyc2VkTWVzc2FnZSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHBhcnNlZE1lc3NhZ2UpKSAmJiBudWxsICE9PSBwYXJzZWRNZXNzYWdlICYmIHBhcnNlZE1lc3NhZ2UudHlwZSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBwYXJzZWRNZXNzYWdlLnR5cGUgJiYgX3R5cGVzLlJFQ0VJVkVfTUVTU0FHRV9UWVBFU1twYXJzZWRNZXNzYWdlLnR5cGVdKSByZXR1cm4gcGFyc2VkTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5zb3VyY2VEb21haW4gfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgbWVzc2FnZS5zb3VyY2VEb21haW4pIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1lc3NhZ2UgdG8gaGF2ZSBzb3VyY2VEb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgIDAgIT09IG1lc3NhZ2Uuc291cmNlRG9tYWluLmluZGV4T2YoX2NvbmYuQ09OU1RBTlRTLk1PQ0tfUFJPVE9DT0wpICYmIDAgIT09IG1lc3NhZ2Uuc291cmNlRG9tYWluLmluZGV4T2YoX2NvbmYuQ09OU1RBTlRTLkZJTEVfUFJPVE9DT0wpIHx8IChvcmlnaW4gPSBtZXNzYWdlLnNvdXJjZURvbWFpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX2dsb2JhbC5nbG9iYWwucmVjZWl2ZWRNZXNzYWdlcy5pbmRleE9mKG1lc3NhZ2UuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWNlaXZlZE1lc3NhZ2VzLnB1c2gobWVzc2FnZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IC0xICE9PSBfY29uZi5QT1NUX01FU1NBR0VfTkFNRVNfTElTVC5pbmRleE9mKG1lc3NhZ2UubmFtZSkgfHwgbWVzc2FnZS50eXBlID09PSBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuQUNLID8gXCJkZWJ1Z1wiIDogXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IFwiZXJyb3JcIiA6IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xpYi5sb2cubG9nTGV2ZWwobGV2ZWwsIFsgXCJcXG5cXG5cXHRcIiwgXCIjcmVjZWl2ZVwiLCBtZXNzYWdlLnR5cGUucmVwbGFjZSgvXnBvc3Ryb2JvdF9tZXNzYWdlXy8sIFwiXCIpLCBcIjo6XCIsIG1lc3NhZ2UubmFtZSwgXCI6OlwiLCBvcmlnaW4sIFwiXFxuXFxuXCIsIG1lc3NhZ2UgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjLmlzV2luZG93Q2xvc2VkKShzb3VyY2UpIHx8IG1lc3NhZ2UuZmlyZUFuZEZvcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSAmJiAobWVzc2FnZS5kYXRhID0gKDAsIF9saWIuZGVzZXJpYWxpemVNZXRob2RzKShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZS5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3R5cGVzLlJFQ0VJVkVfTUVTU0FHRV9UWVBFU1ttZXNzYWdlLnR5cGVdKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBfbGliLmxvZy5kZWJ1ZyhcIlNvdXJjZSB3aW5kb3cgaXMgY2xvc2VkIC0gY2FuIG5vdCBzZW5kIFwiICsgbWVzc2FnZS50eXBlICsgXCIgXCIgKyBtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbWVzc2FnZUxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIubm9vcCkoZXZlbnQuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGV2ZW50LnNvdXJjZSB8fCBldmVudC5zb3VyY2VFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGV2ZW50Lm9yaWdpbiB8fCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBldmVudC5kYXRhXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29tcGF0L2luZGV4LmpzXCIpLmVtdWxhdGVJRVJlc3RyaWN0aW9ucyhtZXNzYWdlRXZlbnQuc291cmNlLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWNlaXZlTWVzc2FnZSA9IHJlY2VpdmVNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvcmVjZWl2ZS90eXBlcy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLlJFQ0VJVkVfTUVTU0FHRV9UWVBFUyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfUkVDRUlWRV9NRVNTQUdFX1RZUEUsIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0sIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2luZGV4LmpzXCIpLCBfc2VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3NlbmQvaW5kZXguanNcIiksIF9saXN0ZW5lcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9saXN0ZW5lcnMuanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLlJFQ0VJVkVfTUVTU0FHRV9UWVBFUyA9ICgoX1JFQ0VJVkVfTUVTU0FHRV9UWVBFID0ge30pW19jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5BQ0tdID0gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBfbGlzdGVuZXJzLmlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQpKG1lc3NhZ2UuaGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAoMCwgX2xpc3RlbmVycy5nZXRSZXNwb25zZUxpc3RlbmVyKShtZXNzYWdlLmhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSBhY2sgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIkFjayBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hY2sgPSAhMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfUkVDRUlWRV9NRVNTQUdFX1RZUEVbX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9UWVBFLlJFUVVFU1RdID0gZnVuY3Rpb24oc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9ICgwLCBfbGlzdGVuZXJzLmdldFJlcXVlc3RMaXN0ZW5lcikoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBtZXNzYWdlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHdpbjogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3BvbmQoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5maXJlQW5kRm9yZ2V0IHx8ICgwLCBfc3JjMi5pc1dpbmRvd0Nsb3NlZCkoc291cmNlKSA/IF9zcmMuWmFsZ29Qcm9taXNlLnJlc29sdmUoKSA6ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgX3NlbmQuc2VuZE1lc3NhZ2UpKHNvdXJjZSwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBtZXNzYWdlLm9yaWdpbmFsU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lXG4gICAgICAgICAgICAgICAgICAgIH0sIGRhdGEpLCBvcmlnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UuYWxsKFsgcmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5BQ0tcbiAgICAgICAgICAgICAgICB9KSwgX3NyYy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMyLm1hdGNoRG9tYWluKShvcHRpb25zLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmhhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5SRVNQT05TRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjazogX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9BQ0suU1VDQ0VTUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICgwLCBfbGliLnN0cmluZ2lmeUVycm9yKShlcnIpLnJlcGxhY2UoL15FcnJvcjogLywgXCJcIiksIGNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9UWVBFLlJFU1BPTlNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNrOiBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX0FDSy5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkgXSkudGhlbihfbGliLm5vb3ApLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUVycm9yKSByZXR1cm4gb3B0aW9ucy5oYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBfbGliLmxvZy5lcnJvcigoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBfUkVDRUlWRV9NRVNTQUdFX1RZUEVbX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9UWVBFLlJFU1BPTlNFXSA9IGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoMCwgX2xpc3RlbmVycy5pc1Jlc3BvbnNlTGlzdGVuZXJFcnJvcmVkKShtZXNzYWdlLmhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gKDAsIF9saXN0ZW5lcnMuZ2V0UmVzcG9uc2VMaXN0ZW5lcikobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYW5kbGVyIGZvdW5kIGZvciBwb3N0IG1lc3NhZ2UgcmVzcG9uc2UgZm9yIG1lc3NhZ2U6IFwiICsgbWVzc2FnZS5uYW1lICsgXCIgZnJvbSBcIiArIG9yaWdpbiArIFwiIGluIFwiICsgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIG9yaWdpbiBcIiArIG9yaWdpbiArIFwiIGRvZXMgbm90IG1hdGNoIGRvbWFpbiBcIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgX3NyYzIuc3RyaW5naWZ5RG9tYWluUGF0dGVybikob3B0aW9ucy5kb21haW4pKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saXN0ZW5lcnMuZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcikobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYWNrID09PSBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX0FDSy5FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZSAmJiAoZXJyLmNvZGUgPSBtZXNzYWdlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVzcG9uZChlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmFjayA9PT0gX2NvbmYuQ09OU1RBTlRTLlBPU1RfTUVTU0FHRV9BQ0suU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGEgfHwgbWVzc2FnZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlc3BvbmQobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX1JFQ0VJVkVfTUVTU0FHRV9UWVBFKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9kcml2ZXJzL3NlbmQvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24od2luLCBtZXNzYWdlLCBkb21haW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9qc29uU3RyaW5naWZ5O1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZnVuY3Rpb24od2luLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge30sIGlkID0gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpYi51bmlxdWVJRCkoKSwgdHlwZSA9ICgwLCBfbGliLmdldFdpbmRvd1R5cGUpKCksIHNvdXJjZURvbWFpbiA9ICgwLCBfc3JjLmdldERvbWFpbikod2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgbWVzc2FnZSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZURvbWFpbjogc291cmNlRG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1R5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KHdpbiwgbWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKDAsIF9saWIuc2VyaWFsaXplTWV0aG9kcykod2luLCBkb21haW4sIG1lc3NhZ2UuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IC0xICE9PSBfY29uZi5QT1NUX01FU1NBR0VfTkFNRVNfTElTVC5pbmRleE9mKG1lc3NhZ2UubmFtZSkgfHwgbWVzc2FnZS50eXBlID09PSBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX1RZUEUuQUNLID8gXCJkZWJ1Z1wiIDogXCJlcnJvclwiID09PSBtZXNzYWdlLmFjayA/IFwiZXJyb3JcIiA6IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgICAgICBfbGliLmxvZy5sb2dMZXZlbChsZXZlbCwgWyBcIlxcblxcblxcdFwiLCBcIiNzZW5kXCIsIG1lc3NhZ2UudHlwZS5yZXBsYWNlKC9ecG9zdHJvYm90X21lc3NhZ2VfLywgXCJcIiksIFwiOjpcIiwgbWVzc2FnZS5uYW1lLCBcIjo6XCIsIGRvbWFpbiB8fCBfY29uZi5DT05TVEFOVFMuV0lMRENBUkQsIFwiXFxuXFxuXCIsIG1lc3NhZ2UgXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdyAmJiAhX2NvbmYuQ09ORklHLkFMTE9XX1NBTUVfT1JJR0lOKSB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXBpbmcgdG8gc2VuZCBtZXNzYWdlIHRvIHNlbGZcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiV2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX2xpYi5sb2cuZGVidWcoXCJSdW5uaW5nIHNlbmQgbWVzc2FnZSBzdHJhdGVnaWVzXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBbXSwgc2VyaWFsaXplZE1lc3NhZ2UgPSAoMCwgX2xpYi5qc29uU3RyaW5naWZ5KSgoKF9qc29uU3RyaW5naWZ5ID0ge30pW19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXSA9IG1lc3NhZ2UsIFxuICAgICAgICAgICAgICAgICAgICBfanNvblN0cmluZ2lmeSksIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLm1hcChPYmplY3Qua2V5cyhfc3RyYXRlZ2llcy5TRU5EX01FU1NBR0VfU1RSQVRFR0lFUyksIGZ1bmN0aW9uKHN0cmF0ZWd5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29uZi5DT05GSUcuQUxMT1dFRF9QT1NUX01FU1NBR0VfTUVUSE9EU1tzdHJhdGVneU5hbWVdKSB0aHJvdyBuZXcgRXJyb3IoXCJTdHJhdGVneSBkaXNhbGxvd2VkOiBcIiArIHN0cmF0ZWd5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdHJhdGVnaWVzLlNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTW3N0cmF0ZWd5TmFtZV0od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChzdHJhdGVneU5hbWUgKyBcIjogc3VjY2Vzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKHN0cmF0ZWd5TmFtZSArIFwiOiBcIiArICgwLCBfbGliLnN0cmluZ2lmeUVycm9yKShlcnIpICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSByZXN1bHRzLnNvbWUoQm9vbGVhbiksIHN0YXR1cyA9IG1lc3NhZ2UudHlwZSArIFwiIFwiICsgbWVzc2FnZS5uYW1lICsgXCIgXCIgKyAoc3VjY2VzcyA/IFwic3VjY2Vzc1wiIDogXCJlcnJvclwiKSArIFwiOlxcbiAgLSBcIiArIG1lc3NhZ2VzLmpvaW4oXCJcXG4gIC0gXCIpICsgXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIubG9nLmRlYnVnKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHRocm93IG5ldyBFcnJvcihzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9zdHJhdGVnaWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvc2VuZC9zdHJhdGVnaWVzLmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvc2VuZC9zdHJhdGVnaWVzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuU0VORF9NRVNTQUdFX1NUUkFURUdJRVMgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMgPSBleHBvcnRzLlNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTID0ge307XG4gICAgICAgICAgICBTRU5EX01FU1NBR0VfU1RSQVRFR0lFU1tfY29uZi5DT05TVEFOVFMuU0VORF9TVFJBVEVHSUVTLlBPU1RfTUVTU0FHRV0gPSBmdW5jdGlvbih3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29tcGF0L2luZGV4LmpzXCIpLmVtdWxhdGVJRVJlc3RyaWN0aW9ucyh3aW5kb3csIHdpbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoZG9tYWluKSA/IGRvbWFpbiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIGRvbWFpbiA/IFsgZG9tYWluIF0gOiBbIF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCBdKS5tYXAoZnVuY3Rpb24oZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID09PSBkb20uaW5kZXhPZihfY29uZi5DT05TVEFOVFMuTU9DS19QUk9UT0NPTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IF9jb25mLkNPTlNUQU5UUy5GSUxFX1BST1RPQ09MKSByZXR1cm4gX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYy5pc0FjdHVhbGx5U2FtZURvbWFpbikod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdGluZyB0byBzZW5kIG1lc3NzYWdlIHRvIG1vY2sgZG9tYWluIFwiICsgZG9tICsgXCIsIGJ1dCB3aW5kb3cgaXMgYWN0dWFsbHkgY3Jvc3MtZG9tYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc3JjLmdldEFjdHVhbERvbWFpbikod2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMCA9PT0gZG9tLmluZGV4T2YoX2NvbmYuQ09OU1RBTlRTLkZJTEVfUFJPVE9DT0wpID8gX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEIDogZG9tO1xuICAgICAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW4ucG9zdE1lc3NhZ2Uoc2VyaWFsaXplZE1lc3NhZ2UsIGRvbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9pbmRleC5qc1wiKSwgc2VuZEJyaWRnZU1lc3NhZ2UgPSBfcmVxdWlyZS5zZW5kQnJpZGdlTWVzc2FnZSwgbmVlZHNCcmlkZ2VGb3JCcm93c2VyID0gX3JlcXVpcmUubmVlZHNCcmlkZ2VGb3JCcm93c2VyLCBpc0JyaWRnZSA9IF9yZXF1aXJlLmlzQnJpZGdlO1xuICAgICAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVNbX2NvbmYuQ09OU1RBTlRTLlNFTkRfU1RSQVRFR0lFUy5CUklER0VdID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzQnJpZGdlRm9yQnJvd3NlcigpIHx8IGlzQnJpZGdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjLmlzU2FtZURvbWFpbikod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiUG9zdCBtZXNzYWdlIHRocm91Z2ggYnJpZGdlIGRpc2FibGVkIGJldHdlZW4gc2FtZSBkb21haW4gd2luZG93c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSAoMCwgX3NyYy5pc1NhbWVUb3BXaW5kb3cpKHdpbmRvdywgd2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgdXNlIGJyaWRnZSB0byBjb21tdW5pY2F0ZSBiZXR3ZWVuIHR3byBkaWZmZXJlbnQgd2luZG93cywgbm90IGJldHdlZW4gZnJhbWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZEJyaWRnZU1lc3NhZ2Uod2luLCBzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVNbX2NvbmYuQ09OU1RBTlRTLlNFTkRfU1RSQVRFR0lFUy5HTE9CQUxdID0gZnVuY3Rpb24od2luLCBzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2xpYi5uZWVkc0dsb2JhbE1lc3NhZ2luZ0ZvckJyb3dzZXIpKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYy5pc1NhbWVEb21haW4pKHdpbikpIHRocm93IG5ldyBFcnJvcihcIlBvc3QgbWVzc2FnZSB0aHJvdWdoIGdsb2JhbCBkaXNhYmxlZCBiZXR3ZWVuIGRpZmZlcmVudCBkb21haW4gd2luZG93c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCExICE9PSAoMCwgX3NyYy5pc1NhbWVUb3BXaW5kb3cpKHdpbmRvdywgd2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgdXNlIGdsb2JhbCB0byBjb21tdW5pY2F0ZSBiZXR3ZWVuIHR3byBkaWZmZXJlbnQgd2luZG93cywgbm90IGJldHdlZW4gZnJhbWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm9yZWlnbkdsb2JhbCA9IHdpbltfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm9yZWlnbkdsb2JhbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIHBvc3RSb2JvdCBnbG9iYWwgb24gZm9yZWlnbiB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JlaWduR2xvYmFsLnJlY2VpdmVNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogd2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiAoMCwgX3NyYy5nZXREb21haW4pKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBzZXJpYWxpemVkTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2dsb2JhbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmdsb2JhbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgKGV4cG9ydHMuZ2xvYmFsID0gd2luZG93W19jb25mLkNPTlNUQU5UUy5XSU5ET1dfUFJPUFMuUE9TVFJPQk9UXSA9IHdpbmRvd1tfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF0gfHwge30pLnJlZ2lzdGVyU2VsZiA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9pbnRlcmZhY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW50ZXJmYWNlLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2ludGVyZmFjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaW50ZXJmYWNlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIElOVEVSRkFDRSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChudWxsICE9IG9iaikgZm9yICh2YXIga2V5IGluIG9iaikgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiAobmV3T2JqW2tleV0gPSBvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICAgICAgICAgIH0oX2ludGVyZmFjZSk7XG4gICAgICAgICAgICBleHBvcnRzLmRlZmF1bHQgPSBJTlRFUkZBQ0U7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW50ZXJmYWNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuYnJpZGdlID0gZXhwb3J0cy5Qcm9taXNlID0gZXhwb3J0cy5jbGVhblVwV2luZG93ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9wdWJsaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvcHVibGljL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3B1YmxpYykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHVibGljW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jbGVhbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jbGVhbi5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsZWFuVXBXaW5kb3dcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2xlYW4uY2xlYW5VcFdpbmRvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwb3J0cy5pbml0ID0gaW5pdDtcbiAgICAgICAgICAgIHZhciBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2RyaXZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLmJyaWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9icmlkZ2UvaW50ZXJmYWNlLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9nbG9iYWwuZ2xvYmFsLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfZHJpdmVycy5saXN0ZW5Gb3JNZXNzYWdlcykoKTtcbiAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2JyaWRnZS9pbmRleC5qc1wiKS5vcGVuVHVubmVsVG9PcGVuZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaW5pdE9uUmVhZHkpKCk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmxpc3RlbkZvck1ldGhvZHMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBfcHVibGljLm9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3B1YmxpYy5zZW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5pbml0aWFsaXplZCA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3V0aWwuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdXRpbCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdXRpbFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9sb2cuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfbG9nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9sb2dba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3NlcmlhbGl6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvc2VyaWFsaXplLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3NlcmlhbGl6ZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9yZWFkeSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvcmVhZHkuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcmVhZHkpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWR5W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9sb2cuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5sb2cgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9LCBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpLCBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvdXRpbC5qc1wiKSwgTE9HX0xFVkVMUyA9IFsgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiBdO1xuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiYgd2luZG93LmNvbnNvbGUgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihjb25zb2xlLmxvZykgJiYgWyBcImxvZ1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiBdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZVttZXRob2RdID0gdGhpcy5iaW5kKGNvbnNvbGVbbWV0aG9kXSwgY29uc29sZSk7XG4gICAgICAgICAgICB9LCBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCk7XG4gICAgICAgICAgICB2YXIgbG9nID0gZXhwb3J0cy5sb2cgPSB7XG4gICAgICAgICAgICAgICAgY2xlYXJMb2dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUuY2xlYXIgJiYgd2luZG93LmNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb25mLkNPTkZJRy5MT0dfVE9fUEFHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG9zdFJvYm90TG9nc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciAmJiBjb250YWluZXIucGFyZW50Tm9kZSAmJiBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3cml0ZVRvUGFnZTogZnVuY3Rpb24obGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBvc3RSb2JvdExvZ3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKS5pZCA9IFwicG9zdFJvYm90TG9nc1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJ3aWR0aDogODAwcHg7IGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7IHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIGRhdGUgPSBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkuc3BsaXQoXCIgXCIpWzRdLCBwYXlsb2FkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbSkgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSAoMCwgX3V0aWwuanNvblN0cmluZ2lmeSkoaXRlbSwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSBcIltvYmplY3RdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlxcblxcblwiICsganNvbiArIFwiXFxuXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiIFwiKSwgbXNnID0gZGF0ZSArIFwiIFwiICsgbGV2ZWwgKyBcIiBcIiArIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwgPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nOiBcIiNkZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuOiBcIm9yYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBcInJlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm86IFwiYmx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnOiBcIiNhYWFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVtsZXZlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5jc3NUZXh0ID0gXCJtYXJnaW4tdG9wOiAxMHB4OyBjb2xvcjogXCIgKyBjb2xvciArIFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID8gY29udGFpbmVyLmluc2VydEJlZm9yZShlbCwgY29udGFpbmVyLmNoaWxkTm9kZXNbMF0pIDogY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2dMZXZlbDogZnVuY3Rpb24obGV2ZWwsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0gd2luZG93LkxPR19MRVZFTCB8fCBfY29uZi5DT05GSUcuTE9HX0xFVkVMO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImRpc2FibGVkXCIgPT09IGxvZ0xldmVsIHx8IExPR19MRVZFTFMuaW5kZXhPZihsZXZlbCkgPCBMT0dfTEVWRUxTLmluZGV4T2YobG9nTGV2ZWwpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSkudW5zaGlmdChcIlwiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChcIjo6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MudW5zaGlmdChcIlwiICsgKDAsIF91dGlsLmdldFdpbmRvd1R5cGUpKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KFwiW3Bvc3Qtcm9ib3RdXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb25mLkNPTkZJRy5MT0dfVE9fUEFHRSAmJiBsb2cud3JpdGVUb1BhZ2UobGV2ZWwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luZG93LmNvbnNvbGUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZVtsZXZlbF0gfHwgKGxldmVsID0gXCJsb2dcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW5kb3cuY29uc29sZVtsZXZlbF0pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZVtsZXZlbF0uYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlYnVnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIGxvZy5sb2dMZXZlbChcImRlYnVnXCIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgIGxvZy5sb2dMZXZlbChcImluZm9cIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB3YXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmxvZ0xldmVsKFwid2FyblwiLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmxvZ0xldmVsKFwiZXJyb3JcIiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvcmVhZHkuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5vbkhlbGxvID0gb25IZWxsbztcbiAgICAgICAgICAgIGV4cG9ydHMuc2F5SGVsbG8gPSBzYXlIZWxsbztcbiAgICAgICAgICAgIGV4cG9ydHMuaW5pdE9uUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkhlbGxvKGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsIG9yaWdpbiA9IF9yZWYzLm9yaWdpbiwgcHJvbWlzZSA9IF9nbG9iYWwuZ2xvYmFsLnJlYWR5UHJvbWlzZXMuZ2V0KHNvdXJjZSkgfHwgbmV3IF9zcmMzLlphbGdvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlYWR5UHJvbWlzZXMuc2V0KHNvdXJjZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICgwLCBfc3JjMi5nZXRBbmNlc3RvcikoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgJiYgc2F5SGVsbG8ocGFyZW50KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvZy5sb2cuZGVidWcoKDAsIF91dGlsLnN0cmluZ2lmeUVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm9uQ2hpbGRXaW5kb3dSZWFkeSA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiA1ZTMsIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IFwiV2luZG93XCIsIHByb21pc2UgPSBfZ2xvYmFsLmdsb2JhbC5yZWFkeVByb21pc2VzLmdldCh3aW4pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlKSByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbmV3IF9zcmMzLlphbGdvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlYWR5UHJvbWlzZXMuc2V0KHdpbiwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgLTEgIT09IHRpbWVvdXQgJiYgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihuYW1lICsgXCIgZGlkIG5vdCBsb2FkIGFmdGVyIFwiICsgdGltZW91dCArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIiksIF9sb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL2xvZy5qc1wiKSwgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvbGliL3V0aWwuanNcIik7XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5yZWFkeVByb21pc2VzID0gX2dsb2JhbC5nbG9iYWwucmVhZHlQcm9taXNlcyB8fCBuZXcgX3NyYy5XZWFrTWFwKCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkhlbGxvKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5vbihfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX05BTUVTLkhFTExPLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYub3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2F5SGVsbG8od2luKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLnNlbmQod2luLCBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX05BTUVTLkhFTExPLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICBkb21haW46IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRCxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogLTFcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IF9yZWYyLm9yaWdpblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9zZXJpYWxpemUuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5saXN0ZW5Gb3JNZXRob2RzID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2VyaWFsaXplTWV0aG9kID0gc2VyaWFsaXplTWV0aG9kO1xuICAgICAgICAgICAgZXhwb3J0cy5zZXJpYWxpemVNZXRob2RzID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5yZXBsYWNlT2JqZWN0KSh7XG4gICAgICAgICAgICAgICAgICAgIG9iajogb2JqXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oaXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0gPyBzZXJpYWxpemVNZXRob2QoZGVzdGluYXRpb24sIGRvbWFpbiwgaXRlbSwga2V5LnRvU3RyaW5nKCkpIDogaXRlbSBpbnN0YW5jZW9mIEVycm9yID8gKGVyciA9IGl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGVfXzogX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX21lc3NhZ2VfXzogKDAsIF91dGlsLnN0cmluZ2lmeUVycm9yKShlcnIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19jb2RlX186IGVyci5jb2RlXG4gICAgICAgICAgICAgICAgICAgIH0pIDogd2luZG93LlByb21pc2UgJiYgaXRlbSBpbnN0YW5jZW9mIHdpbmRvdy5Qcm9taXNlID8gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgcHJvbWlzZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGVfXzogX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuUFJPTUlTRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX3RoZW5fXzogc2VyaWFsaXplTWV0aG9kKGRlc3RpbmF0aW9uLCBkb21haW4sIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgbmFtZSArIFwiLnRoZW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0oZGVzdGluYXRpb24sIGRvbWFpbiwgaXRlbSwga2V5LnRvU3RyaW5nKCkpIDogX3NyYzMuWmFsZ29Qcm9taXNlLmlzUHJvbWlzZShpdGVtKSA/IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBkb21haW4sIHByb21pc2UsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlpBTEdPX1BST01JU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190aGVuX186IHNlcmlhbGl6ZU1ldGhvZChkZXN0aW5hdGlvbiwgZG9tYWluLCBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG5hbWUgKyBcIi50aGVuXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIGl0ZW0sIGtleS50b1N0cmluZygpKSA6ICgwLCBfdXRpbC5pc1JlZ2V4KShpdGVtKSA/IChyZWdleCA9IGl0ZW0sIFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX3R5cGVfXzogX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuUkVHRVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBfX3NvdXJjZV9fOiByZWdleC5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIsIHJlZ2V4O1xuICAgICAgICAgICAgICAgIH0pLm9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlc2VyaWFsaXplTWV0aG9kID0gZGVzZXJpYWxpemVNZXRob2Q7XG4gICAgICAgICAgICBleHBvcnRzLmRlc2VyaWFsaXplRXJyb3IgPSBkZXNlcmlhbGl6ZUVycm9yO1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZVphbGdvUHJvbWlzZSA9IGRlc2VyaWFsaXplWmFsZ29Qcm9taXNlO1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZVByb21pc2UgPSBkZXNlcmlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBleHBvcnRzLmRlc2VyaWFsaXplUmVnZXggPSBkZXNlcmlhbGl6ZVJlZ2V4O1xuICAgICAgICAgICAgZXhwb3J0cy5kZXNlcmlhbGl6ZU1ldGhvZHMgPSBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgb2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5yZXBsYWNlT2JqZWN0KSh7XG4gICAgICAgICAgICAgICAgICAgIG9iajogb2JqXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gaXRlbSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGl0ZW0pKSAmJiBudWxsICE9PSBpdGVtKSByZXR1cm4gaXNTZXJpYWxpemVkKGl0ZW0sIF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLk1FVEhPRCkgPyBkZXNlcmlhbGl6ZU1ldGhvZChzb3VyY2UsIG9yaWdpbiwgaXRlbSkgOiBpc1NlcmlhbGl6ZWQoaXRlbSwgX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuRVJST1IpID8gZGVzZXJpYWxpemVFcnJvcihzb3VyY2UsIG9yaWdpbiwgaXRlbSkgOiBpc1NlcmlhbGl6ZWQoaXRlbSwgX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuUFJPTUlTRSkgPyBkZXNlcmlhbGl6ZVByb21pc2Uoc291cmNlLCBvcmlnaW4sIGl0ZW0pIDogaXNTZXJpYWxpemVkKGl0ZW0sIF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlpBTEdPX1BST01JU0UpID8gZGVzZXJpYWxpemVaYWxnb1Byb21pc2Uoc291cmNlLCBvcmlnaW4sIGl0ZW0pIDogaXNTZXJpYWxpemVkKGl0ZW0sIF9jb25mLkNPTlNUQU5UUy5TRVJJQUxJWkFUSU9OX1RZUEVTLlJFR0VYKSA/IGRlc2VyaWFsaXplUmVnZXgoc291cmNlLCBvcmlnaW4sIGl0ZW0pIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIH0pLm9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpLCBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvdXRpbC5qc1wiKSwgX2xvZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvbG9nLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwubWV0aG9kcyA9IF9nbG9iYWwuZ2xvYmFsLm1ldGhvZHMgfHwgbmV3IF9zcmMuV2Vha01hcCgpO1xuICAgICAgICAgICAgZXhwb3J0cy5saXN0ZW5Gb3JNZXRob2RzID0gKDAsIF91dGlsLm9uY2UpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLm9uKF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfTkFNRVMuTUVUSE9ELCB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogX2NvbmYuQ09OU1RBTlRTLldJTERDQVJEXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZi5zb3VyY2UsIG9yaWdpbiA9IF9yZWYub3JpZ2luLCBkYXRhID0gX3JlZi5kYXRhLCBtZXRob2RzID0gX2dsb2JhbC5nbG9iYWwubWV0aG9kcy5nZXQoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRob2RzKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBhbnkgbWV0aG9kcyB0aGlzIHdpbmRvdyBoYXMgcHJpdmlsZWdlcyB0byBjYWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbZGF0YS5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWV0aCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbWV0aG9kIHdpdGggaWQ6IFwiICsgZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMyLm1hdGNoRG9tYWluKShtZXRoLmRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIGRvbWFpbiBcIiArIG1ldGguZG9tYWluICsgXCIgZG9lcyBub3QgbWF0Y2ggb3JpZ2luIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgX2xvZy5sb2cuZGVidWcoXCJDYWxsIGxvY2FsIG1ldGhvZFwiLCBkYXRhLm5hbWUsIGRhdGEuYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGgubWV0aG9kLmFwcGx5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBkYXRhLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc1NlcmlhbGl6ZWQoaXRlbSwgdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpICYmIG51bGwgIT09IGl0ZW0gJiYgaXRlbS5fX3R5cGVfXyA9PT0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZU1ldGhvZChkZXN0aW5hdGlvbiwgZG9tYWluLCBtZXRob2QsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSAoMCwgX3V0aWwudW5pcXVlSUQpKCksIG1ldGhvZHMgPSBfZ2xvYmFsLmdsb2JhbC5tZXRob2RzLmdldChkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwubWV0aG9kcy5zZXQoZGVzdGluYXRpb24sIG1ldGhvZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2RzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4sXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfX3R5cGVfXzogX2NvbmYuQ09OU1RBTlRTLlNFUklBTElaQVRJT05fVFlQRVMuTUVUSE9ELFxuICAgICAgICAgICAgICAgICAgICBfX2lkX186IGlkLFxuICAgICAgICAgICAgICAgICAgICBfX25hbWVfXzogbmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1ldGhvZChzb3VyY2UsIG9yaWdpbiwgb2JqKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBfbG9nLmxvZy5kZWJ1ZyhcIkNhbGwgZm9yZWlnbiBtZXRob2RcIiwgb2JqLl9fbmFtZV9fLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWwuZ2xvYmFsLnNlbmQoc291cmNlLCBfY29uZi5DT05TVEFOVFMuUE9TVF9NRVNTQUdFX05BTUVTLk1FVEhPRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG9iai5fX2lkX18sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBvYmouX19uYW1lX18sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogLTFcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihfcmVmMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvZy5sb2cuZGVidWcoXCJHb3QgZm9yZWlnbiBtZXRob2QgcmVzdWx0XCIsIG9iai5fX25hbWVfXywgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2cubG9nLmRlYnVnKFwiR290IGZvcmVpZ24gbWV0aG9kIGVycm9yXCIsICgwLCBfdXRpbC5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cmFwcGVyLl9fbmFtZV9fID0gb2JqLl9fbmFtZV9fO1xuICAgICAgICAgICAgICAgIHdyYXBwZXIuX194ZG9tYWluX18gPSAhMDtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICB3cmFwcGVyLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3Ioc291cmNlLCBvcmlnaW4sIG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3Iob2JqLl9fbWVzc2FnZV9fKTtcbiAgICAgICAgICAgICAgICBvYmouX19jb2RlX18gJiYgKGVyci5jb2RlID0gb2JqLl9fY29kZV9fKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVaYWxnb1Byb21pc2Uoc291cmNlLCBvcmlnaW4sIHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9zcmMzLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTWV0aG9kKHNvdXJjZSwgb3JpZ2luLCBwcm9tLl9fdGhlbl9fKShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVzZXJpYWxpemVQcm9taXNlKHNvdXJjZSwgb3JpZ2luLCBwcm9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5Qcm9taXNlID8gbmV3IHdpbmRvdy5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVNZXRob2Qoc291cmNlLCBvcmlnaW4sIHByb20uX190aGVuX18pKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfSkgOiBkZXNlcmlhbGl6ZVphbGdvUHJvbWlzZShzb3VyY2UsIG9yaWdpbiwgcHJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ2V4KHNvdXJjZSwgb3JpZ2luLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoaXRlbS5fX3NvdXJjZV9fKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvdXRpbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLndlYWtNYXBNZW1vaXplID0gZXhwb3J0cy5vbmNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5RXJyb3IgPSBmdW5jdGlvbiBzdHJpbmdpZnlFcnJvcihlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID49IDMpIHJldHVybiBcInN0cmluZ2lmeUVycm9yIHN0YWNrIG92ZXJmbG93XCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHJldHVybiBcIjx1bmtub3duIGVycm9yOiBcIiArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpICsgXCI+XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlcnIpIHJldHVybiBlcnI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyICYmIGVyci5zdGFjaywgbWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjayAmJiBtZXNzYWdlKSByZXR1cm4gLTEgIT09IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPyBzdGFjayA6IG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2spIHJldHVybiBzdGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnIudG9TdHJpbmcgPyBlcnIudG9TdHJpbmcoKSA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0Vycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvciB3aGlsZSBzdHJpbmdpZnlpbmcgZXJyb3I6IFwiICsgc3RyaW5naWZ5RXJyb3IobmV3RXJyLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24ob2JqLCBldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIG9iai5hZGRFdmVudExpc3RlbmVyID8gb2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpIDogb2JqLmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikgOiBvYmouZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnVuaXF1ZUlEID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lYWNoQXJyYXkgPSBlYWNoQXJyYXk7XG4gICAgICAgICAgICBleHBvcnRzLmVhY2hPYmplY3QgPSBlYWNoT2JqZWN0O1xuICAgICAgICAgICAgZXhwb3J0cy5lYWNoID0gZWFjaDtcbiAgICAgICAgICAgIGV4cG9ydHMucmVwbGFjZU9iamVjdCA9IGZ1bmN0aW9uIHJlcGxhY2VPYmplY3QoaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID49IDEwMCkgdGhyb3cgbmV3IEVycm9yKFwiU2VsZi1yZWZlcmVudGlhbCBvYmplY3QgcGFzc2VkLCBvciBvYmplY3QgY29udGFpbmVkIHRvbyBtYW55IGxheWVyc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3b2JqID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpIHx8IG51bGwgPT09IGl0ZW0gfHwgQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHR5cGU6IFwiICsgKHZvaWQgMCA9PT0gaXRlbSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGl0ZW0pKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld29iaiA9IFtdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBuZXdvYmogPSB7fTtcbiAgICAgICAgICAgICAgICBlYWNoKGl0ZW0sIGZ1bmN0aW9uKGNoaWxkSXRlbSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjayhjaGlsZEl0ZW0sIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gcmVzdWx0ID8gbmV3b2JqW2tleV0gPSByZXN1bHQgOiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBjaGlsZEl0ZW0gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjaGlsZEl0ZW0pKSAmJiBudWxsICE9PSBjaGlsZEl0ZW0gPyBuZXdvYmpba2V5XSA9IHJlcGxhY2VPYmplY3QoY2hpbGRJdGVtLCBjYWxsYmFjaywgZGVwdGggKyAxKSA6IG5ld29ialtrZXldID0gY2hpbGRJdGVtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlSW50ZXJ2YWwgPSBmdW5jdGlvbihtZXRob2QsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiBydW5JbnRlcnZhbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocnVuSW50ZXJ2YWwsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QuY2FsbCgpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNSZWdleCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0V2luZG93VHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzIuaXNQb3B1cCkoKSkgcmV0dXJuIF9jb25mLkNPTlNUQU5UUy5XSU5ET1dfVFlQRVMuUE9QVVA7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMi5pc0lmcmFtZSkoKSkgcmV0dXJuIF9jb25mLkNPTlNUQU5UUy5XSU5ET1dfVFlQRVMuSUZSQU1FO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZi5DT05TVEFOVFMuV0lORE9XX1RZUEVTLkZVTExQQUdFO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuanNvblN0cmluZ2lmeSA9IGZ1bmN0aW9uKG9iaiwgcmVwbGFjZXIsIGluZGVudCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RUb0pTT04gPSB2b2lkIDAsIGFycmF5VG9KU09OID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInt9XCIgIT09IEpTT04uc3RyaW5naWZ5KHt9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VG9KU09OID0gT2JqZWN0LnByb3RvdHlwZS50b0pTT047XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS50b0pTT047XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwie31cIiAhPT0gSlNPTi5zdHJpbmdpZnkoe30pKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGNvcnJlY3RseSBzZXJpYWxpemUgSlNPTiBvYmplY3RzXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJbXVwiICE9PSBKU09OLnN0cmluZ2lmeShbXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5VG9KU09OID0gQXJyYXkucHJvdG90eXBlLnRvSlNPTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBBcnJheS5wcm90b3R5cGUudG9KU09OO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIltdXCIgIT09IEpTT04uc3RyaW5naWZ5KFtdKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBjb3JyZWN0bHkgc2VyaWFsaXplIEpTT04gb2JqZWN0c1wiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXBhaXIgSlNPTi5zdHJpbmdpZnk6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkuY2FsbCh0aGlzLCBvYmosIHJlcGxhY2VyLCBpbmRlbnQpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFRvSlNPTiAmJiAoT2JqZWN0LnByb3RvdHlwZS50b0pTT04gPSBvYmplY3RUb0pTT04pO1xuICAgICAgICAgICAgICAgICAgICBhcnJheVRvSlNPTiAmJiAoQXJyYXkucHJvdG90eXBlLnRvSlNPTiA9IGFycmF5VG9KU09OKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZXBhaXIgSlNPTi5zdHJpbmdpZnk6IFwiICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuanNvblBhcnNlID0gZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGl0ZW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubmVlZHNHbG9iYWxNZXNzYWdpbmdGb3JCcm93c2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjMi5nZXRVc2VyQWdlbnQpKHdpbmRvdykubWF0Y2goL01TSUV8dHJpZGVudHxlZGdlXFwvMTJ8ZWRnZVxcLzEzL2kpKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgaWYgKCFfY29uZi5DT05GSUcuQUxMT1dfUE9TVE1FU1NBR0VfUE9QVVApIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXNhZmUtd2Vha21hcC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9jb25mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2NvbmYvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLm9uY2UgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGhvZCkgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGVkID0gITE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hBcnJheShpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbS5sZW5ndGg7IGkrKykgY2FsbGJhY2soaXRlbVtpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoT2JqZWN0KGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2tleSBpbiBpdGVtKSBpdGVtLmhhc093blByb3BlcnR5KF9rZXkpICYmIGNhbGxiYWNrKGl0ZW1bX2tleV0sIF9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZWFjaChpdGVtLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoaXRlbSkgPyBlYWNoQXJyYXkoaXRlbSwgY2FsbGJhY2spIDogXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gaXRlbSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGl0ZW0pKSAmJiBudWxsICE9PSBpdGVtICYmIGVhY2hPYmplY3QoaXRlbSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwb3J0cy53ZWFrTWFwTWVtb2l6ZSA9IGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gbmV3IF9zcmMuV2Vha01hcCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHdlYWttYXAuZ2V0KGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSAocmVzdWx0ID0gbWV0aG9kLmNhbGwodGhpcywgYXJnKSkgJiYgd2Vha21hcC5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9jbGllbnQuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5zZW5kID0gdm9pZCAwO1xuICAgICAgICAgICAgZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIGV4cG9ydHMuc2VuZFRvUGFyZW50ID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciB3aW4gPSAoMCwgX3NyYzMuZ2V0QW5jZXN0b3IpKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIldpbmRvdyBkb2VzIG5vdCBoYXZlIGEgcGFyZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3NlbmQod2luLCBuYW1lLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmNsaWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMud2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLndpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgd2luID0gb3B0aW9ucy53aW5kb3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZW5kKHdpbiwgbmFtZSwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2RyaXZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9saWIvaW5kZXguanNcIiksIF9nbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZ2xvYmFsLmpzXCIpO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwucmVxdWVzdFByb21pc2VzID0gX2dsb2JhbC5nbG9iYWwucmVxdWVzdFByb21pc2VzIHx8IG5ldyBfc3JjLldlYWtNYXAoKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy5uYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSwgdGFyZ2V0V2luZG93ID0gdm9pZCAwLCBkb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBvcHRpb25zLndpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy53aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbCkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy53aW5kb3cgXCIgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9ucy53aW5kb3cpICsgXCIgdG8gYmUgYSB2YWxpZCBlbGVtZW50IGlkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiaWZyYW1lXCIgIT09IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb3B0aW9ucy53aW5kb3cgXCIgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob3B0aW9ucy53aW5kb3cpICsgXCIgdG8gYmUgYW4gaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbC5jb250ZW50V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJJZnJhbWUgbXVzdCBoYXZlIGNvbnRlbnRXaW5kb3cuICBNYWtlIHN1cmUgaXQgaGFzIGEgc3JjIGF0dHJpYnV0ZSBhbmQgaXMgaW4gdGhlIERPTS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRXaW5kb3cgPSBlbC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMud2luZG93IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImlmcmFtZVwiICE9PSBvcHRpb25zLndpbmRvdy50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMud2luZG93IFwiICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMud2luZG93KSArIFwiIHRvIGJlIGFuIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpbmRvdyAmJiAhb3B0aW9ucy53aW5kb3cuY29udGVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiSWZyYW1lIG11c3QgaGF2ZSBjb250ZW50V2luZG93LiAgTWFrZSBzdXJlIGl0IGhhcyBhIHNyYyBhdHRyaWJ1dGUgYW5kIGlzIGluIHRoZSBET00uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy53aW5kb3cgJiYgb3B0aW9ucy53aW5kb3cuY29udGVudFdpbmRvdyAmJiAodGFyZ2V0V2luZG93ID0gb3B0aW9ucy53aW5kb3cuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB0YXJnZXRXaW5kb3cgPSBvcHRpb25zLndpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRXaW5kb3cpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMud2luZG93IHRvIGJlIGEgd2luZG93IG9iamVjdCwgaWZyYW1lLCBvciBpZnJhbWUgZWxlbWVudCBpZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW4gPSB0YXJnZXRXaW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluIHx8IF9jb25mLkNPTlNUQU5UUy5XSUxEQ0FSRDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBvcHRpb25zLm5hbWUgKyBcIl9cIiArICgwLCBfbGliLnVuaXF1ZUlEKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMzLmlzV2luZG93Q2xvc2VkKSh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJUYXJnZXQgd2luZG93IGlzIGNsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1Jlc3VsdCA9ICExLCByZXF1ZXN0UHJvbWlzZXMgPSBfZ2xvYmFsLmdsb2JhbC5yZXF1ZXN0UHJvbWlzZXMuZ2V0KHdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdFByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nbG9iYWwuZ2xvYmFsLnJlcXVlc3RQcm9taXNlcy5zZXQod2luLCByZXF1ZXN0UHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0UHJvbWlzZSA9IF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMzLmlzQW5jZXN0b3IpKHdpbmRvdywgd2luKSkgcmV0dXJuICgwLCBfbGliLm9uQ2hpbGRXaW5kb3dSZWFkeSkod2luLCBvcHRpb25zLnRpbWVvdXQgfHwgX2NvbmYuQ09ORklHLkNISUxEX1dJTkRPV19USU1FT1VUKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fSkub3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfbGliLmlzUmVnZXgpKGRvbWFpbikgJiYgIW9yaWdpbikgcmV0dXJuICgwLCBfbGliLnNheUhlbGxvKSh3aW4pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9KS5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9saWIuaXNSZWdleCkoZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMzLm1hdGNoRG9tYWluKShkb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB3aW5kb3cgZG9tYWluIFwiICsgb3JpZ2luICsgXCIgZG9lcyBub3QgbWF0Y2ggcmVnZXg6IFwiICsgZG9tYWluLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBkb21haW4gJiYgIUFycmF5LmlzQXJyYXkoZG9tYWluKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGRvbWFpbiB0byBiZSBhIHN0cmluZyBvciBhcnJheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY3R1YWxEb21haW4gPSBkb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VMaXN0ZW5lciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZmlyZUFuZEZvcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZUxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBhY3R1YWxEb21haW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25kOiBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Jlc3VsdCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UHJvbWlzZXMuc3BsaWNlKHJlcXVlc3RQcm9taXNlcy5pbmRleE9mKHJlcXVlc3RQcm9taXNlLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2RyaXZlcnMuYWRkUmVzcG9uc2VMaXN0ZW5lcikoaGFzaCwgcmVzcG9uc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZHJpdmVycy5zZW5kTWVzc2FnZSkod2luLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25mLkNPTlNUQU5UUy5QT1NUX01FU1NBR0VfVFlQRS5SRVFVRVNULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IG9wdGlvbnMuZmlyZUFuZEZvcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGFjdHVhbERvbWFpbikuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maXJlQW5kRm9yZ2V0KSByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2tUaW1lb3V0ID0gX2NvbmYuQ09ORklHLkFDS19USU1FT1VULCByZXNUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IF9jb25mLkNPTkZJRy5SRVNfVElNRU9VVCwgY3ljbGVUaW1lID0gMTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gY3ljbGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9zcmMzLmlzV2luZG93Q2xvc2VkKSh3aW4pKSByZXR1cm4gcmVzcG9uc2VMaXN0ZW5lci5hY2sgPyByZWplY3QobmV3IEVycm9yKFwiV2luZG93IGNsb3NlZCBmb3IgXCIgKyBuYW1lICsgXCIgYmVmb3JlIHJlc3BvbnNlXCIpKSA6IHJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgY2xvc2VkIGZvciBcIiArIG5hbWUgKyBcIiBiZWZvcmUgYWNrXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFja1RpbWVvdXQgPSBNYXRoLm1heChhY2tUaW1lb3V0IC0gY3ljbGVUaW1lLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSByZXNUaW1lb3V0ICYmIChyZXNUaW1lb3V0ID0gTWF0aC5tYXgocmVzVGltZW91dCAtIGN5Y2xlVGltZSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTGlzdGVuZXIuYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSByZXNUaW1lb3V0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGVUaW1lID0gTWF0aC5taW4ocmVzVGltZW91dCwgMmUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGFja1RpbWVvdXQpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYWNrIGZvciBwb3N0TWVzc2FnZSBcIiArIG5hbWUgKyBcIiBpbiBcIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjMy5nZXREb21haW4pKCkgKyBcIiBpbiBcIiArIF9jb25mLkNPTkZJRy5BQ0tfVElNRU9VVCArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgwID09PSByZXNUaW1lb3V0KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZvciBwb3N0TWVzc2FnZSBcIiArIG5hbWUgKyBcIiBpbiBcIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3JjMy5nZXREb21haW4pKCkgKyBcIiBpbiBcIiArIChvcHRpb25zLnRpbWVvdXQgfHwgX2NvbmYuQ09ORklHLlJFU19USU1FT1VUKSArIFwibXNcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjeWNsZSwgY3ljbGVUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGN5Y2xlVGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RQcm9taXNlLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9kcml2ZXJzLm1hcmtSZXNwb25zZUxpc3RlbmVyRXJyb3JlZCkoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2RyaXZlcnMuZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcikoaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0UHJvbWlzZXMucHVzaChyZXF1ZXN0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zZW5kKHdpbmRvdywgbmFtZSwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkud2luZG93ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuc2VuZCA9IF9zZW5kO1xuICAgICAgICAgICAgX2dsb2JhbC5nbG9iYWwuc2VuZCA9IF9zZW5kO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9jb25maWcuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5DT05TVEFOVFMgPSBleHBvcnRzLkNPTkZJRyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfY29uZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9jb25mL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ09ORklHXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmYuQ09ORklHO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ09OU1RBTlRTXCIsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmYuQ09OU1RBTlRTO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwb3J0cy5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvd1tfY29uZi5DT05TVEFOVFMuV0lORE9XX1BST1BTLlBPU1RST0JPVF07XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIF9kcml2ZXJzLm1lc3NhZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2RyaXZlcnMvaW5kZXguanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvcHVibGljL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9jbGllbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvcHVibGljL2NsaWVudC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jbGllbnQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NsaWVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfc2VydmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL3B1YmxpYy9zZXJ2ZXIuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfc2VydmVyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZXJ2ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2NvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9wdWJsaWMvY29uZmlnLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbmZpZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIGV4cG9ydHMucGFyZW50ID0gKDAsIF9zcmMuZ2V0QW5jZXN0b3IpKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvcHVibGljL3NlcnZlci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLm9uID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubGlzdGVuID0gbGlzdGVuO1xuICAgICAgICAgICAgZXhwb3J0cy5vbmNlID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgaGFuZGxlciA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyIHx8IG9wdGlvbnMuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gb3B0aW9ucy5lcnJvckhhbmRsZXIsIHByb21pc2UgPSBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAob3B0aW9ucyA9IG9wdGlvbnMgfHwge30pLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2UgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHJldHVybiBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlcikgcmV0dXJuIGVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLCBvbmNlTGlzdGVuZXIgPSBsaXN0ZW4ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwgPSBvbmNlTGlzdGVuZXIuY2FuY2VsO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfb24obmFtZSwgb3B0aW9ucywgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2xpYi9pbmRleC5qc1wiKSwgX2RyaXZlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvZHJpdmVycy9pbmRleC5qc1wiKSwgX2NvbmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvY29uZi9pbmRleC5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9wb3N0LXJvYm90L3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW4ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLm5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMuaGFuZGxlclwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSwgd2luID0gb3B0aW9ucy53aW5kb3csIGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluLCBsaXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IG9wdGlvbnMuaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3I6IG9wdGlvbnMuZXJyb3JIYW5kbGVyIHx8IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4gfHwgX2NvbmYuQ09OU1RBTlRTLldJTERDQVJELFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgICAgICAgfSwgcmVxdWVzdExpc3RlbmVyID0gKDAsIF9kcml2ZXJzLmFkZFJlcXVlc3RMaXN0ZW5lcikoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB3aW46IHdpbixcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cbiAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9oYW5kbGVyID0gbGlzdGVuZXJPcHRpb25zLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyT3B0aW9ucy5oYW5kbGVyID0gKDAsIF9saWIub25jZSkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2hhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lck9wdGlvbnMud2luZG93ICYmIG9wdGlvbnMuZXJyb3JPbkNsb3NlKSB2YXIgaW50ZXJ2YWwgPSAoMCwgX2xpYi5zYWZlSW50ZXJ2YWwpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2luICYmIFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IHdpbiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbikpICYmICgwLCBfc3JjLmlzV2luZG93Q2xvc2VkKSh3aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyT3B0aW9ucy5oYW5kbGVFcnJvcihuZXcgRXJyb3IoXCJQb3N0IG1lc3NhZ2UgdGFyZ2V0IHdpbmRvdyBpcyBjbG9zZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gX29uKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChvcHRpb25zID0gb3B0aW9ucyB8fCB7fSkubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oYW5kbGVyID0gaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbihvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMub24gPSBfb247XG4gICAgICAgICAgICBfZ2xvYmFsLmdsb2JhbC5vbiA9IF9vbjtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBjYWNoZWRTZXRUaW1lb3V0LCBjYWNoZWRDbGVhclRpbWVvdXQsIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuICAgICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgY2xlYXJUaW1lb3V0ID8gY2xlYXJUaW1lb3V0IDogZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVudFF1ZXVlLCBxdWV1ZSA9IFtdLCBkcmFpbmluZyA9ICExLCBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWluaW5nICYmIGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFpbmluZyA9ICExO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVldWUubGVuZ3RoID8gcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKSA6IHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUubGVuZ3RoICYmIGRyYWluUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgICAgICAgICAgICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWluaW5nID0gITA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDsgbGVuOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOysrcXVldWVJbmRleCA8IGxlbjsgKSBjdXJyZW50UXVldWUgJiYgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRyYWluaW5nID0gITE7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0odGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uKGZ1bikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgICAgICAgICAgICAgIDEgIT09IHF1ZXVlLmxlbmd0aCB8fCBkcmFpbmluZyB8fCBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnVuID0gZnVuO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3MudGl0bGUgPSBcImJyb3dzZXJcIjtcbiAgICAgICAgICAgIHByb2Nlc3MuYnJvd3NlciA9ICEwO1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYgPSB7fTtcbiAgICAgICAgICAgIHByb2Nlc3MuYXJndiA9IFtdO1xuICAgICAgICAgICAgcHJvY2Vzcy52ZXJzaW9uID0gXCJcIjtcbiAgICAgICAgICAgIHByb2Nlc3MudmVyc2lvbnMgPSB7fTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICAgICAgICAgICAgcHJvY2Vzcy5vbiA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbiAgICAgICAgICAgIHByb2Nlc3Mub25jZSA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLm9mZiA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbiAgICAgICAgICAgIHByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbiAgICAgICAgICAgIHByb2Nlc3MuZW1pdCA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG4gICAgICAgICAgICBwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuICAgICAgICAgICAgcHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgKGZ1bmN0aW9uKF9fd2VicGFja19hbWRfb3B0aW9uc19fKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiAgICAgICAgICAgIH0pLmNhbGwoZXhwb3J0cywge30pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIHZhciBnLCBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMCwgZXZhbCkoXCJ0aGlzXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiB3aW5kb3cgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSAmJiAoZyA9IHdpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGc7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5wYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGUuY2hpbGRyZW4gfHwgKG1vZHVsZS5jaGlsZHJlbiA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUubDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUuaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9leGNlcHRpb25zLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZGlzcGF0Y2hQb3NzaWJseVVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0xICE9PSAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuZGlzcGF0Y2hlZEVycm9ycy5pbmRleE9mKGVycikpIHJldHVybjtcbiAgICAgICAgICAgICAgICAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuZGlzcGF0Y2hlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLnBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmxlbmd0aDsgaisrKSAoMCwgXG4gICAgICAgICAgICAgICAgX2dsb2JhbC5nZXRHbG9iYWwpKCkucG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnNbal0oZXJyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm9uUG9zc2libHlVbmhhbmRsZWRFeGNlcHRpb24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLnBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5zcGxpY2UoKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLnBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLmluZGV4T2YoaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvZ2xvYmFsLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICAoZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICAgICAgZXhwb3J0cy5nZXRHbG9iYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2IgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cpIGdsb2IgPSB3aW5kb3c7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2xvYmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FuIG5vdCBmaW5kIGdsb2JhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2IgPSBnbG9iYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHphbGdvR2xvYmFsID0gZ2xvYi5fX3phbGdvcHJvbWlzZV9fID0gZ2xvYi5fX3phbGdvcHJvbWlzZV9fIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB6YWxnb0dsb2JhbC5mbHVzaFByb21pc2VzID0gemFsZ29HbG9iYWwuZmx1c2hQcm9taXNlcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgemFsZ29HbG9iYWwuYWN0aXZlQ291bnQgPSB6YWxnb0dsb2JhbC5hY3RpdmVDb3VudCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB6YWxnb0dsb2JhbC5wb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycyA9IHphbGdvR2xvYmFsLnBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICB6YWxnb0dsb2JhbC5kaXNwYXRjaGVkRXJyb3JzID0gemFsZ29HbG9iYWwuZGlzcGF0Y2hlZEVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHphbGdvR2xvYmFsO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXCIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3Byb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvcHJvbWlzZS5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlphbGdvUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wcm9taXNlLlphbGdvUHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9wcm9taXNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuWmFsZ29Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy91dGlscy5qc1wiKSwgX2V4Y2VwdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvZXhjZXB0aW9ucy5qc1wiKSwgX2dsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICB2YXIgWmFsZ29Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gWmFsZ29Qcm9taXNlKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgWmFsZ29Qcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9ICExO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0ID0gdm9pZCAwLCBfZXJyb3IgPSB2b2lkIDAsIHJlc29sdmVkID0gITEsIHJlamVjdGVkID0gITEsIGlzQXN5bmMgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmMpIF90aGlzLnJlc29sdmUocmVzKTsgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdCA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVqZWN0KGVycik7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FzeW5jID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA/IHRoaXMucmVzb2x2ZShfcmVzdWx0KSA6IHJlamVjdGVkICYmIHRoaXMucmVqZWN0KF9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF91dGlscy5pc1Byb21pc2UpKHJlc3VsdCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggYW5vdGhlciBwcm9taXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfdXRpbHMuaXNQcm9taXNlKShlcnJvcikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVqZWN0IHByb21pc2Ugd2l0aCBhbm90aGVyIHByb21pc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZXJyID0gZXJyb3IgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlcnJvci50b1N0cmluZyA/IGVycm9yLnRvU3RyaW5nKCkgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByZWplY3QgdG8gYmUgY2FsbGVkIHdpdGggRXJyb3IsIGdvdCBcIiArIF9lcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCB8fCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmVycm9ySGFuZGxlZCB8fCAoMCwgX2V4Y2VwdGlvbnMuZGlzcGF0Y2hQb3NzaWJseVVuaGFuZGxlZEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnByb3RvdHlwZS5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JIYW5kbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXMsIGRpc3BhdGNoaW5nID0gdGhpcy5kaXNwYXRjaGluZywgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVkLCByZWplY3RlZCA9IHRoaXMucmVqZWN0ZWQsIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNwYXRjaGluZyAmJiAocmVzb2x2ZWQgfHwgcmVqZWN0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoaW5nID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuYWN0aXZlQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sb29wID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaGFuZGxlcnMkaSA9IGhhbmRsZXJzW2ldLCBvblN1Y2Nlc3MgPSBfaGFuZGxlcnMkaS5vblN1Y2Nlc3MsIG9uRXJyb3IgPSBfaGFuZGxlcnMkaS5vbkVycm9yLCBwcm9taXNlID0gX2hhbmRsZXJzJGkucHJvbWlzZSwgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gb25TdWNjZXNzID8gb25TdWNjZXNzKF90aGlzMy52YWx1ZSkgOiBfdGhpczMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KF90aGlzMy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvbkVycm9yKF90aGlzMy5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFphbGdvUHJvbWlzZSAmJiAocmVzdWx0LnJlc29sdmVkIHx8IHJlc3VsdC5yZWplY3RlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBwcm9taXNlLnJlamVjdChyZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JIYW5kbGVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlICgwLCBfdXRpbHMuaXNQcm9taXNlKShyZXN1bHQpID8gcmVzdWx0IGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlICYmIChyZXN1bHQucmVzb2x2ZWQgfHwgcmVzdWx0LnJlamVjdGVkKSA/IHJlc3VsdC5yZXNvbHZlZCA/IHByb21pc2UucmVzb2x2ZShyZXN1bHQudmFsdWUpIDogcHJvbWlzZS5yZWplY3QocmVzdWx0LmVycm9yKSA6IHJlc3VsdC50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IHByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykgX2xvb3AoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9ICExO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmFjdGl2ZUNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAwID09PSAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuYWN0aXZlQ291bnQgJiYgWmFsZ29Qcm9taXNlLmZsdXNoUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvblN1Y2Nlc3MgJiYgIW9uU3VjY2Vzcy5jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlLnRoZW4gZXhwZWN0ZWQgYSBmdW5jdGlvbiBmb3Igc3VjY2VzcyBoYW5kbGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob25FcnJvciAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRXJyb3IgJiYgIW9uRXJyb3IuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KGhhbmRsZXIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KGhhbmRsZXIpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odGltZSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZCB8fCB0aGlzLnJlamVjdGVkKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0LnJlc29sdmVkIHx8IF90aGlzNC5yZWplY3RlZCB8fCBfdGhpczQucmVqZWN0KGVyciB8fCBuZXcgRXJyb3IoXCJQcm9taXNlIHRpbWVkIG91dCBhZnRlciBcIiArIHRpbWUgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBQcm9taXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ291bGQgbm90IGZpbmQgUHJvbWlzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlID8gdmFsdWUgOiAoMCwgX3V0aWxzLmlzUHJvbWlzZSkodmFsdWUpID8gbmV3IFphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pIDogbmV3IFphbGdvUHJvbWlzZSgpLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKCkucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2UoKSwgY291bnQgPSBwcm9taXNlcy5sZW5ndGgsIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2xvb3AyID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb20gPSBwcm9taXNlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb20ucmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb20udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghKDAsIF91dGlscy5pc1Byb21pc2UpKHByb20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHByb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlc29sdmUocHJvbSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAgPT09IChjb3VudCAtPSAxKSAmJiBwcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIF9sb29wMihpKTtcbiAgICAgICAgICAgICAgICAgICAgMCA9PT0gY291bnQgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS5oYXNoID0gZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChPYmplY3Qua2V5cyhwcm9taXNlcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5yZXNvbHZlKHByb21pc2VzW2tleV0pLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UubWFwID0gZnVuY3Rpb24oaXRlbXMsIG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLmFsbChpdGVtcy5tYXAobWV0aG9kKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2Uub25Qb3NzaWJseVVuaGFuZGxlZEV4Y2VwdGlvbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZXhjZXB0aW9ucy5vblBvc3NpYmx5VW5oYW5kbGVkRXhjZXB0aW9uKShoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFphbGdvUHJvbWlzZS50cnkgPSBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1ldGhvZC5hcHBseShjb250ZXh0LCBhcmdzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24oX2RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgX2RlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UuaXNQcm9taXNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB8fCAoMCwgX3V0aWxzLmlzUHJvbWlzZSkodmFsdWUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFphbGdvUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuZmx1c2hQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICAwID09PSAoMCwgX2dsb2JhbC5nZXRHbG9iYWwpKCkuYWN0aXZlQ291bnQgJiYgWmFsZ29Qcm9taXNlLmZsdXNoUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBaYWxnb1Byb21pc2UuZmx1c2hRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXNUb0ZsdXNoID0gKDAsIF9nbG9iYWwuZ2V0R2xvYmFsKSgpLmZsdXNoUHJvbWlzZXM7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfZ2xvYmFsLmdldEdsb2JhbCkoKS5mbHVzaFByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBwcm9taXNlc1RvRmx1c2gsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZi5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2U7XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICBleHBvcnRzLlphbGdvUHJvbWlzZSA9IFphbGdvUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy91dGlscy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFByb21pc2UgJiYgaXRlbSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiAhMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiB3aW5kb3cuV2luZG93ICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuV2luZG93KSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgd2luZG93LmNvbnN0cnVjdG9yICYmIGl0ZW0gaW5zdGFuY2VvZiB3aW5kb3cuY29uc3RydWN0b3IpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF90b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiW29iamVjdCBXaW5kb3ddXCIgPT09IG5hbWUgfHwgXCJbb2JqZWN0IGdsb2JhbF1cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgRE9NV2luZG93XVwiID09PSBuYW1lKSByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50aGVuKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvYmFzZS5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLkJhc2VDb21wb25lbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIik7XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIHZhciBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIGV4cG9ydHMuQmFzZUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VDb21wb25lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIEJhc2VDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuID0gKG9iaiA9IHRoaXMsIHRhc2tzID0gW10sIGNsZWFuZWQgPSAhMSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihuYW1lLCBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFuZWQpIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24obmFtZSwgbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCI8YW5vbnltb3VzLWNsZWFudXAtaGFuZGxlcj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbWV0aG9kKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdG8gYmUgcGFzc2VkIGZ1bmN0aW9uIHRvIGNsZWFuLnJlZ2lzdGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWQgPyBtZXRob2QoKSA6IHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kICYmIG1ldGhvZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVGFza3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHRhc2tzLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXRlbS5jb21wbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7dGFza3MubGVuZ3RoOyApIHJlc3VsdHMucHVzaCh0YXNrcy5wb3AoKS5ydW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIF9pdGVyYXRvciA9IHRhc2tzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm5hbWUgPT09IG5hbWUgJiYgcmVzdWx0cy5wdXNoKGl0ZW0ucnVuKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oX2xpYi5ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmosIHRhc2tzLCBjbGVhbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gKDAsIF9saWIuZXZlbnRFbWl0dGVyKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5hZGRQcm9wID0gZnVuY3Rpb24ob3B0aW9ucywgbmFtZSwgZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmNvcHlQcm9wKShvcHRpb25zLCB0aGlzLCBuYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnQub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJhc2VDb21wb25lbnQucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBsaXN0ZW5lcnMgdG8gYmUgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBlcnJvciB0byBiZSBpbXBsZW1lbnRlZCAtIGdvdCBcIiArICgwLCBfbGliLnN0cmluZ2lmeUVycm9yKShlcnIpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIEJhc2VDb21wb25lbnQucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uKHdpbiwgZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2luKSB0aHJvdyB0aGlzLmNvbXBvbmVudC5jcmVhdGVFcnJvcihcIndpbmRvdyB0byBsaXN0ZW4gdG8gbm90IHNldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb21haW4pIHRocm93IG5ldyBFcnJvcihcIk11c3QgcGFzcyBkb21haW4gdG8gbGlzdGVuIHRvXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycygpLCBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyTmFtZSA9IF9yZWYyLCBuYW1lID0gbGlzdGVuZXJOYW1lLnJlcGxhY2UoL156b2lkXy8sIFwiXCIpLCBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lciA9ICgwLCBfc3JjMi5vbikobGlzdGVuZXJOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogd2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiBlcnJvckhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjMuc291cmNlLCBkYXRhID0gX3JlZjMuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmxvZyhcImxpc3RlbmVyX1wiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnNbbGlzdGVuZXJOYW1lXS5jYWxsKF90aGlzLCBzb3VyY2UsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBlcnJvckxpc3RlbmVyID0gKDAsIF9zcmMyLm9uKShsaXN0ZW5lck5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcjogZXJyb3JIYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IF9yZWY0Lm9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmxvZ0Vycm9yKFwidW5leHBlY3RlZF9saXN0ZW5lcl9cIiArIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW4udG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5hbWUgKyBcIiBtZXNzYWdlIGZyb20gZG9tYWluIFwiICsgb3JpZ2luICsgXCIgLS0gZXhwZWN0ZWQgbWVzc2FnZSBmcm9tIFwiICsgZG9tYWluLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBfaXRlcmF0b3IyID0gT2JqZWN0LmtleXMobGlzdGVuZXJzKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJicmVha1wiID09PSBfbG9vcCgpKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VDb21wb25lbnQ7XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2NoaWxkL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuQ2hpbGRDb21wb25lbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9LCBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCIpLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIiksIF93aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L3dpbmRvdy5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIiksIF9wcm9wcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvY2hpbGQvcHJvcHMuanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLkNoaWxkQ29tcG9uZW50ID0gZnVuY3Rpb24oX0Jhc2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0oQ2hpbGRDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBDaGlsZENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgQ2hpbGRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQmFzZUNvbXBvbmVudC5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmhhc1ZhbGlkUGFyZW50RG9tYWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yKG5ldyBfZXJyb3IuUmVuZGVyRXJyb3IoXCJDYW4gbm90IGJlIHJlbmRlcmVkIGJ5IGRvbWFpbjogXCIgKyBfdGhpcy5nZXRQYXJlbnREb21haW4oKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQubG9nKFwiY29uc3RydWN0X2NoaWxkXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblByb3BIYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYXJyID0gWyBfdGhpcy5jb21wb25lbnQsIHdpbmRvdyBdLCBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaXRlbSA9IF9hcnJbX2ldLCBfYXJyMiA9IFsgWyBcInhjaGlsZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IF0sIFsgXCJ4cHJvcHNcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBdIF0sIF9sb29wMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYXJyMiRfaSA9IF9hcnIyW19pMl0sIG5hbWUgPSBfYXJyMiRfaVswXSwgZ2V0dGVyID0gX2FycjIkX2lbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0ZW0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzIHx8IF90aGlzLnNldFByb3BzKF90aGlzLmdldEluaXRpYWxQcm9wcygpLCAoMCwgX3dpbmRvdy5nZXRQYXJlbnREb21haW4pKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtW25hbWVdID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2kyID0gMDsgX2kyIDwgX2FycjIubGVuZ3RoOyBfaTIrKykgX2xvb3AyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9pID0gMDsgX2kgPCBfYXJyLmxlbmd0aDsgX2krKykgX2xvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmxvZyhcImluaXRfY2hpbGRcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFdpbmRvd3MoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuRm9yUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uSW5pdCA9IF90aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5JTklULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBfdGhpcy5leHBvcnRzKClcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gX3JlZi5vcmlnaW4sIGRhdGEgPSBfcmVmLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0UHJvcHMoZGF0YS5wcm9wcywgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLndhdGNoRm9yUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmxpc3RlbkZvclJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lmxpc3RlbkZvclJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuT05SRVNJWkUsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5PTlJFU0laRSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogITBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuaGFzVmFsaWRQYXJlbnREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc3JjLm1hdGNoRG9tYWluKSh0aGlzLmNvbXBvbmVudC5hbGxvd2VkUGFyZW50RG9tYWlucywgdGhpcy5nZXRQYXJlbnREb21haW4oKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkluaXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3dpbmRvdy5nZXRQYXJlbnREb21haW4pKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUub25Qcm9wcyA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByb3BIYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmdldFBhcmVudENvbXBvbmVudFdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF93aW5kb3cuZ2V0UGFyZW50Q29tcG9uZW50V2luZG93KSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmdldFBhcmVudFJlbmRlcldpbmRvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF93aW5kb3cuZ2V0UGFyZW50UmVuZGVyV2luZG93KSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmdldEluaXRpYWxQcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcywgY29tcG9uZW50TWV0YSA9ICgwLCBfd2luZG93LmdldENvbXBvbmVudE1ldGEpKCksIHByb3BzID0gY29tcG9uZW50TWV0YS5wcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnR5cGUgPT09IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5SQVcpIHByb3BzID0gcHJvcHMudmFsdWU7IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnR5cGUgIT09IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5VSUQpIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBwcm9wcyB0eXBlOiBcIiArIHByb3BzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbXBvbmVudFdpbmRvdyA9ICgwLCBfd2luZG93LmdldFBhcmVudENvbXBvbmVudFdpbmRvdykoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9zcmMuaXNTYW1lRG9tYWluKShwYXJlbnRDb21wb25lbnRXaW5kb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZmlsZTpcIiA9PT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGdldCBwcm9wcyBmcm9tIGZpbGU6Ly8gZG9tYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmVudCBjb21wb25lbnQgd2luZG93IGlzIG9uIGEgZGlmZmVyZW50IGRvbWFpbiAtIGV4cGVjdGVkIFwiICsgKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zcmMuZ2V0RG9tYWluKSgpICsgXCIgLSBjYW4gbm90IHJldHJpZXZlIHByb3BzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdsb2JhbCA9ICgwLCBfbGliLmdsb2JhbEZvcikocGFyZW50Q29tcG9uZW50V2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZ2xvYmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgZ2xvYmFsIGZvciBwYXJlbnQgY29tcG9uZW50IC0gY2FuIG5vdCByZXRyaWV2ZSBwcm9wc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzID0gSlNPTi5wYXJzZShnbG9iYWwucHJvcHNbY29tcG9uZW50TWV0YS51aWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BzKSB0aHJvdyBuZXcgRXJyb3IoXCJJbml0aWFsIHByb3BzIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLmRlc2VyaWFsaXplRnVuY3Rpb25zKShwcm9wcywgZnVuY3Rpb24oX3JlZjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdWxsS2V5ID0gX3JlZjIuZnVsbEtleSwgc2VsZiA9IF9yZWYyLnNlbGYsIGFyZ3MgPSBfcmVmMi5hcmdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5vbkluaXQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuYyA9ICgwLCBfbGliLmdldCkoX3RoaXMzLnByb3BzLCBmdWxsS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBmdW5jKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXCIgKyBmdWxsS2V5ICsgXCIgdG8gYmUgZnVuY3Rpb24sIGdvdCBcIiArICh2b2lkIDAgPT09IGZ1bmMgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihmdW5jKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24ocHJvcHMsIG9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdKSB8fCBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSB0aGlzLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplZFByb3BzID0gKDAsIF9wcm9wcy5ub3JtYWxpemVDaGlsZFByb3BzKSh0aGlzLmNvbXBvbmVudCwgcHJvcHMsIG9yaWdpbiwgcmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5leHRlbmQpKHRoaXMucHJvcHMsIG5vcm1hbGl6ZWRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubG9nTGV2ZWwgJiYgKDAsIF9saWIuc2V0TG9nTGV2ZWwpKHRoaXMucHJvcHMubG9nTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yID0gdGhpcy5vblByb3BIYW5kbGVycywgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pMyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzID0gX2l0ZXJhdG9yW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYzLmNhbGwodGhpcywgdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5zZW5kVG9QYXJlbnQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge30sIHBhcmVudFdpbmRvdyA9ICgwLCBcbiAgICAgICAgICAgICAgICAgICAgX3dpbmRvdy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cpKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGZpbmQgcGFyZW50IGNvbXBvbmVudCB3aW5kb3cgdG8gbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubG9nKFwic2VuZF90b19wYXJlbnRfXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfc3JjMi5zZW5kKShwYXJlbnRXaW5kb3csIG5hbWUsIGRhdGEsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogKDAsIF93aW5kb3cuZ2V0UGFyZW50RG9tYWluKSgpXG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5zZXRXaW5kb3dzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuX19hY3RpdmVab2lkQ29tcG9uZW50X18pIHRocm93IHRoaXMuY29tcG9uZW50LmNyZWF0ZUVycm9yKFwiQ2FuIG5vdCBhdHRhY2ggbXVsdGlwbGUgY29tcG9uZW50cyB0byB0aGUgc2FtZSB3aW5kb3dcIik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5fX2FjdGl2ZVpvaWRDb21wb25lbnRfXyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF93aW5kb3cuZ2V0UGFyZW50Q29tcG9uZW50V2luZG93KSgpKSB0aHJvdyB0aGlzLmNvbXBvbmVudC5jcmVhdGVFcnJvcihcIkNhbiBub3QgZmluZCBwYXJlbnQgd2luZG93XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50TWV0YSA9ICgwLCBfd2luZG93LmdldENvbXBvbmVudE1ldGEpKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnRNZXRhLnRhZyAhPT0gdGhpcy5jb21wb25lbnQudGFnKSB0aHJvdyB0aGlzLmNvbXBvbmVudC5jcmVhdGVFcnJvcihcIlBhcmVudCBpcyBcIiArIGNvbXBvbmVudE1ldGEudGFnICsgXCIgLSBjYW4gbm90IGF0dGFjaCBcIiArIHRoaXMuY29tcG9uZW50LnRhZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hGb3JDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5jaGVja0Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZUF1dG9SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiB7fSwgX3JlZjQkd2lkdGggPSBfcmVmNC53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWY0JHdpZHRoIHx8IF9yZWY0JHdpZHRoLCBfcmVmNCRoZWlnaHQgPSBfcmVmNC5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZjQkaGVpZ2h0IHx8IF9yZWY0JGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRvUmVzaXplID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXRjaEZvclJlc2l6ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmdldEF1dG9SZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gITEsIGhlaWdodCA9ICExLCBhdXRvUmVzaXplID0gdGhpcy5hdXRvUmVzaXplIHx8IHRoaXMuY29tcG9uZW50LmF1dG9SZXNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBhdXRvUmVzaXplID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXV0b1Jlc2l6ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IEJvb2xlYW4oYXV0b1Jlc2l6ZS53aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBCb29sZWFuKGF1dG9SZXNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdXRvUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gITA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogYXV0b1Jlc2l6ZS5lbGVtZW50ID8gKDAsIF9saWIuZ2V0RWxlbWVudCkoYXV0b1Jlc2l6ZS5lbGVtZW50KSA6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFICg5fDEwKVxcLi8pID8gZG9jdW1lbnQuYm9keSA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzLCBfZ2V0QXV0b1Jlc2l6ZSA9IHRoaXMuZ2V0QXV0b1Jlc2l6ZSgpLCB3aWR0aCA9IF9nZXRBdXRvUmVzaXplLndpZHRoLCBoZWlnaHQgPSBfZ2V0QXV0b1Jlc2l6ZS5oZWlnaHQsIGVsZW1lbnQgPSBfZ2V0QXV0b1Jlc2l6ZS5lbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHdpZHRoIHx8IGhlaWdodCkgJiYgdGhpcy5jb250ZXh0ICE9PSBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVAgJiYgIXRoaXMud2F0Y2hpbmdGb3JSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2F0Y2hpbmdGb3JSZXNpemUgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfbGliLmRvY3VtZW50UmVhZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIF9saWIuZGltZW5zaW9uc01hdGNoVmlld3BvcnQpKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSByZXR1cm4gX3RoaXM1LnJlc2l6ZVRvRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLmN5Y2xlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLm9uRGltZW5zaW9uc0NoYW5nZSkoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUucmVzaXplVG9FbGVtZW50KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVQcm9wczogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2V0UHJvcHMocHJvcHMsIF90aGlzNi5vcmlnaW4sICExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM3LmNvbXBvbmVudC5sb2coXCJyZXNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAoMCwgX2xpYi5zdHJpbmdpZnkpKHdpZHRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICgwLCBfbGliLnN0cmluZ2lmeSkoaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM3LmNvbnRleHQgIT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUCkgcmV0dXJuIF90aGlzNy5zZW5kVG9QYXJlbnQoX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuUkVTSVpFLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLnJlc2l6ZVRvRWxlbWVudCA9IGZ1bmN0aW9uKGVsLCBfcmVmNSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcywgd2lkdGggPSBfcmVmNS53aWR0aCwgaGVpZ2h0ID0gX3JlZjUuaGVpZ2h0LCBoaXN0b3J5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tlciA9ICgwLCBfbGliLnRyYWNrRGltZW5zaW9ucykoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBkaW1lbnNpb25zID0gdHJhY2tlci5jaGVjaygpLmRpbWVuc2lvbnMsIF9pdGVyYXRvcjIgPSBoaXN0b3J5LCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTQgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjYgPSBfaXRlcmF0b3IyW19pNCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k0ID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjYgPSBfaTQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSBfcmVmNiwgd2lkdGhNYXRjaCA9ICF3aWR0aCB8fCBzaXplLndpZHRoID09PSBkaW1lbnNpb25zLndpZHRoLCBoZWlnaHRNYXRjaCA9ICFoZWlnaHQgfHwgc2l6ZS5oZWlnaHQgPT09IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhNYXRjaCAmJiBoZWlnaHRNYXRjaCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBkaW1lbnNpb25zLmhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgucmVzaXplKHdpZHRoID8gZGltZW5zaW9ucy53aWR0aCA6IG51bGwsIGhlaWdodCA/IGRpbWVuc2lvbnMuaGVpZ2h0IDogbnVsbCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZXIuY2hlY2soKS5jaGFuZ2VkKSByZXR1cm4gcmVzaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFRvUGFyZW50KF9jb25zdGFudHMuUE9TVF9NRVNTQUdFLkhJREUpLnRoZW4oX2xpYi5ub29wKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENoaWxkQ29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5TSE9XKS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUudXNlckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5VU0VSX0NMT1NFRCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogX2NvbnN0YW50cy5DTE9TRV9SRUFTT05TLkNISUxEX0NBTEw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZyhcImNsb3NlX2NoaWxkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5DTE9TRSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuY2hlY2tDbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5DSEVDS19DTE9TRSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6ICEwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfY2xpZW50LmZsdXNoKSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDaGlsZENvbXBvbmVudC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubG9nKFwiZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ2hpbGRDb21wb25lbnQucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZEVycm9yID0gKDAsIF9saWIuc3RyaW5naWZ5RXJyb3IpKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZ0Vycm9yKFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHN0cmluZ2lmaWVkRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRUb1BhcmVudChfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHN0cmluZ2lmaWVkRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIENoaWxkQ29tcG9uZW50O1xuICAgICAgICAgICAgfShfYmFzZS5CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY2hpbGQvcHJvcHMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVDaGlsZFByb3AgPSBub3JtYWxpemVDaGlsZFByb3A7XG4gICAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZUNoaWxkUHJvcHMgPSBmdW5jdGlvbihjb21wb25lbnQsIHByb3BzLCBvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciByZXF1aXJlZCA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10pIHx8IGFyZ3VtZW50c1szXSwgcmVzdWx0ID0ge30sIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKHByb3BzKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXkgPSBfcmVmLCBwcm9wID0gY29tcG9uZW50LmdldFByb3AoX2tleSksIHZhbHVlID0gcHJvcHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCB8fCAhcHJvcC5zYW1lRG9tYWluIHx8IG9yaWdpbiA9PT0gKDAsIF9zcmMuZ2V0RG9tYWluKSh3aW5kb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbX2tleV0gPSBub3JtYWxpemVDaGlsZFByb3AoY29tcG9uZW50LCBwcm9wcywgX2tleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCAmJiBwcm9wLmFsaWFzICYmICFyZXN1bHRbcHJvcC5hbGlhc10gJiYgKHJlc3VsdFtwcm9wLmFsaWFzXSA9IHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWQpIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjb21wb25lbnQuZ2V0UHJvcE5hbWVzKCksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAocmVzdWx0W2tleV0gPSBub3JtYWxpemVDaGlsZFByb3AoY29tcG9uZW50LCBwcm9wcywga2V5LCBwcm9wc1trZXldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkUHJvcChjb21wb25lbnQsIHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBjb21wb25lbnQuZ2V0UHJvcChrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wID8gXCJmdW5jdGlvblwiID09IHR5cGVvZiBwcm9wLmNoaWxkRGVjb3JhdGUgPyBwcm9wLmNoaWxkRGVjb3JhdGUodmFsdWUpIDogdmFsdWUgOiBjb21wb25lbnQubG9vc2VQcm9wcyA/IHZhbHVlIDogdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5Db21wb25lbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2NsYXNzLCBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0sIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIiksIF9zcmMyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvYmFzZS5qc1wiKSwgX2NoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jaGlsZC9pbmRleC5qc1wiKSwgX3BhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCIpLCBfZGVsZWdhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2RlbGVnYXRlL2luZGV4LmpzXCIpLCBfd2luZG93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC93aW5kb3cuanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfaW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF92YWxpZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3ZhbGlkYXRlLmpzXCIpLCBfdGVtcGxhdGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvdGVtcGxhdGVzL2luZGV4LmpzXCIpLCBfcHJvcHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC9wcm9wcy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBkcml2ZXJzID0ge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXI6IF9pbmRleC5hbmd1bGFyLFxuICAgICAgICAgICAgICAgIGFuZ3VsYXIyOiBfaW5kZXguYW5ndWxhcjIsXG4gICAgICAgICAgICAgICAgZ2xpbW1lcjogX2luZGV4LmdsaW1tZXIsXG4gICAgICAgICAgICAgICAgcmVhY3Q6IF9pbmRleC5yZWFjdCxcbiAgICAgICAgICAgICAgICB2dWU6IF9pbmRleC52dWUsXG4gICAgICAgICAgICAgICAgc2NyaXB0OiBfaW5kZXguc2NyaXB0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGV4cG9ydHMuQ29tcG9uZW50ID0gKGZ1bmN0aW9uKHRhcmdldCwgcHJvcGVydHksIGRlY29yYXRvcnMsIGRlc2NyaXB0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZXNjLmVudW1lcmFibGUgPSAhIWRlc2MuZW51bWVyYWJsZTtcbiAgICAgICAgICAgICAgICBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7XG4gICAgICAgICAgICAgICAgKFwidmFsdWVcIiBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpICYmIChkZXNjLndyaXRhYmxlID0gITApO1xuICAgICAgICAgICAgICAgIGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbihkZXNjLCBkZWNvcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjO1xuICAgICAgICAgICAgICAgIH0sIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIHZvaWQgMCAhPT0gZGVzYy5pbml0aWFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy5pbml0aWFsaXplciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZGVzYy5pbml0aWFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKF9jbGFzcyA9IGZ1bmN0aW9uKF9CYXNlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgIWZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHN1cGVyQ2xhc3MgJiYgbnVsbCAhPT0gc3VwZXJDbGFzcykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyQ2xhc3MgJiYgKE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICB9KENvbXBvbmVudCwgX0Jhc2VDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IGZ1bmN0aW9uKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZikgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGUpKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwidGFnXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiZGVmYXVsdExvZ0xldmVsXCIsIFwiaW5mb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImFsbG93ZWRQYXJlbnREb21haW5zXCIsIF9jb25zdGFudHMuV0lMRENBUkQpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5zZXRMb2dMZXZlbCkoX3RoaXMuZGVmYXVsdExvZ0xldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbXBvbmVudC5jb21wb25lbnRzW190aGlzLnRhZ10pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29tcG9uZW50cyB3aXRoIHRoZSBzYW1lIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcIm5hbWVcIiwgX3RoaXMudGFnLnJlcGxhY2UoLy0vZywgXCJfXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnVpbHRpblByb3BzID0gKDAsIF9wcm9wcy5nZXRJbnRlcm5hbFByb3BzKSgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcyA9IG9wdGlvbnMucHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvcHMgfHwgKF90aGlzLmxvb3NlUHJvcHMgPSAhMCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJkaW1lbnNpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwic2Nyb2xsaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwibGlzdGVuRm9yUmVzaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwidmVyc2lvblwiLCBcImxhdGVzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImRlZmF1bHRFbnZcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJidWlsZFVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcInVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImRvbWFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImJyaWRnZVVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImJyaWRnZURvbWFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImF0dHJpYnV0ZXNcIiwge30pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiY29udGV4dHNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwOiAhMVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcImRlZmF1bHRDb250ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRQcm9wKG9wdGlvbnMsIFwiYXV0b1Jlc2l6ZVwiLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJjb250YWluZXJUZW1wbGF0ZVwiLCBfdGVtcGxhdGVzLmRlZmF1bHRDb250YWluZXJUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJwcmVyZW5kZXJUZW1wbGF0ZVwiLCBfdGVtcGxhdGVzLmRlZmF1bHRQcmVyZW5kZXJUZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZFByb3Aob3B0aW9ucywgXCJ2YWxpZGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkUHJvcChvcHRpb25zLCBcInVuc2FmZVJlbmRlclRvXCIsICExKTtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LmNvbXBvbmVudHNbX3RoaXMudGFnXSA9IF90aGlzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RlckRyaXZlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXJDaGlsZCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5saXN0ZW5EZWxlZ2F0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UHJvcE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLCBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyh0aGlzLmJ1aWx0aW5Qcm9wcyksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAtMSA9PT0gcHJvcHMuaW5kZXhPZihrZXkpICYmIHByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldFByb3AgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzW25hbWVdIHx8IHRoaXMuYnVpbHRpblByb3BzW25hbWVdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckRyaXZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcml2ZXJDYWNoZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IE9iamVjdC5rZXlzKGRyaXZlcnMpLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjIpLCBfaTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMCAhPT0gZHJpdmVyTmFtZS5pbmRleE9mKFwiX1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnbG9iID0gZHJpdmVyc1tkcml2ZXJOYW1lXS5nbG9iYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iICYmIHRoaXMuZHJpdmVyKGRyaXZlck5hbWUsIGdsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmRyaXZlciA9IGZ1bmN0aW9uKG5hbWUsIGRlcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRyaXZlcnNbbmFtZV0pIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRyaXZlciBmb3IgZnJhbWV3b3JrOiBcIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyaXZlckNhY2hlW25hbWVdIHx8ICh0aGlzLmRyaXZlckNhY2hlW25hbWVdID0gZHJpdmVyc1tuYW1lXS5yZWdpc3Rlcih0aGlzLCBkZXApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJpdmVyQ2FjaGVbbmFtZV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlZ2lzdGVyQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5pc0NoaWxkKCkpIHJldHVybiBuZXcgX2NoaWxkLkNoaWxkQ29tcG9uZW50KF90aGlzMik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5saXN0ZW5EZWxlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMub24pKF9jb25zdGFudHMuUE9TVF9NRVNTQUdFLkFMTE9XX0RFTEVHQVRFICsgXCJfXCIgKyB0aGlzLm5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMub24pKF9jb25zdGFudHMuUE9TVF9NRVNTQUdFLkRFTEVHQVRFICsgXCJfXCIgKyB0aGlzLm5hbWUsIGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gX3JlZjMuc291cmNlLCBvcmlnaW4gPSBfcmVmMy5vcmlnaW4sIGRhdGEgPSBfcmVmMy5kYXRhLCBkb21haW4gPSBfdGhpczMuZ2V0RG9tYWluKG51bGwsIGRhdGEuZW52IHx8IF90aGlzMy5kZWZhdWx0RW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGRvbWFpbiB0byBhbGxvdyByZW1vdGUgcmVuZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzMubWF0Y2hEb21haW4pKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZW5kZXIgZnJvbSBcIiArIG9yaWdpbiArIFwiIC0gZXhwZWN0ZWQgXCIgKyBkb21haW4udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGUgPSBfdGhpczMuZGVsZWdhdGUoc291cmNlLCBkYXRhLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IGRlbGVnYXRlLmdldE92ZXJyaWRlcyhkYXRhLmNvbnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5jYW5SZW5kZXJUbyA9IGZ1bmN0aW9uKHdpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zcmMuc2VuZCkod2luLCBfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5BTExPV19ERUxFR0FURSArIFwiX1wiICsgdGhpcy5uYW1lKS50aGVuKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRWYWxpZERvbWFpbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gKDAsIF9zcmMzLmdldERvbWFpbkZyb21VcmwpKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5kb21haW4gJiYgZG9tYWluID09PSB0aGlzLmRvbWFpbikgcmV0dXJuIGRvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW5zID0gdGhpcy5kb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWlucyAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBkb21haW5zID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZG9tYWlucykpICYmICEoZG9tYWlucyBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IE9iamVjdC5rZXlzKGRvbWFpbnMpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjUgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjUgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiICE9PSBfcmVmNSAmJiBkb21haW4gPT09IGRvbWFpbnNbX3JlZjVdKSByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXREb21haW4gPSBmdW5jdGlvbih1cmwsIGVudikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdGhpcy5nZXRGb3JFbnYodGhpcy5kb21haW4sIGVudik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHJldHVybiBkb21haW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gPSB0aGlzLmdldFZhbGlkRG9tYWluKHVybCkpIHJldHVybiBkb21haW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbnZVcmwgPSB0aGlzLmdldEZvckVudih0aGlzLnVybCwgZW52KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudlVybCA/ICgwLCBfc3JjMy5nZXREb21haW5Gcm9tVXJsKShlbnZVcmwpIDogdXJsID8gKDAsIF9zcmMzLmdldERvbWFpbkZyb21VcmwpKHVybCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEJyaWRnZVVybCA9IGZ1bmN0aW9uKGVudikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JFbnYodGhpcy5icmlkZ2VVcmwsIGVudik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEZvckVudiA9IGZ1bmN0aW9uKGl0ZW0sIGVudikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGl0ZW0gfHwgaXRlbSBpbnN0YW5jZW9mIFJlZ0V4cCkgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnYgfHwgKGVudiA9IHRoaXMuZGVmYXVsdEVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW52KSByZXR1cm4gZW52ICYmIFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IGl0ZW0gPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihpdGVtKSkgJiYgaXRlbVtlbnZdID8gaXRlbVtlbnZdIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldEJyaWRnZURvbWFpbiA9IGZ1bmN0aW9uKGVudikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnJpZGdlRG9tYWluID0gdGhpcy5nZXRGb3JFbnYodGhpcy5icmlkZ2VEb21haW4sIGVudik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmlkZ2VEb21haW4pIHJldHVybiBicmlkZ2VEb21haW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBicmlkZ2VVcmwgPSB0aGlzLmdldEJyaWRnZVVybChlbnYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnJpZGdlVXJsID8gKDAsIF9zcmMzLmdldERvbWFpbkZyb21VcmwpKGJyaWRnZVVybCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmdldFVybCA9IGZ1bmN0aW9uKGVudiwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuZ2V0Rm9yRW52KHRoaXMudXJsLCBlbnYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXJsKSByZXR1cm4gdXJsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5idWlsZFVybCkgcmV0dXJuIHRoaXMuYnVpbGRVcmwocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHVybFwiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuaXNab2lkQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3dpbmRvdy5pc1pvaWRDb21wb25lbnRXaW5kb3cpKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmlzQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfd2luZG93LmlzWm9pZENvbXBvbmVudFdpbmRvdykoKSAmJiAoMCwgX3dpbmRvdy5nZXRDb21wb25lbnRNZXRhKSgpLnRhZyA9PT0gdGhpcy50YWc7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJbXCIgKyAodGFnIHx8IHRoaXMudGFnKSArIFwiXSBcIiArIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24ocHJvcHMsIGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudCh0aGlzLCB0aGlzLmdldFJlbmRlckNvbnRleHQoY29udGV4dCwgZWxlbWVudCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUuZGVsZWdhdGUgPSBmdW5jdGlvbihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfZGVsZWdhdGUuRGVsZWdhdGVDb21wb25lbnQodGhpcywgc291cmNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUudmFsaWRhdGVSZW5kZXJDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiAhdGhpcy5jb250ZXh0c1tjb250ZXh0XSkgdGhyb3cgbmV3IEVycm9yKFwiW1wiICsgdGhpcy50YWcgKyBcIl0gQ2FuIG5vdCByZW5kZXIgdG8gXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50ICYmIGNvbnRleHQgPT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUUpIHRocm93IG5ldyBFcnJvcihcIltcIiArIHRoaXMudGFnICsgXCJdIENvbnRleHQgdHlwZSBcIiArIF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUUgKyBcIiByZXF1aXJlcyBhbiBlbGVtZW50IHNlbGVjdG9yXCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXREZWZhdWx0Q29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0Q29udGV4dCkgcmV0dXJuIHRoaXMuZGVmYXVsdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRzW19jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUVdKSByZXR1cm4gX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLklGUkFNRTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dHNbX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLlBPUFVQXSkgcmV0dXJuIF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBkZXRlcm1pbmUgZGVmYXVsdCBjb250ZXh0XCIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRSZW5kZXJDb250ZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmdldERlZmF1bHRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVSZW5kZXJDb250ZXh0KGNvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudChfdGhpczQsIF90aGlzNC5nZXRSZW5kZXJDb250ZXh0KG51bGwsIGVsZW1lbnQpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW5kZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJJZnJhbWUgPSBmdW5jdGlvbihwcm9wcywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9wYXJlbnQuUGFyZW50Q29tcG9uZW50KF90aGlzNSwgX3RoaXM1LmdldFJlbmRlckNvbnRleHQoX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLklGUkFNRSwgZWxlbWVudCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlcihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclBvcHVwID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMi5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudChfdGhpczYsIF90aGlzNi5nZXRSZW5kZXJDb250ZXh0KF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyVG8gPSBmdW5jdGlvbih3aW4sIHByb3BzLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3BhcmVudC5QYXJlbnRDb21wb25lbnQoX3RoaXM3LCBfdGhpczcuZ2V0UmVuZGVyQ29udGV4dChudWxsLCBlbGVtZW50KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyVG8od2luLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcklmcmFtZVRvID0gZnVuY3Rpb24od2luLCBwcm9wcywgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9wYXJlbnQuUGFyZW50Q29tcG9uZW50KF90aGlzOCwgX3RoaXM4LmdldFJlbmRlckNvbnRleHQoX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLklGUkFNRSwgZWxlbWVudCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnJlbmRlclRvKHdpbiwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJQb3B1cFRvID0gZnVuY3Rpb24od2luLCBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMyLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9wYXJlbnQuUGFyZW50Q29tcG9uZW50KF90aGlzOSwgX3RoaXM5LmdldFJlbmRlckNvbnRleHQoX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLlBPUFVQKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVuZGVyVG8od2luKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLnByZXJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBfcGFyZW50LlBhcmVudENvbXBvbmVudCh0aGlzLCB0aGlzLmdldFJlbmRlckNvbnRleHQobnVsbCwgZWxlbWVudCksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UucHJlZmV0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oaW5uZXJQcm9wcywgaW5uZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJQcm9wcyAmJiBpbnN0YW5jZS51cGRhdGVQcm9wcyhpbm5lclByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyKGlubmVyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG86IGZ1bmN0aW9uKHdpbiwgaW5uZXJQcm9wcywgaW5uZXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJQcm9wcyAmJiBpbnN0YW5jZS51cGRhdGVQcm9wcyhpbm5lclByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVuZGVyVG8od2luLCBpbm5lckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBodG1sKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5odG1sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCBodG1sKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuaHRtbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmluZm8pKHRoaXMubmFtZSwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnByb3RvdHlwZS5sb2dXYXJuaW5nID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIud2FybikodGhpcy5uYW1lLCBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24oZXZlbnQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuZXJyb3IpKHRoaXMubmFtZSwgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LmdldEJ5VGFnID0gZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c1t0YWddO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcbiAgICAgICAgICAgIH0oX2Jhc2UuQmFzZUNvbXBvbmVudCkpLnByb3RvdHlwZSwgXCJnZXRQcm9wTmFtZXNcIiwgWyBfbGliLm1lbW9pemUgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImdldFByb3BOYW1lc1wiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2NsYXNzKSkuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvcHJvcHMuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRJbnRlcm5hbFByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZW52OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRFbnY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHVpZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLnVuaXF1ZUlEKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW06ICEwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxvZ0xldmVsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRMb2dMZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EaXNwbGF5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBub29wOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vaXplOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkVudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBub29wOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2lmeTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kVG9DaGlsZDogITFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25SZW5kZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vb3A6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzaWZ5OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBub29wOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzaWZ5OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblRpbWVvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9pemU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzaWZ5OiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRUb0NoaWxkOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSByZXR1cm4gdGhpcy5wcm9wcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNpZnk6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRvQ2hpbGQ6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgdmFyIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL3R5cGVzLmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbXBvbmVudC9jb21wb25lbnQvdGVtcGxhdGVzL2NvbXBvbmVudC5qc3hcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5kZWZhdWx0UHJlcmVuZGVyVGVtcGxhdGUgPSBmdW5jdGlvbihfcmVmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGpzeERvbSA9IF9yZWYuanN4RG9tO1xuICAgICAgICAgICAgICAgIHJldHVybiBqc3hEb20oXCJodG1sXCIsIG51bGwsIGpzeERvbShcImhlYWRcIiwgbnVsbCwganN4RG9tKFwic3R5bGVcIiwgbnVsbCwgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sLCBib2R5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwaW5uZXIge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heC1oZWlnaHQ6IDYwdm1pbjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4LXdpZHRoOiA2MHZtaW47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogNDBweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQwcHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogNTAlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiA1MCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC01MCUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6LWluZGV4OiAxMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwaW5uZXIgLmxvYWRlciB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHJnYmEoMCwgMCwgMCwgLjIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDMzLCAxMjgsIDE5MiwgMC44KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiByb3RhdGlvbiAuN3MgaW5maW5pdGUgbGluZWFyO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBAa2V5ZnJhbWVzIHJvdGF0aW9uIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM1OWRlZylcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIFwiKSksIGpzeERvbShcImJvZHlcIiwgbnVsbCwganN4RG9tKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwic3Bpbm5lclwiXG4gICAgICAgICAgICAgICAgfSwganN4RG9tKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IFwibG9hZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImxvYWRlclwiXG4gICAgICAgICAgICAgICAgfSkpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC90ZW1wbGF0ZXMvY29udGFpbmVyLmpzeFwiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmRlZmF1bHRDb250YWluZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uKF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfcmVmLmlkLCB0YWcgPSBfcmVmLnRhZywgY29udGV4dCA9IF9yZWYuY29udGV4dCwgQ0xBU1MgPSBfcmVmLkNMQVNTLCBvdXRsZXQgPSBfcmVmLm91dGxldCwganN4RG9tID0gX3JlZi5qc3hEb20sIF9yZWYkZGltZW5zaW9ucyA9IF9yZWYuZGltZW5zaW9ucywgd2lkdGggPSBfcmVmJGRpbWVuc2lvbnMud2lkdGgsIGhlaWdodCA9IF9yZWYkZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzeERvbShcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IENMQVNTLlpPSUQgKyBcIiBcIiArIENMQVNTLlpPSUQgKyBcIi10YWctXCIgKyB0YWcgKyBcIiBcIiArIENMQVNTLlpPSUQgKyBcIi1jb250ZXh0LVwiICsgY29udGV4dFxuICAgICAgICAgICAgICAgIH0sIGpzeERvbShcInN0eWxlXCIsIG51bGwsIFwiXFxuICAgICAgICAgICAgICAgICAgICAjXCIgKyBpZCArIFwiLCAjXCIgKyBpZCArIFwiID4gLlwiICsgQ0xBU1MuT1VUTEVUICsgXCIge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIiArIHdpZHRoICsgXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIGhlaWdodCArIFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgI1wiICsgaWQgKyBcIiA+IC5cIiArIENMQVNTLk9VVExFVCArIFwiIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgI1wiICsgaWQgKyBcIiA+IC5cIiArIENMQVNTLk9VVExFVCArIFwiID4gaWZyYW1lIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgLjJzIGVhc2UtaW4tb3V0O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgI1wiICsgaWQgKyBcIiA+IC5cIiArIENMQVNTLk9VVExFVCArIFwiID4gaWZyYW1lLlwiICsgQ0xBU1MuVklTSUJMRSArIFwiIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgI1wiICsgaWQgKyBcIiA+IC5cIiArIENMQVNTLk9VVExFVCArIFwiID4gaWZyYW1lLlwiICsgQ0xBU1MuSU5WSVNJQkxFICsgXCIge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFwiKSwgb3V0bGV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L3BhcmVudC9pbmRleC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3RlbXBsYXRlcy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2NvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3RlbXBsYXRlcy9jb250YWluZXIuanN4XCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2NvbnRhaW5lcikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGFpbmVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC90ZW1wbGF0ZXMvY29tcG9uZW50LmpzeFwiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBvbmVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvY29tcG9uZW50L3ZhbGlkYXRlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWNyZWQgb3B0aW9ucyB0byBiZSBwYXNzZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRhZyB8fCAhb3B0aW9ucy50YWcubWF0Y2goL15bYS16MC05LV0rJC8pKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9wdGlvbnMudGFnOiBcIiArIG9wdGlvbnMudGFnKTtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9wcyAmJiBcIm9iamVjdFwiICE9PSBfdHlwZW9mKG9wdGlvbnMucHJvcHMpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnByb3BzIHRvIGJlIGFuIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvcHMpIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKG9wdGlvbnMucHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZiwgcHJvcCA9IG9wdGlvbnMucHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcCB8fCBcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBwcm9wID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocHJvcCkpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnByb3BzLlwiICsga2V5ICsgXCIgdG8gYmUgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wLnR5cGUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHByb3AudHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX2NvbnN0YW50cy5QUk9QX1RZUEVTX0xJU1QuaW5kZXhPZihwcm9wLnR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcm9wLnR5cGUgdG8gYmUgb25lIG9mIFwiICsgX2NvbnN0YW50cy5QUk9QX1RZUEVTX0xJU1Quam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wLnJlcXVpcmVkICYmIHByb3AuZGVmKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlZCBwcm9wIGNhbiBub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGltZW5zaW9ucyAmJiAhKDAsIF9saWIuaXNQeCkob3B0aW9ucy5kaW1lbnNpb25zLndpZHRoKSAmJiAhKDAsIF9saWIuaXNQZXJjKShvcHRpb25zLmRpbWVuc2lvbnMud2lkdGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLmRpbWVuc2lvbnMud2lkdGggdG8gYmUgYSBweCBvciAlIHN0cmluZyB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGltZW5zaW9ucyAmJiAhKDAsIF9saWIuaXNQeCkob3B0aW9ucy5kaW1lbnNpb25zLmhlaWdodCkgJiYgISgwLCBfbGliLmlzUGVyYykob3B0aW9ucy5kaW1lbnNpb25zLmhlaWdodCkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMuZGltZW5zaW9ucy5oZWlnaHQgdG8gYmUgYSBweCBvciAlIHN0cmluZyB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb250ZXh0cy5wb3B1cCwgMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYW55RW5hYmxlZCA9ICExLCBfaXRlcmF0b3IyID0gT2JqZWN0LmtleXMob3B0aW9ucy5jb250ZXh0cyksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFU19MSVNULmluZGV4T2YoY29udGV4dCkpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbnRleHQgdHlwZTogXCIgKyBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25zLmNvbnRleHRzICYmIG9wdGlvbnMuY29udGV4dHNbY29udGV4dF0gfHwgb3B0aW9ucy5jb250ZXh0cyAmJiB2b2lkIDAgPT09IG9wdGlvbnMuY29udGV4dHNbY29udGV4dF0pICYmIChhbnlFbmFibGVkID0gITApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW55RW5hYmxlZCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udGV4dCB0eXBlIGlzIGVuYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX2NvbnN0YW50cy5DT05URVhUX1RZUEVTX0xJU1QuaW5kZXhPZihvcHRpb25zLmRlZmF1bHRDb250ZXh0KSkgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY29udGV4dCB0eXBlOiBcIiArIChvcHRpb25zLmRlZmF1bHRDb250ZXh0IHx8IFwidW5rbm93blwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRleHRzICYmIG9wdGlvbnMuZGVmYXVsdENvbnRleHQgJiYgIW9wdGlvbnMuY29udGV4dHNbb3B0aW9ucy5kZWZhdWx0Q29udGV4dF0pIHRocm93IG5ldyBFcnJvcihcIkRpc2FsbG93ZWQgZGVmYXVsdCBjb250ZXh0IHR5cGU6IFwiICsgKG9wdGlvbnMuZGVmYXVsdENvbnRleHQgfHwgXCJ1bmtub3duXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsICYmIG9wdGlvbnMuYnVpbGRVcmwpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcGFzcyBib3RoIG9wdGlvbnMudXJsIGFuZCBvcHRpb25zLmJ1aWxkVXJsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRFbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIG9wdGlvbnMuZGVmYXVsdEVudikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIG9wdGlvbnMuZGVmYXVsdEVudiB0byBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmJ1aWxkVXJsICYmIFwib2JqZWN0XCIgIT09IF90eXBlb2Yob3B0aW9ucy51cmwpKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnVybCB0byBiZSBhbiBvYmplY3QgbWFwcGluZyBlbnYtPnVybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXJsICYmIFwib2JqZWN0XCIgPT09IF90eXBlb2Yob3B0aW9ucy51cmwpICYmICFvcHRpb25zLnVybFtvcHRpb25zLmRlZmF1bHRFbnZdKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB1cmwgZm91bmQgZm9yIGRlZmF1bHQgZW52OiBcIiArIG9wdGlvbnMuZGVmYXVsdEVudik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVybCAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGVmYXVsdEVudikgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwYXNzIG9wdGlvbnMuZGVmYXVsdEVudiB3aXRoIGVudi0+dXJsIG1hcHBpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBPYmplY3Qua2V5cyhvcHRpb25zLnVybCksIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMyksIF9pMyA9IDAsIF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pdGVyYXRvcjNbX2kzKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbnYgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51cmxbZW52XSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXJsIHNwZWNpZmllZCBmb3IgZW52OiBcIiArIGVudik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJlcmVuZGVyVGVtcGxhdGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLnByZXJlbmRlclRlbXBsYXRlIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGFpbmVyVGVtcGxhdGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBvcHRpb25zLmNvbnRhaW5lclRlbXBsYXRlIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvZGVsZWdhdGUvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5EZWxlZ2F0ZUNvbXBvbmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCIgaW4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvUHJvcHMgJiYgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcyAmJiBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9iYXNlID0gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgXG4gICAgICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIikpLCBfcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvZHJpdmVycy5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLkRlbGVnYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24oX0Jhc2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0oRGVsZWdhdGVDb21wb25lbnQsIF9CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBEZWxlZ2F0ZUNvbXBvbmVudChjb21wb25lbnQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBEZWxlZ2F0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IGZ1bmN0aW9uKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZikgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcywgX0Jhc2VDb21wb25lbnQuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW4uc2V0KFwic291cmNlXCIsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiBvcHRpb25zLnByb3BzLnVpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IG9wdGlvbnMucHJvcHMuZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U6IG9wdGlvbnMucHJvcHMub25DbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGlzcGxheTogb3B0aW9ucy5wcm9wcy5vbkRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50LmdldFByb3AocHJvcE5hbWUpLmFsbG93RGVsZWdhdGUgJiYgKF90aGlzLnByb3BzW3Byb3BOYW1lXSA9IG9wdGlvbnMucHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMub3ZlcnJpZGVzLmZvY3VzLmNhbGwoX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lGb2N1c092ZXJyaWRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBfbGliLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQ2xvc2UgPSBvcHRpb25zLm92ZXJyaWRlcy51c2VyQ2xvc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdldERvbWFpbiA9IG9wdGlvbnMub3ZlcnJpZGVzLmdldERvbWFpbjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBvcHRpb25zLm92ZXJyaWRlcy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub24gPSBvcHRpb25zLm92ZXJyaWRlcy5vbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlT3ZlcnJpZGVzID0gX2RyaXZlcnMuUkVOREVSX0RSSVZFUlNbb3B0aW9ucy5jb250ZXh0XS5kZWxlZ2F0ZU92ZXJyaWRlcywgX2l0ZXJhdG9yMiA9IE9iamVjdC5rZXlzKGRlbGVnYXRlT3ZlcnJpZGVzKSwgX2lzQXJyYXkyID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IyKSwgX2kyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaXRlcmF0b3IyW19pMisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjIgPSBfaTIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpc1trZXldID0gX3BhcmVudC5QYXJlbnRDb21wb25lbnQucHJvdG90eXBlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRXaW5kb3dOYW1lID0gb3B0aW9ucy5jaGlsZFdpbmRvd05hbWU7XG4gICAgICAgICAgICAgICAgICAgIF9wYXJlbnQuUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckFjdGl2ZUNvbXBvbmVudC5jYWxsKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMud2F0Y2hGb3JDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIERlbGVnYXRlQ29tcG9uZW50LnByb3RvdHlwZS53YXRjaEZvckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMub25DbG9zZVdpbmRvdykodGhpcy5zb3VyY2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiLCBjbG9zZVdpbmRvd0xpc3RlbmVyLmNhbmNlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxlZ2F0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3ZlcnJpZGVzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVPdmVycmlkZXMgPSBfZHJpdmVycy5SRU5ERVJfRFJJVkVSU1tjb250ZXh0XS5kZWxlZ2F0ZU92ZXJyaWRlcywgb3ZlcnJpZGVzID0ge30sIHNlbGYgPSB0aGlzLCBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMyA9IF9pMy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlc1trZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnQuUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZVtrZXldLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LCBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMoZGVsZWdhdGVPdmVycmlkZXMpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImJyZWFrXCIgPT09IF9sb29wKCkpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBEZWxlZ2F0ZUNvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhbi5hbGwoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhEZWxlZ2F0ZUNvbXBvbmVudCwgWyB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJkcml2ZXJcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IG5vdCBzZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2RyaXZlcnMuUkVOREVSX0RSSVZFUlNbdGhpcy5jb250ZXh0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlbGVnYXRlQ29tcG9uZW50O1xuICAgICAgICAgICAgfShfYmFzZS5CYXNlQ29tcG9uZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2NvbXBvbmVudC9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jb21wb25lbnQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbXBvbmVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvaW5kZXguanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcGFyZW50KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2NoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9jaGlsZC9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jaGlsZCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY2hpbGRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvY29tcG9uZW50L3BhcmVudC9kcml2ZXJzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuUkVOREVSX0RSSVZFUlMgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpLCBfY29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSwgX3dpbmRvdyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvd2luZG93LmpzXCIpLCBSRU5ERVJfRFJJVkVSUyA9IGV4cG9ydHMuUkVOREVSX0RSSVZFUlMgPSB7fTtcbiAgICAgICAgICAgIFJFTkRFUl9EUklWRVJTW19jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5JRlJBTUVdID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzYWJsZTogITEsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGU6ICEwLFxuICAgICAgICAgICAgICAgIGFsbG93UmVzaXplOiAhMCxcbiAgICAgICAgICAgICAgICBvcGVuT25DbGljazogITEsXG4gICAgICAgICAgICAgICAgbmVlZHNCcmlkZ2U6ICExLFxuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLCBhdHRyaWJ1dGVzID0gdGhpcy5jb21wb25lbnQuYXR0cmlidXRlcy5pZnJhbWUgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lID0gKDAsIF9saWIuaWZyYW1lKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNoaWxkV2luZG93TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogdGhpcy5jb21wb25lbnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxpbmc6IHRoaXMuY29tcG9uZW50LnNjcm9sbGluZyA/IFwieWVzXCIgOiBcIm5vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFsgX2NvbnN0YW50cy5DTEFTU19OQU1FUy5DT01QT05FTlRfRlJBTUUsIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuSU5WSVNJQkxFIF1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLmF3YWl0RnJhbWVXaW5kb3cpKHRoaXMuaWZyYW1lKS50aGVuKGZ1bmN0aW9uKGZyYW1lV2luZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy53aW5kb3cgPSBmcmFtZVdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXRlY3RDbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5vbkNsb3NlKF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5DTE9TRV9ERVRFQ1RFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlmcmFtZVdhdGNoZXIgPSAoMCwgX2xpYi53YXRjaEVsZW1lbnRGb3JDbG9zZSkoX3RoaXMuaWZyYW1lLCBkZXRlY3RDbG9zZSksIGVsZW1lbnRXYXRjaGVyID0gKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpYi53YXRjaEVsZW1lbnRGb3JDbG9zZSkoX3RoaXMuZWxlbWVudCwgZGV0ZWN0Q2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95V2luZG93XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZVdhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFdhdGNoZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9zcmMyLmNsZWFuVXBXaW5kb3cpKF90aGlzLndpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLndpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfbGliLmRlc3Ryb3lFbGVtZW50KShfdGhpcy5pZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW5QcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcywgYXR0cmlidXRlcyA9IHRoaXMuY29tcG9uZW50LmF0dHJpYnV0ZXMuaWZyYW1lIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXJlbmRlcklmcmFtZSA9ICgwLCBfbGliLmlmcmFtZSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiX19wcmVyZW5kZXJfX1wiICsgdGhpcy5jaGlsZFdpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsaW5nOiB0aGlzLmNvbXBvbmVudC5zY3JvbGxpbmcgPyBcInllc1wiIDogXCJub1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBbIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuUFJFUkVOREVSX0ZSQU1FLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLlZJU0lCTEUgXVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuYXdhaXRGcmFtZVdpbmRvdykodGhpcy5wcmVyZW5kZXJJZnJhbWUpLnRoZW4oZnVuY3Rpb24ocHJlcmVuZGVyRnJhbWVXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5wcmVyZW5kZXJXaW5kb3cgPSBwcmVyZW5kZXJGcmFtZVdpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lQcmVyZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5wcmVyZW5kZXJJZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuZGVzdHJveUVsZW1lbnQpKF90aGlzMi5wcmVyZW5kZXJJZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMyLnByZXJlbmRlcklmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hQcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuYWRkQ2xhc3MpKHRoaXMucHJlcmVuZGVySWZyYW1lLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLklOVklTSUJMRSk7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfbGliLnJlbW92ZUNsYXNzKSh0aGlzLnByZXJlbmRlcklmcmFtZSwgX2NvbnN0YW50cy5DTEFTU19OQU1FUy5WSVNJQkxFKTtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuYWRkQ2xhc3MpKHRoaXMuaWZyYW1lLCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLlZJU0lCTEUpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5yZW1vdmVDbGFzcykodGhpcy5pZnJhbWUsIF9jb25zdGFudHMuQ0xBU1NfTkFNRVMuSU5WSVNJQkxFKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5wcmVyZW5kZXJJZnJhbWUgJiYgKDAsIF9saWIuZGVzdHJveUVsZW1lbnQpKF90aGlzMy5wcmVyZW5kZXJJZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxZTMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVPdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95Q29tcG9uZW50OiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lDb250YWluZXI6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQ29udGFpbmVyRXZlbnRzOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZXJlbmRlclRlbXBsYXRlOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSZWFkeTogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q29udGFpbmVyOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDb21wb25lbnQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBoaWRlQ29tcG9uZW50OiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICByZXNpemU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZFVybDogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBoaWphY2tTdWJtaXQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgb3BlblByZXJlbmRlcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hQcmVyZW5kZXI6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGVtcGxhdGU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTCxcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbnRhaW5lckZyYW1lOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIGdldE91dGxldDogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX09SSUdJTkFMLFxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBmdW5jdGlvbihvcmlnaW5hbCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczQuY2xlYW4uc2V0KFwid2luZG93XCIsICgwLCBfc3JjMy5maW5kRnJhbWVCeU5hbWUpKCgwLCBfd2luZG93LmdldFBhcmVudENvbXBvbmVudFdpbmRvdykoKSwgX3RoaXM0LmNoaWxkV2luZG93TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzNC53aW5kb3cpIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIHBhcmVudCBjb21wb25lbnQgaWZyYW1lIHdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLndpZHRoID0gKDAsIF9saWIudG9DU1MpKHdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICgwLCBfbGliLnRvQ1NTKSh3aWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gKDAsIF9saWIudG9DU1MpKGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKDAsIF9saWIudG9DU1MpKGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5zaG93RWxlbWVudCkodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5oaWRlRWxlbWVudCkodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxvYWRVcmw6IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUkVOREVSX0RSSVZFUlNbX2NvbnN0YW50cy5DT05URVhUX1RZUEVTLlBPUFVQXSA9IHtcbiAgICAgICAgICAgICAgICBmb2N1c2FibGU6ICEwLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSW50b0NvbnRhaW5lclRlbXBsYXRlOiAhMSxcbiAgICAgICAgICAgICAgICBhbGxvd1Jlc2l6ZTogITEsXG4gICAgICAgICAgICAgICAgb3Blbk9uQ2xpY2s6ICEwLFxuICAgICAgICAgICAgICAgIG5lZWRzQnJpZGdlOiAhMCxcbiAgICAgICAgICAgICAgICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNSA9IHRoaXMsIHVybCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmID0gX3RoaXM1LmNvbXBvbmVudC5kaW1lbnNpb25zIHx8IHt9LCBfcmVmJHdpZHRoID0gX3JlZi53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWYkd2lkdGggPyBfY29uc3RhbnRzLkRFRkFVTFRfRElNRU5TSU9OUy5XSURUSCA6IF9yZWYkd2lkdGgsIF9yZWYkaGVpZ2h0ID0gX3JlZi5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZiRoZWlnaHQgPyBfY29uc3RhbnRzLkRFRkFVTFRfRElNRU5TSU9OUy5IRUlHSFQgOiBfcmVmJGhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gKDAsIF9saWIubm9ybWFsaXplRGltZW5zaW9uKSh3aWR0aCwgd2luZG93Lm91dGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gKDAsIF9saWIubm9ybWFsaXplRGltZW5zaW9uKShoZWlnaHQsIHdpbmRvdy5vdXRlcldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSAoMCwgX3dpbmRvdy5nZXRQb3NpdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIHggPSBfZ2V0UG9zaXRpb24ueCwgeSA9IF9nZXRQb3NpdGlvbi55LCBhdHRyaWJ1dGVzID0gX3RoaXM1LmNvbXBvbmVudC5hdHRyaWJ1dGVzLnBvcHVwIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM1LndpbmRvdyA9ICgwLCBfbGliLnBvcHVwKSh1cmwgfHwgXCJcIiwgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF90aGlzNS5jaGlsZFdpbmRvd05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sYmFyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnViYXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXphYmxlOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcnM6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzNS5wcmVyZW5kZXJXaW5kb3cgPSBfdGhpczUud2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM1LmNsZWFuLnJlZ2lzdGVyKFwiZGVzdHJveVdpbmRvd1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXM1LndpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczUud2luZG93LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfc3JjMi5jbGVhblVwV2luZG93KShfdGhpczUud2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzNS53aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczUucHJlcmVuZGVyV2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM1LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcGVuUHJlcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzaXplOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGhpZGUgcG9wdXBcIik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzaG93IHBvcHVwXCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVPdmVycmlkZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbkNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95Q29udGFpbmVyOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRSZWFkeTogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q29udGFpbmVyOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDb21wb25lbnQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUNvbnRhaW5lcjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBoaWRlQ29tcG9uZW50OiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfREVMRUdBVEUsXG4gICAgICAgICAgICAgICAgICAgIGhpZGU6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgc2hvdzogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX0RFTEVHQVRFLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxDb250YWluZXJFdmVudHM6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX09SSUdJTkFMLFxuICAgICAgICAgICAgICAgICAgICBsb2FkVXJsOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVByZXJlbmRlclRlbXBsYXRlOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3lDb21wb25lbnQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTCxcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRlbXBsYXRlOiBfY29uc3RhbnRzLkRFTEVHQVRFLkNBTExfT1JJR0lOQUwsXG4gICAgICAgICAgICAgICAgICAgIG9wZW5Db250YWluZXJGcmFtZTogX2NvbnN0YW50cy5ERUxFR0FURS5DQUxMX09SSUdJTkFMLFxuICAgICAgICAgICAgICAgICAgICBnZXRPdXRsZXQ6IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbG9hZFVybDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYzMuaXNTYW1lRG9tYWluKSh0aGlzLndpbmRvdykpIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy53aW5kb3cubG9jYXRpb24gJiYgdGhpcy53aW5kb3cubG9jYXRpb24ucmVwbGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aW5kb3cubG9jYXRpb24gPSB1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuUGFyZW50Q29tcG9uZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9jbGFzcywgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9LCBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInZhbHVlXCIgaW4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvUHJvcHMgJiYgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNQcm9wcyAmJiBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpLCBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCIpLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfc3JjMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tdXRpbHMvc3JjL2luZGV4LmpzXCIpLCBfc3JjMyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L2Jhc2UuanNcIiksIF93aW5kb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29tcG9uZW50L3dpbmRvdy5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpLCBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIiksIF9kcml2ZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvZHJpdmVycy5qc1wiKSwgX3ZhbGlkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9wYXJlbnQvdmFsaWRhdGUuanNcIiksIF9wcm9wcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3Byb3BzLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2MgPSB7fTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjW2tleV0gPSBkZXNjcmlwdG9yW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gICAgICAgICAgICAgICAgZGVzYy5jb25maWd1cmFibGUgPSAhIWRlc2MuY29uZmlndXJhYmxlO1xuICAgICAgICAgICAgICAgIChcInZhbHVlXCIgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSAmJiAoZGVzYy53cml0YWJsZSA9ICEwKTtcbiAgICAgICAgICAgICAgICBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24oZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgICAgICAgICAgICAgICB9LCBkZXNjKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiB2b2lkIDAgIT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGRlc2MuaW5pdGlhbGl6ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgPT09IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfbGliLmdsb2JhbC5wcm9wcyA9IF9saWIuZ2xvYmFsLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgX2xpYi5nbG9iYWwud2luZG93cyA9IF9saWIuZ2xvYmFsLndpbmRvd3MgfHwge307XG4gICAgICAgICAgICAoZXhwb3J0cy5QYXJlbnRDb21wb25lbnQgPSAoX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcigoX2NsYXNzID0gZnVuY3Rpb24oX0Jhc2VDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0oUGFyZW50Q29tcG9uZW50LCBfQmFzZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUGFyZW50Q29tcG9uZW50KGNvbXBvbmVudCwgY29udGV4dCwgX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBQYXJlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBmdW5jdGlvbihzZWxmLCBjYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIF9CYXNlQ29tcG9uZW50LmNhbGwodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbGlkYXRlUGFyZW50RG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmxvZ0xldmVsICYmICgwLCBfbGliLnNldExvZ0xldmVsKShfdGhpcy5wcm9wcy5sb2dMZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkV2luZG93TmFtZSA9IF90aGlzLmJ1aWxkQ2hpbGRXaW5kb3dOYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRvOiB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyQWN0aXZlQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudC5sb2coXCJjb25zdHJ1Y3RfcGFyZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy53YXRjaEZvclVubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkluaXQgPSBuZXcgX3NyYzMuWmFsZ29Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uSW5pdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXMsIGxvYWRVcmwgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdKSB8fCBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUluaXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIuY29tcG9uZW50LmxvZyhcInJlbmRlcl9cIiArIF90aGlzMi5jb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3RoaXMyLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVXJsOiAoMCwgX2xpYi5zdHJpbmdpZnkpKGxvYWRVcmwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXNrcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3Mub25SZW5kZXIgPSBfdGhpczIucHJvcHMub25SZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmdldERvbWFpbiA9IF90aGlzMi5nZXREb21haW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmVsZW1lbnRSZWFkeSA9IF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHJldHVybiBfdGhpczIuZWxlbWVudFJlYWR5KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuQ29udGFpbmVyID0gdGFza3MuZWxlbWVudFJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5vcGVuQ29udGFpbmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zaG93Q29udGFpbmVyID0gdGFza3Mub3BlbkNvbnRhaW5lci50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc2hvd0NvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuUHJlcmVuZGVyID0gdGFza3Mub3BlbkNvbnRhaW5lci50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub3BlblByZXJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zd2l0Y2hQcmVyZW5kZXIgPSBfc3JjMy5aYWxnb1Byb21pc2UuYWxsKFsgdGFza3Mub3BlblByZXJlbmRlciwgX3RoaXMyLm9uSW5pdCBdKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuc3dpdGNoUHJlcmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLm9wZW4gPSBfdGhpczIuZHJpdmVyLm9wZW5PbkNsaWNrID8gX3RoaXMyLm9wZW4oKSA6IHRhc2tzLm9wZW5Db250YWluZXIudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLm9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubGlzdGVuID0gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHRhc2tzLmdldERvbWFpbiwgdGFza3Mub3BlbiBdKS50aGVuKGZ1bmN0aW9uKF9yZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWYyWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5saXN0ZW4oX3RoaXMyLndpbmRvdywgZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3Mud2F0Y2hGb3JDbG9zZSA9IHRhc2tzLm9wZW4udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLndhdGNoRm9yQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubGlua0RvbWFpbiA9IF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyB0YXNrcy5nZXREb21haW4sIHRhc2tzLm9wZW4gXSkudGhlbihmdW5jdGlvbihfcmVmMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBfcmVmM1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NyYy5icmlkZ2UgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluKSByZXR1cm4gX3NyYy5icmlkZ2UubGlua1VybChfdGhpczIud2luZG93LCBkb21haW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMi5odG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUgPSB0YXNrcy5vcGVuUHJlcmVuZGVyLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5zaG93Q29tcG9uZW50ID0gdGFza3MuY3JlYXRlUHJlcmVuZGVyVGVtcGxhdGUudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5zaG93Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5vcGVuQnJpZGdlID0gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHRhc2tzLmdldERvbWFpbiwgdGFza3Mub3BlbiBdKS50aGVuKGZ1bmN0aW9uKF9yZWY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF9yZWY0WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub3BlbkJyaWRnZShcInN0cmluZ1wiID09IHR5cGVvZiBkb21haW4gPyBkb21haW4gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5odG1sKSB0YXNrcy5sb2FkSFRNTCA9IHRhc2tzLm9wZW4udGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLmxvYWRIVE1MKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTsgZWxzZSBpZiAobG9hZFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzLmJ1aWxkVXJsID0gX3RoaXMyLmJ1aWxkVXJsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MubG9hZFVybCA9IF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyB0YXNrcy5idWlsZFVybCwgdGFza3Mub3BlbiwgdGFza3MubGlua0RvbWFpbiwgdGFza3MubGlzdGVuLCB0YXNrcy5vcGVuLCB0YXNrcy5vcGVuQnJpZGdlLCB0YXNrcy5jcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZSBdKS50aGVuKGZ1bmN0aW9uKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmNVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5sb2FkVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucnVuVGltZW91dCA9IHRhc2tzLmxvYWRVcmwudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5ydW5UaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmhhc2godGFza3MpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5wcm9wcy5vbkVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3V0bGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRsZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5hZGRDbGFzcykob3V0bGV0LCBfY29uc3RhbnRzLkNMQVNTX05BTUVTLk9VVExFVCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnZhbGlkYXRlUGFyZW50RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSAoMCwgX3NyYzIuZ2V0RG9tYWluKSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5tYXRjaERvbWFpbikodGhpcy5jb21wb25lbnQuYWxsb3dlZFBhcmVudERvbWFpbnMsIGRvbWFpbikpIHRocm93IG5ldyBfZXJyb3IuUmVuZGVyRXJyb3IoXCJDYW4gbm90IGJlIHJlbmRlcmVkIGJ5IGRvbWFpbjogXCIgKyBkb21haW4pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJUbyA9IGZ1bmN0aW9uKHdpbiwgZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ5SW5pdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuIF90aGlzMy5yZW5kZXIoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBfc3JjMi5pc1NhbWVUb3BXaW5kb3cpKHdpbmRvdywgd2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG9ubHkgcmVuZGVyVG8gYW4gYWRqYWNlbnQgZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcInN0cmluZ1wiICE9IHR5cGVvZiBlbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHBhc3NlZCB0byByZW5kZXJUbyBtdXN0IGJlIGEgc3RyaW5nIHNlbGVjdG9yLCBnb3QgXCIgKyAodm9pZCAwID09PSBlbGVtZW50ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZWxlbWVudCkpICsgXCIgXCIgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5jaGVja0FsbG93UmVuZGVyVG8od2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy5jb21wb25lbnQubG9nKFwicmVuZGVyX1wiICsgX3RoaXMzLmNvbnRleHQgKyBcIl90b193aW5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICgwLCBfbGliLnN0cmluZ2lmeSkoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogX3RoaXMzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmNoaWxkV2luZG93TmFtZSA9IF90aGlzMy5idWlsZENoaWxkV2luZG93TmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyVG86IHdpblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczMuZGVsZWdhdGUod2luKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMucmVuZGVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUucHJlZmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXM0Lmh0bWwgPSBfdGhpczQuYnVpbGRVcmwoKS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5wcmVmZXRjaFBhZ2UpKHVybCkudGhlbihmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJhc2UgaHJlZj1cIicgKyAoXCJcIiArIHVybC5zcGxpdChcIi9cIikuc2xpY2UoMCwgMykuam9pbihcIi9cIikpICsgJ1wiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICcgKyBodG1sICsgXCJcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8c2NyaXB0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCAnXCIgKyAoXCIvXCIgKyB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDMpLmpvaW4oXCIvXCIpKSArIFwiJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICA8XFwvc2NyaXB0PlxcbiAgICAgICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmxvYWRIVE1MID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXM1Lmh0bWwpIHRocm93IG5ldyBFcnJvcihcIkh0bWwgbm90IHByZWZldGNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM1Lmh0bWwudGhlbihmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLndyaXRlVG9XaW5kb3cpKF90aGlzNS53aW5kb3csIGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5jaGVja0FsbG93UmVuZGVyVG8gPSBmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHRocm93IHRoaXMuY29tcG9uZW50LmNyZWF0ZUVycm9yKFwiTXVzdCBwYXNzIHdpbmRvdyB0byByZW5kZXJUb1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIuaXNTYW1lRG9tYWluKSh3aW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gKDAsIF9zcmMyLmdldERvbWFpbikoKSwgZG9tYWluID0gdGhpcy5jb21wb25lbnQuZ2V0RG9tYWluKG51bGwsIHRoaXMucHJvcHMuZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9tYWluKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIGRvbWFpbiB0byBhbGxvdyByZW1vdGUgcmVuZGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3NyYzIubWF0Y2hEb21haW4pKGRvbWFpbiwgb3JpZ2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZW5kZXIgcmVtb3RlbHkgdG8gXCIgKyBkb21haW4udG9TdHJpbmcoKSArIFwiIC0gY2FuIG9ubHkgcmVuZGVyIHRvIFwiICsgb3JpZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3RlckFjdGl2ZUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LmFjdGl2ZUNvbXBvbmVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5hY3RpdmVDb21wb25lbnRzLnNwbGljZShQYXJlbnRDb21wb25lbnQuYWN0aXZlQ29tcG9uZW50cy5pbmRleE9mKF90aGlzNiksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50UGFyZW50UmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJUb1dpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogd2luZG93O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0ID09PSBfY29uc3RhbnRzLkNPTlRFWFRfVFlQRVMuUE9QVVApIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuT1BFTkVSXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJUb1dpbmRvdyA9PT0gd2luZG93KSByZXR1cm4gKDAsIF9zcmMyLmlzVG9wKSh3aW5kb3cpID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlRPUFxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlBBUkVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAoMCwgX3NyYzIuZ2V0RGlzdGFuY2VGcm9tVG9wKSh3aW5kb3cpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciB1aWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICAgICAgX2xpYi5nbG9iYWwud2luZG93c1t1aWRdID0gd2luZG93O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJlZ2lzdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9saWIuZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWY6IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuR0xPQkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UmVuZGVyUGFyZW50UmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJUb1dpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDogd2luZG93O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyVG9XaW5kb3cgPT09IHdpbmRvdykgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50UGFyZW50UmVmKHJlbmRlclRvV2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVpZCA9ICgwLCBfbGliLnVuaXF1ZUlEKSgpO1xuICAgICAgICAgICAgICAgICAgICBfbGliLmdsb2JhbC53aW5kb3dzW3VpZF0gPSByZW5kZXJUb1dpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfbGliLmdsb2JhbC53aW5kb3dzW3VpZF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLkdMT0JBTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ2hpbGRXaW5kb3dOYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmNiRyZW5kZXJUbyA9IChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9KS5yZW5kZXJUbywgcmVuZGVyVG8gPSB2b2lkIDAgPT09IF9yZWY2JHJlbmRlclRvID8gd2luZG93IDogX3JlZjYkcmVuZGVyVG8sIHNhbWVEb21haW4gPSAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9zcmMyLmlzU2FtZURvbWFpbikocmVuZGVyVG8pLCB1aWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKSwgdGFnID0gdGhpcy5jb21wb25lbnQudGFnLCBzUHJvcHMgPSAoMCwgXG4gICAgICAgICAgICAgICAgICAgIF9saWIuc2VyaWFsaXplRnVuY3Rpb25zKSh0aGlzLmdldFByb3BzRm9yQ2hpbGQoKSksIGNvbXBvbmVudFBhcmVudCA9IHRoaXMuZ2V0Q29tcG9uZW50UGFyZW50UmVmKHJlbmRlclRvKSwgcmVuZGVyUGFyZW50ID0gdGhpcy5nZXRSZW5kZXJQYXJlbnRSZWYocmVuZGVyVG8pLCBwcm9wcyA9ICFzYW1lRG9tYWluICYmICF0aGlzLmNvbXBvbmVudC51bnNhZmVSZW5kZXJUbyA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5VSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZFxuICAgICAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5JTklUSUFMX1BST1BTLlJBVyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnR5cGUgPT09IF9jb25zdGFudHMuSU5JVElBTF9QUk9QUy5VSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIuZ2xvYmFsLnByb3BzW3VpZF0gPSBKU09OLnN0cmluZ2lmeShzUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2xpYi5nbG9iYWwucHJvcHNbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3dpbmRvdy5idWlsZENoaWxkV2luZG93TmFtZSkodGhpcy5jb21wb25lbnQubmFtZSwgdGhpcy5jb21wb25lbnQudmVyc2lvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiB1aWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFBhcmVudDogY29tcG9uZW50UGFyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyUGFyZW50OiByZW5kZXJQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNlbmRUb1BhcmVudCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgX3dpbmRvdy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cpKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZmluZCBwYXJlbnQgY29tcG9uZW50IHdpbmRvdyB0byBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5sb2coXCJzZW5kX3RvX3BhcmVudF9cIiArIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9zcmMuc2VuZCkoKDAsIF93aW5kb3cuZ2V0UGFyZW50Q29tcG9uZW50V2luZG93KSgpLCBuYW1lLCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW46ICgwLCBfd2luZG93LmdldFBhcmVudERvbWFpbikoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuc2V0UHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdKSB8fCBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVQcm9wcykodGhpcy5jb21wb25lbnQsIHByb3BzLCByZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZhbGlkYXRlICYmIHRoaXMuY29tcG9uZW50LnZhbGlkYXRlKHRoaXMuY29tcG9uZW50LCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSB0aGlzLnByb3BzIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5leHRlbmQpKHRoaXMucHJvcHMsICgwLCBfcHJvcHMubm9ybWFsaXplUHJvcHMpKHRoaXMuY29tcG9uZW50LCB0aGlzLCBwcm9wcykpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5idWlsZFVybCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXM3ID0gdGhpcywgcHJvcFVybCA9IHRoaXMucHJvcHMudXJsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIHByb3BVcmwsICgwLCBfcHJvcHMucHJvcHNUb1F1ZXJ5KShfZXh0ZW5kcyh7fSwgdGhpcy5jb21wb25lbnQucHJvcHMsIHRoaXMuY29tcG9uZW50LmJ1aWx0aW5Qcm9wcyksIHRoaXMucHJvcHMpIF0pLnRoZW4oZnVuY3Rpb24oX3JlZjcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmN1swXSwgcXVlcnkgPSBfcmVmN1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmwgJiYgIV90aGlzNy5jb21wb25lbnQuZ2V0VmFsaWREb21haW4odXJsKSA/IHVybCA6IF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybCB8fCBfdGhpczcuY29tcG9uZW50LmdldFVybChfdGhpczcucHJvcHMuZW52LCBfdGhpczcucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihmaW5hbFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5Lnhjb21wb25lbnQgPSBcIjFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuZXh0ZW5kVXJsKShmaW5hbFVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0RG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczgucHJvcHMudXJsO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IF90aGlzOC5jb21wb25lbnQuZ2V0RG9tYWluKHVybCwgX3RoaXM4LnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluIHx8IChfdGhpczguY29tcG9uZW50LmJ1aWxkVXJsID8gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM4LmNvbXBvbmVudC5idWlsZFVybChfdGhpczgucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihidWlsdFVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczguY29tcG9uZW50LmdldERvbWFpbihidWlsdFVybCwgX3RoaXM4LnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSA6IHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbWFpbikgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBkb21haW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZ2V0UHJvcHNGb3JDaGlsZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKHRoaXMucHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjggPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmOCwgcHJvcCA9IHRoaXMuY29tcG9uZW50LmdldFByb3Aoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgJiYgITEgPT09IHByb3Auc2VuZFRvQ2hpbGQgfHwgKHJlc3VsdFtrZXldID0gdGhpcy5wcm9wc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFByb3BzKHByb3BzLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uSW5pdC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzOS5jaGlsZEV4cG9ydHMpIHJldHVybiBfdGhpczkuY2hpbGRFeHBvcnRzLnVwZGF0ZVByb3BzKF90aGlzOS5nZXRQcm9wc0ZvckNoaWxkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hpbGQgZXhwb3J0cyB3ZXJlIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5vcGVuQnJpZGdlID0gZnVuY3Rpb24oZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NyYy5icmlkZ2UgJiYgX3RoaXMxMC5kcml2ZXIubmVlZHNCcmlkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNCcmlkZ2VQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogX3RoaXMxMC53aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiAmJiAobmVlZHNCcmlkZ2VQYXJhbXMuZG9tYWluID0gZG9tYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVlZHNCcmlkZ2UgPSBfc3JjLmJyaWRnZS5uZWVkc0JyaWRnZShuZWVkc0JyaWRnZVBhcmFtcyksIGJyaWRnZVVybCA9IF90aGlzMTAuY29tcG9uZW50LmdldEJyaWRnZVVybChfdGhpczEwLnByb3BzLmVudik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJyaWRnZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmwgPSAoMCwgX2xpYi5leHRlbmRVcmwpKGJyaWRnZVVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBfdGhpczEwLmNvbXBvbmVudC52ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnJpZGdlRG9tYWluID0gX3RoaXMxMC5jb21wb25lbnQuZ2V0QnJpZGdlRG9tYWluKF90aGlzMTAucHJvcHMuZW52KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFicmlkZ2VEb21haW4pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGV0ZXJtaW5lIGRvbWFpbiBmb3IgYnJpZGdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVlZHNCcmlkZ2UgPyBfc3JjLmJyaWRnZS5vcGVuQnJpZGdlKGJyaWRnZVVybCwgYnJpZGdlRG9tYWluKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0JyaWRnZSAmJiBkb21haW4gJiYgIV9zcmMuYnJpZGdlLmhhc0JyaWRnZShkb21haW4sIGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkJyaWRnZSB1cmwgbmVlZGVkIHRvIHJlbmRlciBcIiArIF90aGlzMTAuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczExID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczExLmNvbXBvbmVudC5sb2coXCJvcGVuX1wiICsgX3RoaXMxMS5jb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZTogX3RoaXMxMS5jaGlsZFdpbmRvd05hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTEuZHJpdmVyLm9wZW4uY2FsbChfdGhpczExKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLm9wZW5QcmVyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczEyLmNvbXBvbmVudC5wcmVyZW5kZXJUZW1wbGF0ZSkgcmV0dXJuIF90aGlzMTIuZHJpdmVyLm9wZW5QcmVyZW5kZXIuY2FsbChfdGhpczEyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnN3aXRjaFByZXJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMxMyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMTMucHJlcmVuZGVyV2luZG93ICYmIF90aGlzMTMuZHJpdmVyLnN3aXRjaFByZXJlbmRlcikgcmV0dXJuIF90aGlzMTMuZHJpdmVyLnN3aXRjaFByZXJlbmRlci5jYWxsKF90aGlzMTMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZWxlbWVudFJlYWR5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIF9saWIuZWxlbWVudFJlYWR5KShlbGVtZW50KS50aGVuKF9saWIubm9vcCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmRlbGVnYXRlID0gZnVuY3Rpb24od2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQubG9nKFwiZGVsZWdhdGVfXCIgKyB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHRoaXMucHJvcHMudWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogdGhpcy5wcm9wcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogdGhpcy5wcm9wcy5vbkNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25EaXNwbGF5OiB0aGlzLnByb3BzLm9uRGlzcGxheVxuICAgICAgICAgICAgICAgICAgICB9LCBfaXRlcmF0b3IyID0gdGhpcy5jb21wb25lbnQuZ2V0UHJvcE5hbWVzKCksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMiA9IF9pc0FycmF5MiA/IF9pdGVyYXRvcjIgOiBfaXRlcmF0b3IyW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY5O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY5ID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gX3JlZjk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5nZXRQcm9wKHByb3BOYW1lKS5hbGxvd0RlbGVnYXRlICYmIChwcm9wc1twcm9wTmFtZV0gPSB0aGlzLnByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0gKDAsIF9zcmMuc2VuZCkod2luLCBfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ERUxFR0FURSArIFwiX1wiICsgdGhpcy5jb21wb25lbnQubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZW52OiB0aGlzLnByb3BzLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRXaW5kb3dOYW1lOiB0aGlzLmNoaWxkV2luZG93TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJDbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC51c2VyQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RG9tYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE0LmdldERvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxNC5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKF9yZWYxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfcmVmMTAuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTQuY2xlYW4ucmVnaXN0ZXIoZGF0YS5kZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBkZWxlZ2F0ZSByZW5kZXJpbmcuIFBvc3NpYmx5IHRoZSBjb21wb25lbnQgaXMgbm90IGxvYWRlZCBpbiB0aGUgdGFyZ2V0IHdpbmRvdy5cXG5cXG5cIiArICgwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saWIuc3RyaW5naWZ5RXJyb3IpKGVycikpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgb3ZlcnJpZGVzID0gdGhpcy5kcml2ZXIuZGVsZWdhdGVPdmVycmlkZXMsIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjExLCB2YWwgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9PUklHSU5BTCkgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IF90aGlzMTRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTRba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE1ID0gdGhpcywgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IGRhdGEub3ZlcnJpZGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IF9jb25zdGFudHMuREVMRUdBVEUuQ0FMTF9ERUxFR0FURSkgcmV0dXJuIG92ZXJyaWRlLmFwcGx5KF90aGlzMTUsIF9hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwpIHJldHVybiB2YWwob3JpZ2luYWwsIG92ZXJyaWRlKS5hcHBseShfdGhpczE1LCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZGVsZ2F0ZSB0byBiZSBDQUxMX09SSUdJTkFMLCBDQUxMX0RFTEVHQVRFLCBvciBmYWN0b3J5IG1ldGhvZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3AyOiBmb3IgKF9pdGVyYXRvcjMgPSBfaXNBcnJheTMgPyBfaXRlcmF0b3IzIDogX2l0ZXJhdG9yM1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9sb29wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgX2xvb3AyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb250aW51ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMTYgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMyLm9uQ2xvc2VXaW5kb3cpKHRoaXMud2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTYuY29tcG9uZW50LmxvZyhcImRldGVjdF9jbG9zZV9jaGlsZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczE2LnByb3BzLm9uQ2xvc2UoX2NvbnN0YW50cy5DTE9TRV9SRUFTT05TLkNMT1NFX0RFVEVDVEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDNlMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiLCBjbG9zZVdpbmRvd0xpc3RlbmVyLmNhbmNlbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLndhdGNoRm9yVW5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE3ID0gdGhpcywgb251bmxvYWQgPSAoMCwgX2xpYi5vbmNlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTcuY29tcG9uZW50LmxvZyhcIm5hdmlnYXRlX2F3YXlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2NsaWVudC5mbHVzaCkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTcuZGVzdHJveUNvbXBvbmVudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KSwgdW5sb2FkV2luZG93TGlzdGVuZXIgPSAoMCwgX2xpYi5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFwidW5sb2FkXCIsIG9udW5sb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihcImRlc3Ryb3lVbmxvYWRXaW5kb3dMaXN0ZW5lclwiLCB1bmxvYWRXaW5kb3dMaXN0ZW5lci5jYW5jZWwpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5sb2FkVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE4ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczE4LmNvbXBvbmVudC5sb2coXCJsb2FkX3VybFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdChcIiNcIilbMF0gPT09IHVybC5zcGxpdChcIiNcIilbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3F1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfbGliLmV4dGVuZFVybCkodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAoX3F1ZXJ5ID0ge30sIF9xdWVyeVsoMCwgX2xpYi51bmlxdWVJRCkoKV0gPSBcIjFcIiwgX3F1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTguZHJpdmVyLmxvYWRVcmwuY2FsbChfdGhpczE4LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlqYWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LnRhcmdldCA9IHRoaXMuY2hpbGRXaW5kb3dOYW1lO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5ydW5UaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczE5ID0gdGhpcywgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaWQgPSB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTkuY29tcG9uZW50LmxvZyhcInRpbWVkX291dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IF90aGlzMTkuY29tcG9uZW50LmNyZWF0ZUVycm9yKFwiTG9hZGluZyBjb21wb25lbnQgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZW91dCArIFwiIG1pbGxpc2Vjb25kc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczE5Lm9uSW5pdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTkucHJvcHMub25UaW1lb3V0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5yZWdpc3RlcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMxOS50aW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMTI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX3JlZjEyID0ge30pW19jb25zdGFudHMuUE9TVF9NRVNTQUdFLklOSVRdID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkRXhwb3J0cyA9IGRhdGEuZXhwb3J0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25Jbml0LnJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiB0aGlzLmdldFByb3BzRm9yQ2hpbGQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5DTE9TRV0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZGF0YS5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9LCBfcmVmMTJbX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuQ0hFQ0tfQ0xPU0VdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlZjEyW19jb25zdGFudHMuUE9TVF9NRVNTQUdFLlJFU0laRV0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczIwLmRyaXZlci5hbGxvd1Jlc2l6ZSkgcmV0dXJuIF90aGlzMjAucmVzaXplKGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBfcmVmMTJbX2NvbnN0YW50cy5QT1NUX01FU1NBR0UuT05SRVNJWkVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50LnRyaWdnZXIoXCJyZXNpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5ISURFXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5TSE9XXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZWYxMltfY29uc3RhbnRzLlBPU1RfTUVTU0FHRS5FUlJPUl0gPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKGRhdGEuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlZjEyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIxID0gdGhpcywgX3JlZjEzJHdhaXRGb3JUcmFuc2l0ID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge30pLndhaXRGb3JUcmFuc2l0aW9uLCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHZvaWQgMCA9PT0gX3JlZjEzJHdhaXRGb3JUcmFuc2l0IHx8IF9yZWYxMyR3YWl0Rm9yVHJhbnNpdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmNvbXBvbmVudC5sb2coXCJyZXNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogKDAsIF9saWIuc3RyaW5naWZ5KShoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAoMCwgX2xpYi5zdHJpbmdpZnkpKHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmRyaXZlci5yZXNpemUuY2FsbChfdGhpczIxLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWl0Rm9yVHJhbnNpdGlvbiAmJiAoX3RoaXMyMS5lbGVtZW50IHx8IF90aGlzMjEuaWZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczIxLmVsZW1lbnQgJiYgKG92ZXJmbG93ID0gKDAsIF9saWIuc2V0T3ZlcmZsb3cpKF90aGlzMjEuZWxlbWVudCwgXCJoaWRkZW5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX2xpYi5lbGVtZW50U3RvcHBlZE1vdmluZykoX3RoaXMyMS5lbGVtZW50IHx8IF90aGlzMjEuaWZyYW1lKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyAmJiBvdmVyZmxvdy5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciAmJiAoMCwgX2xpYi5oaWRlRWxlbWVudCkodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcml2ZXIuaGlkZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyICYmICgwLCBfbGliLnNob3dFbGVtZW50KSh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlci5zaG93LmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNoZWNrQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjIgPSB0aGlzLCBjbG9zZVdpbmRvd0xpc3RlbmVyID0gKDAsIF9zcmMyLm9uQ2xvc2VXaW5kb3cpKHRoaXMud2luZG93LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMjIudXNlckNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwLCA1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJlZ2lzdGVyKGNsb3NlV2luZG93TGlzdGVuZXIuY2FuY2VsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUudXNlckNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKF9jb25zdGFudHMuQ0xPU0VfUkVBU09OUy5VU0VSX0NMT1NFRCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczIzID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyMy5jb21wb25lbnQubG9nKFwiY2xvc2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMjMuZXZlbnQudHJpZ2dlck9uY2UoX2NvbnN0YW50cy5FVkVOVFMuQ0xPU0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjMucHJvcHMub25DbG9zZShyZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS5hbGwoWyBfdGhpczIzLmNsb3NlQ29tcG9uZW50KCksIF90aGlzMjMuY2xvc2VDb250YWluZXIoKSBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI0ID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyNC5ldmVudC50cmlnZ2VyT25jZShfY29uc3RhbnRzLkVWRU5UUy5DTE9TRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNC5wcm9wcy5vbkNsb3NlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLmFsbChbIF90aGlzMjQuY2xvc2VDb21wb25lbnQocmVhc29uKSwgX3RoaXMyNC5oaWRlQ29udGFpbmVyKCkgXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNC5kZXN0cm95Q29udGFpbmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5kZXN0cm95Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI1LmNsZWFuLnJ1bihcImRlc3Ryb3lDb250YWluZXJFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI1LmNsZWFuLnJ1bihcImRlc3Ryb3lDb250YWluZXJUZW1wbGF0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLmNsb3NlQ29tcG9uZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczI2ID0gdGhpcywgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBfY29uc3RhbnRzLkNMT1NFX1JFQVNPTlMuUEFSRU5UX0NBTEwsIHdpbiA9IHRoaXMud2luZG93O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczI2LmNhbmNlbENvbnRhaW5lckV2ZW50cygpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMyNi5ldmVudC50cmlnZ2VyT25jZShfY29uc3RhbnRzLkVWRU5UUy5DTE9TRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5wcm9wcy5vbkNsb3NlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5oaWRlQ29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyNi5kZXN0cm95Q29tcG9uZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpczI2LmNoaWxkRXhwb3J0cyAmJiBfdGhpczI2LmNvbnRleHQgPT09IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUy5QT1BVUCAmJiAhKDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgX3NyYzIuaXNXaW5kb3dDbG9zZWQpKHdpbikgJiYgX3RoaXMyNi5jaGlsZEV4cG9ydHMuY2xvc2UoKS5jYXRjaChfbGliLm5vb3ApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJ1bihcImRlc3Ryb3lVbmxvYWRXaW5kb3dMaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5ydW4oXCJkZXN0cm95Q2xvc2VXaW5kb3dMaXN0ZW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbi5ydW4oXCJkZXN0cm95Q29udGFpbmVyRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuLnJ1bihcImRlc3Ryb3lXaW5kb3dcIik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNob3dDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjcgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczI3LnByb3BzLm9uRGlzcGxheSkgcmV0dXJuIF90aGlzMjcucHJvcHMub25EaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyNy5jb250YWluZXIpIHJldHVybiAoMCwgX2xpYi5zaG93QW5kQW5pbWF0ZSkoX3RoaXMyNy5jb250YWluZXIsIF9jb25zdGFudHMuQU5JTUFUSU9OX05BTUVTLlNIT1dfQ09OVEFJTkVSLCBfdGhpczI3LmNsZWFuLnJlZ2lzdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnNob3dDb21wb25lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMjggPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpczI4LnByb3BzLm9uRGlzcGxheSkgcmV0dXJuIF90aGlzMjgucHJvcHMub25EaXNwbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyOC5lbGVtZW50KSByZXR1cm4gKDAsIF9saWIuc2hvd0FuZEFuaW1hdGUpKF90aGlzMjguZWxlbWVudCwgX2NvbnN0YW50cy5BTklNQVRJT05fTkFNRVMuU0hPV19DT01QT05FTlQsIF90aGlzMjguY2xlYW4ucmVnaXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMyOSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMjkuY29udGFpbmVyID8gKDAsIF9saWIuYW5pbWF0ZUFuZEhpZGUpKF90aGlzMjkuY29udGFpbmVyLCBfY29uc3RhbnRzLkFOSU1BVElPTl9OQU1FUy5ISURFX0NPTlRBSU5FUiwgX3RoaXMyOS5jbGVhbi5yZWdpc3RlcikgOiBfc3JjMy5aYWxnb1Byb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuaGlkZUNvbXBvbmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzMCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzAuZWxlbWVudCA/ICgwLCBfbGliLmFuaW1hdGVBbmRIaWRlKShfdGhpczMwLmVsZW1lbnQsIF9jb25zdGFudHMuQU5JTUFUSU9OX05BTUVTLkhJREVfQ09NUE9ORU5ULCBfdGhpczMwLmNsZWFuLnJlZ2lzdGVyKSA6IF9zcmMzLlphbGdvUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2luZG93IHx8ICgwLCBfc3JjMi5pc1dpbmRvd0Nsb3NlZCkodGhpcy53aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3aW5kb3cgdG8gZm9jdXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmxvZyhcImZvY3VzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndpbmRvdy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzMSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzEuY29tcG9uZW50LnByZXJlbmRlclRlbXBsYXRlID8gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzMS5wcmVyZW5kZXJJZnJhbWUgPyAoMCwgX2xpYi5hd2FpdEZyYW1lTG9hZCkoX3RoaXMzMS5wcmVyZW5kZXJJZnJhbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMxLnByZXJlbmRlcldpbmRvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IF90aGlzMzEucHJlcmVuZGVyV2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbih3aW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi53cml0ZUVsZW1lbnRUb1dpbmRvdykod2luLCBfdGhpczMxLnJlbmRlclRlbXBsYXRlKF90aGlzMzEuY29tcG9uZW50LnByZXJlbmRlclRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc3hEb206IF9saWIuanN4RG9tLmJpbmQoZG9jKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogX3NyYzMuWmFsZ29Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMzIgPSB0aGlzLCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgX3JlZjE0ID0gdGhpcy5jb21wb25lbnQuZGltZW5zaW9ucyB8fCB7fSwgX3JlZjE0JHdpZHRoID0gX3JlZjE0LndpZHRoLCB3aWR0aCA9IHZvaWQgMCA9PT0gX3JlZjE0JHdpZHRoID8gX2NvbnN0YW50cy5ERUZBVUxUX0RJTUVOU0lPTlMuV0lEVEggKyBcInB4XCIgOiBfcmVmMTQkd2lkdGgsIF9yZWYxNCRoZWlnaHQgPSBfcmVmMTQuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWYxNCRoZWlnaHQgPyBfY29uc3RhbnRzLkRFRkFVTFRfRElNRU5TSU9OUy5IRUlHSFQgKyBcInB4XCIgOiBfcmVmMTQkaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogX2NvbnN0YW50cy5DTEFTU19OQU1FUy5aT0lEICsgXCItXCIgKyB0aGlzLmNvbXBvbmVudC50YWcgKyBcIi1cIiArIHRoaXMucHJvcHMudWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHJlbmRlcmVyLl9feGRvbWFpbl9fID8gbnVsbCA6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHRoaXMuY29tcG9uZW50LnRhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGxldDogdGhpcy5nZXRPdXRsZXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENMQVNTOiBfY29uc3RhbnRzLkNMQVNTX05BTUVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgQU5JTUFUSU9OOiBfY29uc3RhbnRzLkFOSU1BVElPTl9OQU1FUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTlRFWFQ6IF9jb25zdGFudHMuQ09OVEVYVF9UWVBFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIEVWRU5UOiBfY29uc3RhbnRzLkVWRU5UUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczMyLnVzZXJDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzMi5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBqc3hEb206IF9saWIuanN4RG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBQYXJlbnRDb21wb25lbnQucHJvdG90eXBlLm9wZW5Db250YWluZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczMzID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlbCA9IGVsZW1lbnQgPyAoMCwgX2xpYi5nZXRFbGVtZW50KShlbGVtZW50KSA6IGRvY3VtZW50LmJvZHkpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIG9wZW4gY29udGFpbmVyIGludG9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzMy5jb21wb25lbnQuY29udGFpbmVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMzMy5yZW5kZXJUZW1wbGF0ZShfdGhpczMzLmNvbXBvbmVudC5jb250YWluZXJUZW1wbGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwgX2xpYi5hcHBlbmRDaGlsZCkoZWwsIF90aGlzMzMuY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMzMy5kcml2ZXIucmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzMy5lbGVtZW50ID0gX3RoaXMzMy5nZXRPdXRsZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMzMy5lbGVtZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHRvIHJlbmRlciBjb21wb25lbnQgaW50b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9saWIuaGlkZUVsZW1lbnQpKF90aGlzMzMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzMuY2xlYW4ucmVnaXN0ZXIoXCJkZXN0cm95Q29udGFpbmVyVGVtcGxhdGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzMuY29udGFpbmVyICYmIF90aGlzMzMuY29udGFpbmVyLnBhcmVudE5vZGUgJiYgX3RoaXMzMy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczMzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczMzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMzMy5kcml2ZXIucmVuZGVyZWRJbnRvQ29udGFpbmVyVGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcihcImNvbnRhaW5lclRlbXBsYXRlIG5lZWRlZCB0byByZW5kZXIgXCIgKyBfdGhpczMzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuY2FuY2VsQ29udGFpbmVyRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW4ucnVuKFwiZGVzdHJveUNvbnRhaW5lckV2ZW50c1wiKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMzNCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMzQuY2xlYW4uaGFzVGFza3MoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzQuY29tcG9uZW50LmxvZyhcImRlc3Ryb3lcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9jbGllbnQuZmx1c2gpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzQuY2xlYW4uYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LnByb3RvdHlwZS50cnlJbml0ID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpczM1ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMzLlphbGdvUHJvbWlzZS50cnkobWV0aG9kKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzUub25Jbml0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzUub25Jbml0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIFBhcmVudENvbXBvbmVudC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzMzYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYzMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzYuaGFuZGxlZEVycm9ycyA9IF90aGlzMzYuaGFuZGxlZEVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gX3RoaXMzNi5oYW5kbGVkRXJyb3JzLmluZGV4T2YoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMzYuaGFuZGxlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMzNi5vbkluaXQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMzYuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMzYucHJvcHMub25FcnJvcikgcmV0dXJuIF90aGlzMzYucHJvcHMub25FcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCB3aGlsZSBoYW5kbGluZyBlcnJvcjpcXG5cXG4gXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSArIFwiXFxuXFxuXCIgKyAoMCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGliLnN0cmluZ2lmeUVycm9yKShlcnJFcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMzNi5wcm9wcy5vbkVycm9yKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgUGFyZW50Q29tcG9uZW50LmRlc3Ryb3lBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVzdWx0cyA9IFtdOyBQYXJlbnRDb21wb25lbnQuYWN0aXZlQ29tcG9uZW50cy5sZW5ndGg7ICkgcmVzdWx0cy5wdXNoKFBhcmVudENvbXBvbmVudC5hY3RpdmVDb21wb25lbnRzWzBdLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjMy5aYWxnb1Byb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oX2xpYi5ub29wKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9jcmVhdGVDbGFzcyhQYXJlbnRDb21wb25lbnQsIFsge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IFwiZHJpdmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kcml2ZXJzLlJFTkRFUl9EUklWRVJTW3RoaXMuY29udGV4dF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJlbnRDb21wb25lbnQ7XG4gICAgICAgICAgICB9KF9iYXNlLkJhc2VDb21wb25lbnQpKS5wcm90b3R5cGUsIFwiZ2V0T3V0bGV0XCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZ2V0T3V0bGV0XCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwicHJlZmV0Y2hcIiwgWyBfbGliLm1lbW9pemVkIF0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJwcmVmZXRjaFwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImxvYWRIVE1MXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwibG9hZEhUTUxcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJidWlsZFVybFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImJ1aWxkVXJsXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlblwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm9wZW5cIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJvcGVuUHJlcmVuZGVyXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlblByZXJlbmRlclwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN3aXRjaFByZXJlbmRlclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInN3aXRjaFByZXJlbmRlclwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlXCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiY2xvc2VcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjbG9zZUNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlQ29udGFpbmVyXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiZGVzdHJveUNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImRlc3Ryb3lDb250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjbG9zZUNvbXBvbmVudFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNsb3NlQ29tcG9uZW50XCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd0NvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcInNob3dDb250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJzaG93Q29tcG9uZW50XCIsIFsgX2xpYi5tZW1vaXplZCBdLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwic2hvd0NvbXBvbmVudFwiKSwgX2NsYXNzLnByb3RvdHlwZSksIFxuICAgICAgICAgICAgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhpZGVDb250YWluZXJcIiwgWyBfbGliLm1lbW9pemVkIF0sIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJoaWRlQ29udGFpbmVyXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwiaGlkZUNvbXBvbmVudFwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImhpZGVDb21wb25lbnRcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgXCJjcmVhdGVQcmVyZW5kZXJUZW1wbGF0ZVwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcImNyZWF0ZVByZXJlbmRlclRlbXBsYXRlXCIpLCBfY2xhc3MucHJvdG90eXBlKSwgXG4gICAgICAgICAgICBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsIFwib3BlbkNvbnRhaW5lclwiLCBbIF9saWIubWVtb2l6ZWQgXSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCBcIm9wZW5Db250YWluZXJcIiksIF9jbGFzcy5wcm90b3R5cGUpLCBcbiAgICAgICAgICAgIF9jbGFzcykpLmFjdGl2ZUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3Byb3BzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZVByb3AgPSBub3JtYWxpemVQcm9wO1xuICAgICAgICAgICAgZXhwb3J0cy5ub3JtYWxpemVQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMocHJvcHMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgLTEgIT09IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKS5pbmRleE9mKGtleSkgPyByZXN1bHRba2V5XSA9IG5vcm1hbGl6ZVByb3AoY29tcG9uZW50LCBpbnN0YW5jZSwgcHJvcHMsIGtleSwgcHJvcHNba2V5XSkgOiByZXN1bHRba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBjb21wb25lbnQuZ2V0UHJvcE5hbWVzKCksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfa2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3BzLmhhc093blByb3BlcnR5KF9rZXkpIHx8IGluc3RhbmNlLnByb3BzICYmIGluc3RhbmNlLnByb3BzLmhhc093blByb3BlcnR5KF9rZXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplUHJvcChjb21wb25lbnQsIGluc3RhbmNlLCBwcm9wcywgX2tleSwgcHJvcHNbX2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwICE9PSBub3JtYWxpemVkUHJvcCAmJiAocmVzdWx0W19rZXldID0gbm9ybWFsaXplZFByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcm9wc1RvUXVlcnkgPSBmdW5jdGlvbihwcm9wc0RlZiwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLmFsbChPYmplY3Qua2V5cyhwcm9wcykubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzRGVmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wKSByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHByb3AucXVlcnlQYXJhbSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS5hbGwoWyBmdW5jdGlvbihwcm9wLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zcmMuWmFsZ29Qcm9taXNlLnRyeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcHJvcC5xdWVyeVBhcmFtID8gcHJvcC5xdWVyeVBhcmFtKHZhbHVlKSA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHByb3AucXVlcnlQYXJhbSA/IHByb3AucXVlcnlQYXJhbSA6IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0ocHJvcCwga2V5LCB2YWx1ZSksIGZ1bmN0aW9uKHByb3AsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NyYy5aYWxnb1Byb21pc2UudHJ5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiBwcm9wLnF1ZXJ5VmFsdWUgPyBwcm9wLnF1ZXJ5VmFsdWUodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KHByb3AsIDAsIHZhbHVlKSBdKS50aGVuKGZ1bmN0aW9uKF9yZWYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5UGFyYW0gPSBfcmVmM1swXSwgcXVlcnlWYWx1ZSA9IF9yZWYzWzFdLCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiYm9vbGVhblwiID09IHR5cGVvZiBxdWVyeVZhbHVlKSByZXN1bHQgPSBcIjFcIjsgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmVzdWx0ID0gcXVlcnlWYWx1ZS50b1N0cmluZygpOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcXVlcnlWYWx1ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gcXVlcnlWYWx1ZSA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHF1ZXJ5VmFsdWUpKSAmJiBudWxsICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJqc29uXCIgIT09IHByb3Auc2VyaWFsaXphdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICgwLCBfbGliLmRvdGlmeSkocXVlcnlWYWx1ZSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gT2JqZWN0LmtleXMocmVzdWx0KSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjQgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdGtleSA9IF9yZWY0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZG90a2V5XSA9IHJlc3VsdFtkb3RrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShxdWVyeVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIFwibnVtYmVyXCIgPT0gdHlwZW9mIHF1ZXJ5VmFsdWUgJiYgKHJlc3VsdCA9IHF1ZXJ5VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1txdWVyeVBhcmFtXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVQcm9wKGNvbXBvbmVudCwgaW5zdGFuY2UsIHByb3BzLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBjb21wb25lbnQuZ2V0UHJvcChrZXkpLCByZXN1bHRWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAhKHJlc3VsdFZhbHVlID0gcHJvcC52YWx1ZSA/IHByb3AudmFsdWUgOiAhcHJvcC5kZWYgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCAhPT0gdmFsdWUgJiYgdm9pZCAwICE9PSB2YWx1ZSAmJiBcIlwiICE9PSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KHZhbHVlKSA/IHZhbHVlIDogcHJvcC5kZWYuY2FsbChjb21wb25lbnQsIHByb3BzKSkgJiYgcHJvcC5hbGlhcyAmJiBwcm9wc1twcm9wLmFsaWFzXSAmJiAocmVzdWx0VmFsdWUgPSBwcm9wc1twcm9wLmFsaWFzXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9ICExO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wLmRlY29yYXRlICYmIG51bGwgIT09IHJlc3VsdFZhbHVlICYmIHZvaWQgMCAhPT0gcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0VmFsdWUgPSBwcm9wLmRlY29yYXRlLmNhbGwoaW5zdGFuY2UsIHJlc3VsdFZhbHVlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRlZCA9ICEwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoXCJib29sZWFuXCIgPT09IHR5cGUpIHJlc3VsdFZhbHVlID0gQm9vbGVhbihyZXN1bHRWYWx1ZSk7IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdFZhbHVlICYmIHByb3Aubm9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VmFsdWUgPSBfbGliLm5vb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZGVjb3JhdGVkICYmIHByb3AuZGVjb3JhdGUgJiYgKHJlc3VsdFZhbHVlID0gcHJvcC5kZWNvcmF0ZS5jYWxsKGluc3RhbmNlLCBfbGliLm5vb3AsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFZhbHVlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gcmVzdWx0VmFsdWUuYmluZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmRlbm9kZWlmeSAmJiAocmVzdWx0VmFsdWUgPSAoMCwgX2xpYi5kZW5vZGVpZnkpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLnByb21pc2lmeSAmJiAocmVzdWx0VmFsdWUgPSAoMCwgX2xpYi5wcm9taXNpZnkpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSByZXN1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmxvZyhcImNhbGxfcHJvcF9cIiArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC5vbmNlICYmIChyZXN1bHRWYWx1ZSA9ICgwLCBfbGliLm9uY2UpKHJlc3VsdFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLm1lbW9pemUgJiYgKHJlc3VsdFZhbHVlID0gKDAsIF9saWIubWVtb2l6ZSkocmVzdWx0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBcInN0cmluZ1wiID09PSB0eXBlIHx8IFwib2JqZWN0XCIgPT09IHR5cGUgfHwgXCJudW1iZXJcIiA9PT0gdHlwZSAmJiB2b2lkIDAgIT09IHJlc3VsdFZhbHVlICYmIChyZXN1bHRWYWx1ZSA9IHBhcnNlSW50KHJlc3VsdFZhbHVlLCAxMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L3ZhbGlkYXRlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9IDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlUHJvcCA9IHZhbGlkYXRlUHJvcDtcbiAgICAgICAgICAgIGV4cG9ydHMudmFsaWRhdGVQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWQgPSAhKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdKSB8fCBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wcyA9IHByb3BzIHx8IHt9KS5lbnYgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihjb21wb25lbnQudXJsKSAmJiAhY29tcG9uZW50LnVybFtwcm9wcy5lbnZdKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVudjogXCIgKyBwcm9wcy5lbnYpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9yZWYsIHByb3AgPSBjb21wb25lbnQuZ2V0UHJvcChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcC5hbGlhcyAmJiBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wLmFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbcHJvcC5hbGlhc107XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbcHJvcC5hbGlhc107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1trZXldIHx8IChwcm9wc1trZXldID0gdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhwcm9wcyksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgPyBfaXRlcmF0b3IyIDogX2l0ZXJhdG9yMltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kyID49IF9pdGVyYXRvcjIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2l0ZXJhdG9yMltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBfa2V5ID0gX3JlZjIsIF9wcm9wID0gY29tcG9uZW50LmdldFByb3AoX2tleSksIF92YWx1ZSA9IHByb3BzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBfcHJvcCAmJiB2YWxpZGF0ZVByb3AoX3Byb3AsIF9rZXksIF92YWx1ZSwgcHJvcHMsIHJlcXVpcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbXBvbmVudC5nZXRQcm9wTmFtZXMoKSwgX2lzQXJyYXkzID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IzKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/IF9pdGVyYXRvcjMgOiBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNBcnJheTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTMgPj0gX2l0ZXJhdG9yMy5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kzID0gX2l0ZXJhdG9yMy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9rZXkyID0gX3JlZjMsIF9wcm9wMiA9IGNvbXBvbmVudC5nZXRQcm9wKF9rZXkyKSwgX3ZhbHVlMiA9IHByb3BzW19rZXkyXTtcbiAgICAgICAgICAgICAgICAgICAgX3Byb3AyICYmICFwcm9wcy5oYXNPd25Qcm9wZXJ0eShfa2V5MikgJiYgdmFsaWRhdGVQcm9wKF9wcm9wMiwgX2tleTIsIF92YWx1ZTIsIHByb3BzLCByZXF1aXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcChwcm9wLCBrZXksIHZhbHVlLCBwcm9wcykge1xuICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZCA9ICEoYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbNF0pIHx8IGFyZ3VtZW50c1s0XTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gdmFsdWUgJiYgdm9pZCAwICE9PSB2YWx1ZSAmJiBcIlwiICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdmFsdWUudGhlbiB8fCAhcHJvcC5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSBwcm9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB2YWx1ZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByb3AgaXMgbm90IG9mIHR5cGUgZnVuY3Rpb246IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gcHJvcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHZhbHVlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcCBpcyBub3Qgb2YgdHlwZSBzdHJpbmc6IFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gcHJvcC50eXBlKSB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzZXJpYWxpemUgcHJvcDogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIm51bWJlclwiID09PSBwcm9wLnR5cGUgJiYgaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wIGlzIG5vdCBhIG51bWJlcjogXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwcm9wLnZhbGlkYXRlICYmIHZhbHVlICYmIHByb3AudmFsaWRhdGUodmFsdWUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWlyZWQgJiYgITEgIT09IHByb3AucmVxdWlyZWQgJiYgIXByb3AuaGFzT3duUHJvcGVydHkoXCJkZWZcIikpIHRocm93IG5ldyBFcnJvcihcIlByb3AgaXMgcmVxdWlyZWQ6IFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9jb21wb25lbnQvd2luZG93LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UGFyZW50UmVuZGVyV2luZG93ID0gZXhwb3J0cy5nZXRQYXJlbnRDb21wb25lbnRXaW5kb3cgPSBleHBvcnRzLmdldENvbXBvbmVudE1ldGEgPSBleHBvcnRzLmlzWm9pZENvbXBvbmVudFdpbmRvdyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuYnVpbGRDaGlsZFdpbmRvd05hbWUgPSBmdW5jdGlvbihuYW1lLCB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaWQgPSAoMCwgX2xpYi51bmlxdWVJRCkoKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRvbWFpbiA9ICgwLCBfc3JjLmdldERvbWFpbikod2luZG93KTtcbiAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZE5hbWUgPSBub3JtYWxpemUobmFtZSksIGVuY29kZWRWZXJzaW9uID0gbm9ybWFsaXplKHZlcnNpb24pLCBlbmNvZGVkT3B0aW9ucyA9IChzdHIgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgXG4gICAgICAgICAgICAgICAgX2hpQmFzZTIuZGVmYXVsdC5lbmNvZGUoc3RyKS5yZXBsYWNlKC9cXD0vZywgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0cjtcbiAgICAgICAgICAgICAgICBpZiAoIWVuY29kZWROYW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5hbWU6IFwiICsgbmFtZSArIFwiIC0gbXVzdCBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghZW5jb2RlZFZlcnNpb24pIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbjogXCIgKyB2ZXJzaW9uICsgXCIgLSBtdXN0IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgXCJ4Y29tcG9uZW50XCIsIGVuY29kZWROYW1lLCBlbmNvZGVkVmVyc2lvbiwgZW5jb2RlZE9wdGlvbnMsIFwiXCIgXS5qb2luKFwiX19cIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRQYXJlbnREb21haW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TWV0YSgpLmRvbWFpbjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oX3JlZjMpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfcmVmMy53aWR0aCwgaGVpZ2h0ID0gX3JlZjMuaGVpZ2h0LCB4ID0gMCwgeSA9IDA7XG4gICAgICAgICAgICAgICAgd2lkdGggJiYgKHdpbmRvdy5vdXRlcldpZHRoID8geCA9IE1hdGgucm91bmQoKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMikgKyB3aW5kb3cuc2NyZWVuWCA6IHdpbmRvdy5zY3JlZW4ud2lkdGggJiYgKHggPSBNYXRoLnJvdW5kKCh3aW5kb3cuc2NyZWVuLndpZHRoIC0gd2lkdGgpIC8gMikpKTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgJiYgKHdpbmRvdy5vdXRlckhlaWdodCA/IHkgPSBNYXRoLnJvdW5kKCh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMikgKyB3aW5kb3cuc2NyZWVuWSA6IHdpbmRvdy5zY3JlZW4uaGVpZ2h0ICYmICh5ID0gTWF0aC5yb3VuZCgod2luZG93LnNjcmVlbi5oZWlnaHQgLSBoZWlnaHQpIC8gMikpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb2JqLCBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi11dGlscy9zcmMvaW5kZXguanNcIiksIF9oaUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvaGktYmFzZTMyL3NyYy9iYXNlMzIuanNcIiksIF9oaUJhc2UyID0gKG9iaiA9IF9oaUJhc2UpICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICAgICAgfSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIiksIF9jb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvY29uc3RhbnRzLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gbm9ybWFsaXplKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlteYS16MC05QS1aXSt8W15hLXowLTlBLVpdKyQvZywgXCJcIikucmVwbGFjZSgvW15hLXowLTlBLVpdKy9nLCBcIl9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmlzWm9pZENvbXBvbmVudFdpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXdpbmRvdy5uYW1lICYmIFwieGNvbXBvbmVudFwiID09PSB3aW5kb3cubmFtZS5zcGxpdChcIl9fXCIpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZ2V0Q29tcG9uZW50TWV0YSA9IGV4cG9ydHMuZ2V0Q29tcG9uZW50TWV0YSA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93Lm5hbWUpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZ2V0IGNvbXBvbmVudCBtZXRhIHdpdGhvdXQgd2luZG93IG5hbWVcIik7XG4gICAgICAgICAgICAgICAgdmFyIF93aW5kb3ckbmFtZSRzcGxpdDIgPSB3aW5kb3cubmFtZS5zcGxpdChcIl9fXCIpLCB6b2lkY29tcCA9IF93aW5kb3ckbmFtZSRzcGxpdDJbMF0sIG5hbWUgPSBfd2luZG93JG5hbWUkc3BsaXQyWzFdLCB2ZXJzaW9uID0gX3dpbmRvdyRuYW1lJHNwbGl0MlsyXSwgZW5jb2RlZE9wdGlvbnMgPSBfd2luZG93JG5hbWUkc3BsaXQyWzNdO1xuICAgICAgICAgICAgICAgIGlmIChcInhjb21wb25lbnRcIiAhPT0gem9pZGNvbXApIHRocm93IG5ldyBFcnJvcihcIldpbmRvdyBub3QgcmVuZGVyZWQgYnkgem9pZCAtIGdvdCBcIiArIHpvaWRjb21wKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyLCBjb21wb25lbnRNZXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudE1ldGEgPSBKU09OLnBhcnNlKChzdHIgPSBlbmNvZGVkT3B0aW9ucywgX2hpQmFzZTIuZGVmYXVsdC5kZWNvZGUoc3RyLnRvVXBwZXJDYXNlKCkpKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVjb2RlIGNvbXBvbmVudC1tZXRhOiBcIiArIGVuY29kZWRPcHRpb25zICsgXCIgXCIgKyAoMCwgX2xpYi5zdHJpbmdpZnlFcnJvcikoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE1ldGEubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50TWV0YS52ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKC9fL2csIFwiLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50TWV0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0V2luZG93QnlSZWYoX3JlZikge1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBfcmVmLnJlZiwgdWlkID0gX3JlZi51aWQsIGRpc3RhbmNlID0gX3JlZi5kaXN0YW5jZSwgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJlZiA9PT0gX2NvbnN0YW50cy5XSU5ET1dfUkVGRVJFTkNFUy5PUEVORVIgPyByZXN1bHQgPSAoMCwgX3NyYy5nZXRPcGVuZXIpKHdpbmRvdykgOiByZWYgPT09IF9jb25zdGFudHMuV0lORE9XX1JFRkVSRU5DRVMuVE9QID8gcmVzdWx0ID0gKDAsIFxuICAgICAgICAgICAgICAgIF9zcmMuZ2V0VG9wKSh3aW5kb3cpIDogcmVmID09PSBfY29uc3RhbnRzLldJTkRPV19SRUZFUkVOQ0VTLlBBUkVOVCAmJiAocmVzdWx0ID0gZGlzdGFuY2UgPyAoMCwgXG4gICAgICAgICAgICAgICAgX3NyYy5nZXROdGhQYXJlbnRGcm9tVG9wKSh3aW5kb3csIGRpc3RhbmNlKSA6ICgwLCBfc3JjLmdldFBhcmVudCkod2luZG93KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiA9PT0gX2NvbnN0YW50cy5XSU5ET1dfUkVGRVJFTkNFUy5HTE9CQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gKDAsIF9zcmMuZ2V0QW5jZXN0b3IpKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9ICgwLCBfc3JjLmdldEFsbEZyYW1lc0luV2luZG93KShhbmNlc3RvciksIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYyID0gX2kudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9yZWYyLCBnbG9iYWwgPSAoMCwgX2xpYi5nbG9iYWxGb3IpKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsICYmIGdsb2JhbC53aW5kb3dzICYmIGdsb2JhbC53aW5kb3dzW3VpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2xvYmFsLndpbmRvd3NbdWlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB3aW5kb3cgYnkgcmVmXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmdldFBhcmVudENvbXBvbmVudFdpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNZXRhID0gZ2V0Q29tcG9uZW50TWV0YSgpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50TWV0YSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBnZXQgcGFyZW50IGNvbXBvbmVudCB3aW5kb3cgLSB3aW5kb3cgbm90IHJlbmRlcmVkIGJ5IHpvaWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0J5UmVmKGNvbXBvbmVudE1ldGEuY29tcG9uZW50UGFyZW50KTtcbiAgICAgICAgICAgIH0pLCBleHBvcnRzLmdldFBhcmVudFJlbmRlcldpbmRvdyA9ICgwLCBfbGliLm1lbW9pemUpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRNZXRhID0gZ2V0Q29tcG9uZW50TWV0YSgpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50TWV0YSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBnZXQgcGFyZW50IGNvbXBvbmVudCB3aW5kb3cgLSB3aW5kb3cgbm90IHJlbmRlcmVkIGJ5IHpvaWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFdpbmRvd0J5UmVmKGNvbXBvbmVudE1ldGEucmVuZGVyUGFyZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2NvbnN0YW50cy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgWk9JRCA9IGV4cG9ydHMuWk9JRCA9IFwiem9pZFwiLCBQUk9QX1RZUEVTID0gKGV4cG9ydHMuX19aT0lEX18gPSBcIl9fXCIgKyBaT0lEICsgXCJfX1wiLCBcbiAgICAgICAgICAgIGV4cG9ydHMuUE9TVF9NRVNTQUdFID0ge1xuICAgICAgICAgICAgICAgIElOSVQ6IFpPSUQgKyBcIl9pbml0XCIsXG4gICAgICAgICAgICAgICAgUFJPUFM6IFpPSUQgKyBcIl9wcm9wc1wiLFxuICAgICAgICAgICAgICAgIFBST1BfQ0FMTEJBQ0s6IFpPSUQgKyBcIl9wcm9wX2NhbGxiYWNrXCIsXG4gICAgICAgICAgICAgICAgQ0xPU0U6IFpPSUQgKyBcIl9jbG9zZVwiLFxuICAgICAgICAgICAgICAgIENIRUNLX0NMT1NFOiBaT0lEICsgXCJfY2hlY2tfY2xvc2VcIixcbiAgICAgICAgICAgICAgICBSRURJUkVDVDogWk9JRCArIFwiX3JlZGlyZWN0XCIsXG4gICAgICAgICAgICAgICAgUkVTSVpFOiBaT0lEICsgXCJfcmVzaXplXCIsXG4gICAgICAgICAgICAgICAgT05SRVNJWkU6IFpPSUQgKyBcIl9vbnJlc2l6ZVwiLFxuICAgICAgICAgICAgICAgIERFTEVHQVRFOiBaT0lEICsgXCJfZGVsZWdhdGVcIixcbiAgICAgICAgICAgICAgICBBTExPV19ERUxFR0FURTogWk9JRCArIFwiX2FsbG93X2RlbGVnYXRlXCIsXG4gICAgICAgICAgICAgICAgRVJST1I6IFpPSUQgKyBcIl9lcnJvclwiLFxuICAgICAgICAgICAgICAgIEhJREU6IFpPSUQgKyBcIl9oaWRlXCIsXG4gICAgICAgICAgICAgICAgU0hPVzogWk9JRCArIFwiX3Nob3dcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5QUk9QX1RZUEVTID0ge1xuICAgICAgICAgICAgICAgIFNUUklORzogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBPQkpFQ1Q6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgRlVOQ1RJT046IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBCT09MRUFOOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBOVU1CRVI6IFwibnVtYmVyXCJcbiAgICAgICAgICAgIH0pLCBDT05URVhUX1RZUEVTID0gKGV4cG9ydHMuSU5JVElBTF9QUk9QUyA9IHtcbiAgICAgICAgICAgICAgICBSQVc6IFwicmF3XCIsXG4gICAgICAgICAgICAgICAgVUlEOiBcInVpZFwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLldJTkRPV19SRUZFUkVOQ0VTID0ge1xuICAgICAgICAgICAgICAgIE9QRU5FUjogXCJvcGVuZXJcIixcbiAgICAgICAgICAgICAgICBUT1A6IFwidG9wXCIsXG4gICAgICAgICAgICAgICAgUEFSRU5UOiBcInBhcmVudFwiLFxuICAgICAgICAgICAgICAgIEdMT0JBTDogXCJnbG9iYWxcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5QUk9QX1RZUEVTX0xJU1QgPSBPYmplY3Qua2V5cyhQUk9QX1RZUEVTKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBST1BfVFlQRVNba2V5XTtcbiAgICAgICAgICAgIH0pLCBleHBvcnRzLkNPTlRFWFRfVFlQRVMgPSB7XG4gICAgICAgICAgICAgICAgSUZSQU1FOiBcImlmcmFtZVwiLFxuICAgICAgICAgICAgICAgIFBPUFVQOiBcInBvcHVwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwb3J0cy5DTEFTU19OQU1FUyA9IHtcbiAgICAgICAgICAgICAgICBaT0lEOiBcIlwiICsgWk9JRCxcbiAgICAgICAgICAgICAgICBPVVRMRVQ6IFpPSUQgKyBcIi1vdXRsZXRcIixcbiAgICAgICAgICAgICAgICBDT01QT05FTlRfRlJBTUU6IFpPSUQgKyBcIi1jb21wb25lbnQtZnJhbWVcIixcbiAgICAgICAgICAgICAgICBQUkVSRU5ERVJfRlJBTUU6IFpPSUQgKyBcIi1wcmVyZW5kZXItZnJhbWVcIixcbiAgICAgICAgICAgICAgICBWSVNJQkxFOiBaT0lEICsgXCItdmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgIElOVklTSUJMRTogWk9JRCArIFwiLWludmlzaWJsZVwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkVWRU5UUyA9IHtcbiAgICAgICAgICAgICAgICBDTE9TRTogWk9JRCArIFwiLWNsb3NlXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuQVRUUklCVVRFUyA9IHtcbiAgICAgICAgICAgICAgICBJRlJBTUVfUExBQ0VIT0xERVI6IFwiZGF0YS16b2lkLVwiICsgWk9JRCArIFwiLXBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuQU5JTUFUSU9OX05BTUVTID0ge1xuICAgICAgICAgICAgICAgIFNIT1dfQ09OVEFJTkVSOiBaT0lEICsgXCItc2hvdy1jb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBTSE9XX0NPTVBPTkVOVDogWk9JRCArIFwiLXNob3ctY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgSElERV9DT05UQUlORVI6IFpPSUQgKyBcIi1oaWRlLWNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIEhJREVfQ09NUE9ORU5UOiBaT0lEICsgXCItaGlkZS1jb21wb25lbnRcIlxuICAgICAgICAgICAgfSwgZXhwb3J0cy5FVkVOVF9OQU1FUyA9IHtcbiAgICAgICAgICAgICAgICBDTElDSzogXCJjbGlja1wiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkNMT1NFX1JFQVNPTlMgPSB7XG4gICAgICAgICAgICAgICAgUEFSRU5UX0NBTEw6IFwicGFyZW50X2NhbGxcIixcbiAgICAgICAgICAgICAgICBDSElMRF9DQUxMOiBcImNoaWxkX2NhbGxcIixcbiAgICAgICAgICAgICAgICBDTE9TRV9ERVRFQ1RFRDogXCJjbG9zZV9kZXRlY3RlZFwiLFxuICAgICAgICAgICAgICAgIFVTRVJfQ0xPU0VEOiBcInVzZXJfY2xvc2VkXCIsXG4gICAgICAgICAgICAgICAgUEFSRU5UX0NMT1NFX0RFVEVDVEVEOiBcInBhcmVudF9jbG9zZV9kZXRlY3RlZFwiXG4gICAgICAgICAgICB9LCBleHBvcnRzLkNPTlRFWFRfVFlQRVNfTElTVCA9IE9iamVjdC5rZXlzKENPTlRFWFRfVFlQRVMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OVEVYVF9UWVBFU1trZXldO1xuICAgICAgICAgICAgfSksIGV4cG9ydHMuREVMRUdBVEUgPSB7XG4gICAgICAgICAgICAgICAgQ0FMTF9PUklHSU5BTDogXCJjYWxsX29yaWdpbmFsXCIsXG4gICAgICAgICAgICAgICAgQ0FMTF9ERUxFR0FURTogXCJjYWxsX2RlbGVnYXRlXCJcbiAgICAgICAgICAgIH0sIGV4cG9ydHMuV0lMRENBUkQgPSBcIipcIiwgZXhwb3J0cy5ERUZBVUxUX0RJTUVOU0lPTlMgPSB7XG4gICAgICAgICAgICAgICAgV0lEVEg6IDMwMCxcbiAgICAgICAgICAgICAgICBIRUlHSFQ6IDE1MFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmd1bGFyID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9saWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmd1bGFyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYW5ndWxhcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihjb21wb25lbnQsIG5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZy5tb2R1bGUoY29tcG9uZW50LnRhZywgW10pLmRpcmVjdGl2ZSgoMCwgX2xpYi5kYXNoZXJpemVUb0NhbWVsKShjb21wb25lbnQudGFnKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGUgPSB7fSwgX2l0ZXJhdG9yID0gY29tcG9uZW50LmdldFByb3BOYW1lcygpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2kgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVtfcmVmXSA9IFwiPVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lmxvb3NlUHJvcHMgJiYgKHNjb3BlLnByb3BzID0gXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdHJpY3Q6IFwiRVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXI6IFsgXCIkc2NvcGVcIiwgXCIkZWxlbWVudFwiLCBmdW5jdGlvbigkc2NvcGUsICRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubG9vc2VQcm9wcyAmJiAhJHNjb3BlLnByb3BzKSB0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYW5ndWxhciBiaW5kaW5ncyB0byB3b3JrLCBwcm9wIGRlZmluaXRpb25zIG11c3QgYmUgcGFzc2VkIHRvIHpvaWQuY3JlYXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubG9nKFwiaW5zdGFudGlhdGVfYW5ndWxhcl9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3BlUHJvcHMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNjb3BlLnByb3BzKSBzY29wZVByb3BzID0gJHNjb3BlLnByb3BzOyBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZVByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBPYmplY3Qua2V5cyhzY29wZSksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCAhPT0gJHNjb3BlW2tleV0gJiYgKHNjb3BlUHJvcHNba2V5XSA9ICRzY29wZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVQcm9wcyA9ICgwLCBfbGliLnJlcGxhY2VPYmplY3QpKHNjb3BlUHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiJGFwcGx5XCIgIT09ICRzY29wZS4kcm9vdC4kJHBoYXNlICYmIFwiJGRpZ2VzdFwiICE9PSAkc2NvcGUuJHJvb3QuJCRwaGFzZSkgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KGdldFByb3BzKCksIG51bGwsICRlbGVtZW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcigkZWxlbWVudFswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQudXBkYXRlUHJvcHMoZ2V0UHJvcHMoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuYW5ndWxhcjIgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkgJiYgKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSwgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLmFuZ3VsYXIyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oem9pZCwgX3JlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgQW5ndWxhckNvbXBvbmVudCA9IF9yZWYuQ29tcG9uZW50LCBOZ01vZHVsZSA9IF9yZWYuTmdNb2R1bGUsIEVsZW1lbnRSZWYgPSBfcmVmLkVsZW1lbnRSZWYsIE5nWm9uZSA9IF9yZWYuTmdab25lO1xuICAgICAgICAgICAgICAgICAgICB6b2lkLmxvZyhcImluaXRpYWxpemluZyBhbmd1bGFyMiBjb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRQcm9wcyA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbGliLnJlcGxhY2VPYmplY3QpKF9leHRlbmRzKHt9LCBjb21wb25lbnQuaW50ZXJuYWxQcm9wcywgY29tcG9uZW50LnByb3BzKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWx1ZSkgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcywgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQuem9uZS5ydW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBDb21wb25lbnRJbnN0YW5jZSA9IEFuZ3VsYXJDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHpvaWQudGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj48L2Rpdj5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0czogWyBcInByb3BzXCIgXVxuICAgICAgICAgICAgICAgICAgICB9KS5DbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogWyBFbGVtZW50UmVmLCBOZ1pvbmUsIGZ1bmN0aW9uKGVsZW1lbnRSZWYsIHpvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgcGFyZW50ID0gem9pZC5pbml0KGdldFByb3BzKHRoaXMpLCBudWxsLCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVuZGVyKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5nT25DaGFuZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC51cGRhdGVQcm9wcyhnZXRQcm9wcyh0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmdNb2R1bGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbIENvbXBvbmVudEluc3RhbmNlIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbIENvbXBvbmVudEluc3RhbmNlIF1cbiAgICAgICAgICAgICAgICAgICAgfSkuQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL2VtYmVyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvZHJpdmVycy9nbGltbWVyLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSAmJiAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nbGltbWVyID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24oY29tcG9uZW50LCBHbGltbWVyQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfR2xpbW1lckNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygc3VwZXJDbGFzcyAmJiBudWxsICE9PSBzdXBlckNsYXNzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXJDbGFzcyAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfShfY2xhc3MsIF9HbGltbWVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9jbGFzcygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgX2NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZiwgY2FsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjYWxsIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGNhbGwgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBjYWxsID8gc2VsZiA6IGNhbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh0aGlzLCBfR2xpbW1lckNvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzcy5wcm90b3R5cGUuZGlkSW5zZXJ0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXIoX2V4dGVuZHMoe30sIHRoaXMuYXJncyksIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfShHbGltbWVyQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2RyaXZlcnMvaW5kZXguanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgdmFyIF9zY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy9zY3JpcHQuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfc2NyaXB0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zY3JpcHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvcmVhY3QuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcmVhY3QpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlYWN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF92dWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy92dWUuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfdnVlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92dWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2FuZ3VsYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZHJpdmVycy9hbmd1bGFyLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2FuZ3VsYXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2FuZ3VsYXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2VtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvZW1iZXIuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZW1iZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtYmVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9nbGltbWVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2RyaXZlcnMvZ2xpbW1lci5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9nbGltbWVyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbGltbWVyW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9hbmd1bGFyMiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9kcml2ZXJzL2FuZ3VsYXIyLmpzXCIpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX2FuZ3VsYXIyKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9hbmd1bGFyMltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL3JlYWN0LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMucmVhY3QgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnJlYWN0ID0ge1xuICAgICAgICAgICAgICAgIGdsb2JhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuUmVhY3QgJiYgd2luZG93LlJlYWN0RE9NKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3Q6IHdpbmRvdy5SZWFjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0RE9NOiB3aW5kb3cuUmVhY3RET01cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihjb21wb25lbnQsIF9yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFJlYWN0ID0gX3JlZi5SZWFjdCwgUmVhY3RET00gPSBfcmVmLlJlYWN0RE9NO1xuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVDbGFzcyA/IGNvbXBvbmVudC5yZWFjdCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5sb2coXCJpbnN0YW50aWF0ZV9yZWFjdF9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUucGFyZW50ICYmIHRoaXMuc3RhdGUucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkgOiBjb21wb25lbnQucmVhY3QgPSBmdW5jdGlvbihfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBzdXBlckNsYXNzICYmIG51bGwgIT09IHN1cGVyQ2xhc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlckNsYXNzICYmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KF9jbGFzcywgX1JlYWN0JENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHRoaXMsIF9jbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2FsbCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBjYWxsICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgY2FsbCA/IHNlbGYgOiBjYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5sb2coXCJpbnN0YW50aWF0ZV9yZWFjdF9jb21wb25lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyksIHBhcmVudCA9IGNvbXBvbmVudC5pbml0KCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlbmRlcihlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUucGFyZW50ICYmIHRoaXMuc3RhdGUucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMucHJvcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9KFJlYWN0LkNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQucmVhY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9kcml2ZXJzL3NjcmlwdC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZXhwb3J0cy5zY3JpcHQgPSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnQsIGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlbmRlcihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUgJiYgXCJzY3JpcHRcIiA9PT0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgJiYgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgJiYgXCJhcHBsaWNhdGlvbi94LWNvbXBvbmVudFwiID09PSBlbGVtZW50LmF0dHJpYnV0ZXMudHlwZS52YWx1ZSAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFnICYmIHRhZyA9PT0gY29tcG9uZW50LnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubG9nKFwiaW5zdGFudGlhdGVfc2NyaXB0X2NvbXBvbmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5pbm5lclRleHQgPyBldmFsKFwiKFwiICsgZWxlbWVudC5pbm5lclRleHQgKyBcIilcIikgOiB7fSwgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgaGFzIG5vIHBhcmVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb250YWluZXIsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyKHByb3BzLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBzY2FuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpKSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiBfaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKF9yZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjYW4oKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgc2Nhbik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBzY2FuKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTU5vZGVJbnNlcnRlZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvZHJpdmVycy92dWUuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy52dWUgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgX2xpYiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvaW5kZXguanNcIik7XG4gICAgICAgICAgICBleHBvcnRzLnZ1ZSA9IHtcbiAgICAgICAgICAgICAgICBnbG9iYWw6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihjcmVhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdEF0dHJzOiAhMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuJGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gY29tcG9uZW50LmluaXQoKDAsIF9saWIuZXh0ZW5kKSh7fSwgdGhpcy4kYXR0cnMpLCBudWxsLCBlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVuZGVyKGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMuJGF0dHJzICYmIHRoaXMucGFyZW50LnVwZGF0ZVByb3BzKCgwLCBfbGliLmV4dGVuZCkoe30sIHRoaXMuJGF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9lcnJvci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLlBvcHVwT3BlbkVycm9yID0gUG9wdXBPcGVuRXJyb3I7XG4gICAgICAgICAgICBleHBvcnRzLkludGVncmF0aW9uRXJyb3IgPSBJbnRlZ3JhdGlvbkVycm9yO1xuICAgICAgICAgICAgZXhwb3J0cy5SZW5kZXJFcnJvciA9IFJlbmRlckVycm9yO1xuICAgICAgICAgICAgZnVuY3Rpb24gUG9wdXBPcGVuRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQb3B1cE9wZW5FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBJbnRlZ3JhdGlvbkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSW50ZWdyYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZW5kZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlbmRlckVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9pbmRleC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX2ludGVyZmFjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbnRlcmZhY2UuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfaW50ZXJmYWNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2Vba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgSU5URVJGQUNFID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICB2YXIgbmV3T2JqID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgIT0gb2JqKSBmb3IgKHZhciBrZXkgaW4gb2JqKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIChuZXdPYmpba2V5XSA9IG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfShfaW50ZXJmYWNlKTtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVmYXVsdCA9IElOVEVSRkFDRTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9pbnRlcmZhY2UuanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5DT05TVEFOVFMgPSBleHBvcnRzLnBvc3RSb2JvdCA9IGV4cG9ydHMuZ2V0Q3VycmVudFNjcmlwdERpciA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX2NvbXBvbmVudC5Db21wb25lbnQob3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRCeVRhZyA9IGZ1bmN0aW9uKHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29tcG9uZW50LkNvbXBvbmVudC5nZXRCeVRhZyh0YWcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfbGliID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9pbmRleC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEN1cnJlbnRTY3JpcHREaXJcIiwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfbGliLmdldEN1cnJlbnRTY3JpcHREaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBvcnRzLmRlc3Ryb3lBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcmVudC5QYXJlbnRDb21wb25lbnQuZGVzdHJveUFsbCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZXJyb3IpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Vycm9yW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICAgICAgdmFyIF9wb3N0Um9ib3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvcG9zdC1yb2JvdC9zcmMvaW5kZXguanNcIikpLCBfY29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbXBvbmVudC9pbmRleC5qc1wiKSwgX3BhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb21wb25lbnQvcGFyZW50L2luZGV4LmpzXCIpLCBfQ09OU1RBTlRTID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2NvbnN0YW50cy5qc1wiKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBvYmopIGZvciAodmFyIGtleSBpbiBvYmopIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgKG5ld09ialtrZXldID0gb2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIG5ld09iai5kZWZhdWx0ID0gb2JqO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLnBvc3RSb2JvdCA9IF9wb3N0Um9ib3QsIGV4cG9ydHMuQ09OU1RBTlRTID0gX0NPTlNUQU5UUztcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvY3NzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuaXNQZXJjID0gaXNQZXJjO1xuICAgICAgICAgICAgZXhwb3J0cy5pc1B4ID0gaXNQeDtcbiAgICAgICAgICAgIGV4cG9ydHMudG9OdW0gPSB0b051bTtcbiAgICAgICAgICAgIGV4cG9ydHMudG9QeCA9IHRvUHg7XG4gICAgICAgICAgICBleHBvcnRzLnRvQ1NTID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHRvUHgodmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQZXJjKHZhbCkgPyB2YWwgOiB0b1B4KHZhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wZXJjT2YgPSBwZXJjT2Y7XG4gICAgICAgICAgICBleHBvcnRzLm5vcm1hbGl6ZURpbWVuc2lvbiA9IGZ1bmN0aW9uKGRpbSwgbWF4KSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGRpbSkgcmV0dXJuIGRpbTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQZXJjKGRpbSkpIHJldHVybiBwZXJjT2YobWF4LCBkaW0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1B4KGRpbSkpIHJldHVybiB0b051bShkaW0pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgbm9ybWFsaXplIGRpbWVuc2lvbjogXCIgKyBkaW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUGVyYyhzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2Ygc3RyICYmIC9eWzAtOV0rJSQvLnRlc3Qoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzUHgoc3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHN0ciAmJiAvXlswLTldK3B4JC8udGVzdChzdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdG9OdW0odmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goL14oWzAtOV0rKShweHwlKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgbWF0Y2ggY3NzIHZhbHVlIGZyb20gXCIgKyB2YWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdG9QeCh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9OdW0odmFsKSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBlcmNPZihudW0sIHBlcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtICogdG9OdW0ocGVyYykgLyAxMDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvZGVjb3JhdG9ycy5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLm1lbW9pemVkID0gZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbWVtb2l6ZWRfXyA9IHRoaXMuX19tZW1vaXplZF9fIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbWVtb2l6ZWRfXy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCAodGhpcy5fX21lbW9pemVkX19bbmFtZV0gPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWVtb2l6ZWRfX1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUuZGlzcGxheU5hbWUgPSBuYW1lICsgXCI6bWVtb2l6ZWRcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnByb21pc2UgPSBmdW5jdGlvbih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkobWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZS5kaXNwbGF5TmFtZSA9IG5hbWUgKyBcIjpwcm9taXNpZmllZFwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3phbGdvLXByb21pc2Uvc3JjL2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2xpYi9kb20uanNcIjogZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9ICEwO1xuICAgICAgICAgICAgZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gZXhwb3J0cy5kb2N1bWVudFJlYWR5ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0sIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYXBwZW5kQ2hpbGQgPSBhcHBlbmRDaGlsZDtcbiAgICAgICAgICAgIGV4cG9ydHMucXVlcnlTZWxlY3RvckFsbCA9IHF1ZXJ5U2VsZWN0b3JBbGw7XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnRTYWZlID0gZ2V0RWxlbWVudFNhZmU7XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnQgPSBnZXRFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0RvY3VtZW50UmVhZHkgPSBpc0RvY3VtZW50UmVhZHk7XG4gICAgICAgICAgICBleHBvcnRzLmVsZW1lbnRSZWFkeSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gKDAsIF91dGlsLnN0cmluZ2lmeSkoaWQpLCBlbCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsKSByZXR1cm4gcmVzb2x2ZShlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSkgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsID0gZ2V0RWxlbWVudFNhZmUoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJEb2N1bWVudCBpcyByZWFkeSBhbmQgZWxlbWVudCBcIiArIG5hbWUgKyBcIiBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnBvcHVwID0gZnVuY3Rpb24odXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkgcmV0dXJuIGtleSArIFwiPVwiICsgKDAsIF91dGlsLnN0cmluZ2lmeSkob3B0aW9uc1trZXldKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIixcIiksIHdpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW5kb3cub3Blbih1cmwsIG9wdGlvbnMubmFtZSwgcGFyYW1zLCAhMCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBfZXJyb3IuUG9wdXBPcGVuRXJyb3IoXCJDYW4gbm90IG9wZW4gcG9wdXAgd2luZG93IC0gXCIgKyAoZXJyLnN0YWNrIHx8IGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX3NyYy5pc1dpbmRvd0Nsb3NlZCkod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IF9lcnJvci5Qb3B1cE9wZW5FcnJvcihcIkNhbiBub3Qgb3BlbiBwb3B1cCB3aW5kb3cgLSBibG9ja2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aW47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy53cml0ZVRvV2luZG93ID0gd3JpdGVUb1dpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMud3JpdGVFbGVtZW50VG9XaW5kb3cgPSB3cml0ZUVsZW1lbnRUb1dpbmRvdztcbiAgICAgICAgICAgIGV4cG9ydHMuc2V0U3R5bGUgPSBzZXRTdHlsZTtcbiAgICAgICAgICAgIGV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG4gICAgICAgICAgICBleHBvcnRzLmF3YWl0RnJhbWVMb2FkID0gYXdhaXRGcmFtZUxvYWQ7XG4gICAgICAgICAgICBleHBvcnRzLmF3YWl0RnJhbWVXaW5kb3cgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5jb250ZW50V2luZG93KSByZXR1cm4gX3NyYzIuWmFsZ29Qcm9taXNlLnJlc29sdmUoZnJhbWUuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0RnJhbWVMb2FkKGZyYW1lKS50aGVuKGZ1bmN0aW9uKGxvYWRlZEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9hZGVkRnJhbWUuY29udGVudFdpbmRvdykgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2luZG93IGluIGlmcmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRlZEZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzBdID8gYXJndW1lbnRzWzBdIDoge30sIGVsID0gZ2V0RWxlbWVudChhcmd1bWVudHNbMV0pLCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9LCBzdHlsZSA9IG9wdGlvbnMuc3R5bGUgfHwge30sIGZyYW1lID0gY3JlYXRlRWxlbWVudChcImlmcmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lQm9yZGVyOiBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93VHJhbnNwYXJlbmN5OiBcInRydWVcIlxuICAgICAgICAgICAgICAgICAgICB9LCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgICAgICAgICAgICAgIH0sIHN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogb3B0aW9ucy5odG1sLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkKGZyYW1lKTtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFtZSk7XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMudXJsIHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFfEVkZ2UvaSkpICYmIGZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBvcHRpb25zLnVybCB8fCBcImFib3V0OmJsYW5rXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihvYmosIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgb2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2NhbkZvckphdmFzY3JpcHQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0cikgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyLm1hdGNoKC88c2NyaXB0fG9uXFx3K1xccyo9fGphdmFzY3JpcHQ6fGV4cHJlc3Npb25cXHMqXFwofGV2YWxcXCh8bmV3XFxzKkZ1bmN0aW9uLykpIHRocm93IG5ldyBFcnJvcihcIkhUTUwgY29udGFpbnMgcG90ZW50aWFsIGphdmFzY3JpcHQ6IFwiICsgc3RyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VRdWVyeSh3aW5kb3cubG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpKVtuYW1lXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmZvcm1hdFF1ZXJ5ID0gZm9ybWF0UXVlcnk7XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZFF1ZXJ5ID0gZXh0ZW5kUXVlcnk7XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZFVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5IHx8IHt9LCBoYXNoID0gb3B0aW9ucy5oYXNoIHx8IHt9LCBvcmlnaW5hbFVybCA9IHZvaWQgMCwgb3JpZ2luYWxIYXNoID0gdm9pZCAwLCBfdXJsJHNwbGl0ID0gdXJsLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFVybCA9IF91cmwkc3BsaXRbMF07XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxIYXNoID0gX3VybCRzcGxpdFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgX29yaWdpbmFsVXJsJHNwbGl0ID0gb3JpZ2luYWxVcmwuc3BsaXQoXCI/XCIpO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsVXJsID0gX29yaWdpbmFsVXJsJHNwbGl0WzBdO1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IGV4dGVuZFF1ZXJ5KF9vcmlnaW5hbFVybCRzcGxpdFsxXSwgcXVlcnkpLCBoYXNoU3RyaW5nID0gZXh0ZW5kUXVlcnkob3JpZ2luYWxIYXNoLCBoYXNoKTtcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZyAmJiAob3JpZ2luYWxVcmwgPSBvcmlnaW5hbFVybCArIFwiP1wiICsgcXVlcnlTdHJpbmcpO1xuICAgICAgICAgICAgICAgIGhhc2hTdHJpbmcgJiYgKG9yaWdpbmFsVXJsID0gb3JpZ2luYWxVcmwgKyBcIiNcIiArIGhhc2hTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFVybDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmVsZW1lbnRTdG9wcGVkTW92aW5nID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiA1ZTM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IGdldEVsZW1lbnQoZWxlbWVudCksIHN0YXJ0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGludGVydmFsID0gdm9pZCAwLCB0aW1lciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydC50b3AgPT09IGVuZC50b3AgJiYgc3RhcnQuYm90dG9tID09PSBlbmQuYm90dG9tICYmIHN0YXJ0LmxlZnQgPT09IGVuZC5sZWZ0ICYmIHN0YXJ0LnJpZ2h0ID09PSBlbmQucmlnaHQgJiYgc3RhcnQud2lkdGggPT09IGVuZC53aWR0aCAmJiBzdGFydC5oZWlnaHQgPT09IGVuZC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lZCBvdXQgd2FpdGluZyBmb3IgZWxlbWVudCB0byBzdG9wIGFuaW1hdGluZyBhZnRlciBcIiArIHRpbWVvdXQgKyBcIm1zXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRDdXJyZW50RGltZW5zaW9ucyA9IGdldEN1cnJlbnREaW1lbnNpb25zO1xuICAgICAgICAgICAgZXhwb3J0cy5jaGFuZ2VTdHlsZSA9IGZ1bmN0aW9uKGVsLCBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLCBfaXNBcnJheTMgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjMpLCBfaTMgPSAwLCBfaXRlcmF0b3IzID0gX2lzQXJyYXkzID8gX2l0ZXJhdG9yMyA6IF9pdGVyYXRvcjNbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMyA+PSBfaXRlcmF0b3IzLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3JlZjM7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gc3R5bGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNldE92ZXJmbG93ID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IFwiYXV0b1wiLCBfZWwkc3R5bGUgPSBlbC5zdHlsZSwgb3ZlcmZsb3cgPSBfZWwkc3R5bGUub3ZlcmZsb3csIG92ZXJmbG93WCA9IF9lbCRzdHlsZS5vdmVyZmxvd1gsIG92ZXJmbG93WSA9IF9lbCRzdHlsZS5vdmVyZmxvd1k7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3cgPSBlbC5zdHlsZS5vdmVyZmxvd1ggPSBlbC5zdHlsZS5vdmVyZmxvd1kgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dYID0gb3ZlcmZsb3dYO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dZID0gb3ZlcmZsb3dZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnRyYWNrRGltZW5zaW9ucyA9IHRyYWNrRGltZW5zaW9ucztcbiAgICAgICAgICAgIGV4cG9ydHMub25EaW1lbnNpb25zQ2hhbmdlID0gZnVuY3Rpb24oZWwsIF9yZWY2KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY2JHdpZHRoID0gX3JlZjYud2lkdGgsIHdpZHRoID0gdm9pZCAwID09PSBfcmVmNiR3aWR0aCB8fCBfcmVmNiR3aWR0aCwgX3JlZjYkaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWY2JGhlaWdodCB8fCBfcmVmNiRoZWlnaHQsIF9yZWY2JGRlbGF5ID0gX3JlZjYuZGVsYXksIGRlbGF5ID0gdm9pZCAwID09PSBfcmVmNiRkZWxheSA/IDUwIDogX3JlZjYkZGVsYXksIF9yZWY2JHRocmVzaG9sZCA9IF9yZWY2LnRocmVzaG9sZCwgdGhyZXNob2xkID0gdm9pZCAwID09PSBfcmVmNiR0aHJlc2hvbGQgPyAwIDogX3JlZjYkdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrZXIgPSB0cmFja0RpbWVuc2lvbnMoZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgICAgICAgfSksIGludGVydmFsID0gdm9pZCAwLCByZXNvbHZlciA9ICgwLCBfZm4uZGVib3VuY2UpKGZ1bmN0aW9uKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGltZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDQgKiBkZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RyYWNrZXIkY2hlY2sgPSB0cmFja2VyLmNoZWNrKCksIGNoYW5nZWQgPSBfdHJhY2tlciRjaGVjay5jaGFuZ2VkLCBkaW1lbnNpb25zID0gX3RyYWNrZXIkY2hlY2suZGltZW5zaW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tlci5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlcihkaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBmdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdHJhY2tlciRjaGVjazIgPSB0cmFja2VyLmNoZWNrKCksIGNoYW5nZWQgPSBfdHJhY2tlciRjaGVjazIuY2hhbmdlZCwgZGltZW5zaW9ucyA9IF90cmFja2VyJGNoZWNrMi5kaW1lbnNpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgb25XaW5kb3dSZXNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRpbWVuc2lvbnNNYXRjaFZpZXdwb3J0ID0gZnVuY3Rpb24oZWwsIF9yZWY3KSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX3JlZjcud2lkdGgsIGhlaWdodCA9IF9yZWY3LmhlaWdodCwgZGltZW5zaW9ucyA9IGdldEN1cnJlbnREaW1lbnNpb25zKGVsKTtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggJiYgZGltZW5zaW9ucy53aWR0aCAhPT0gd2luZG93LmlubmVyV2lkdGgpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ICYmIGRpbWVuc2lvbnMuaGVpZ2h0ICE9PSB3aW5kb3cuaW5uZXJIZWlnaHQpIHJldHVybiAhMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5iaW5kRXZlbnRzID0gYmluZEV2ZW50cztcbiAgICAgICAgICAgIGV4cG9ydHMuc2V0VmVuZG9yQ1NTID0gc2V0VmVuZG9yQ1NTO1xuICAgICAgICAgICAgZXhwb3J0cy5hbmltYXRlID0gYW5pbWF0ZTtcbiAgICAgICAgICAgIGV4cG9ydHMubWFrZUVsZW1lbnRWaXNpYmxlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIsIFwiXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMubWFrZUVsZW1lbnRJbnZpc2libGUgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcInZpc2liaWxpdHlcIiwgU1RZTEUuVklTSUJJTElUWS5ISURERU4sIFNUWUxFLklNUE9SVEFOVCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zaG93RWxlbWVudCA9IHNob3dFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5oaWRlRWxlbWVudCA9IGhpZGVFbGVtZW50O1xuICAgICAgICAgICAgZXhwb3J0cy5kZXN0cm95RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2hvd0FuZEFuaW1hdGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCBjbGVhbikge1xuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmltYXRlKGVsZW1lbnQsIG5hbWUsIGNsZWFuKTtcbiAgICAgICAgICAgICAgICBzaG93RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuYW5pbWF0ZUFuZEhpZGUgPSBmdW5jdGlvbihlbGVtZW50LCBuYW1lLCBjbGVhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRlKGVsZW1lbnQsIG5hbWUsIGNsZWFuKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoaWRlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmFkZENsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpIDogLTEgPT09IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuaW5kZXhPZihuYW1lKSAmJiAoZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWxlbWVudCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0ID8gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpIDogLTEgIT09IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KC9cXHMrLykuaW5kZXhPZihuYW1lKSAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKG5hbWUsIFwiXCIpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEN1cnJlbnRTY3JpcHREaXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEbyBub3QgdXNlIHpvaWQuZ2V0Q3VycmVudFNjcmlwdERpcigpIGluIHByb2R1Y3Rpb24gLS0gYnJvd3NlciBzdXBwb3J0IGlzIGxpbWl0ZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYy5zcGxpdChcIi9cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi5cIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmdldEVsZW1lbnROYW1lID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBlbGVtZW50KSByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQudGFnTmFtZSkgcmV0dXJuIFwiPHVua25vd24+XCI7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlkID8gbmFtZSArPSBcIiNcIiArIGVsZW1lbnQuaWQgOiBlbGVtZW50LmNsYXNzTmFtZSAmJiAobmFtZSArPSBcIi5cIiArIGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5pc0VsZW1lbnRDbG9zZWQgPSBpc0VsZW1lbnRDbG9zZWQ7XG4gICAgICAgICAgICBleHBvcnRzLndhdGNoRWxlbWVudEZvckNsb3NlID0gZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSAoMCwgX2ZuLm9uY2UpKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpc0VsZW1lbnRDbG9zZWQoZWxlbWVudCkgPyBoYW5kbGVyKCkgOiBpbnRlcnZhbCA9ICgwLCBfdXRpbC5zYWZlSW50ZXJ2YWwpKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbGVtZW50Q2xvc2VkKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgJiYgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SHR0cFR5cGUgPSBnZXRIdHRwVHlwZTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0SFRNTCA9IGdldEhUTUw7XG4gICAgICAgICAgICBleHBvcnRzLmdldENTUyA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIdHRwVHlwZShcInRleHQvY3NzXCIsIHVybCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXRTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SHR0cFR5cGUoXCIqLypcIiwgdXJsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnByZWZldGNoUGFnZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRIVE1MKHVybCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5maXhTY3JpcHRzID0gZml4U2NyaXB0cztcbiAgICAgICAgICAgIGV4cG9ydHMuanN4RG9tID0gZnVuY3Rpb24obmFtZSwgcHJvcHMsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzICYmIHRoaXMuY3JlYXRlRWxlbWVudCA/IHRoaXMgOiB3aW5kb3cuZG9jdW1lbnQsIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wcykgaWYgKHByb3AgaW4gSlNYX0VWRU5UUykgZWwuYWRkRXZlbnRMaXN0ZW5lcihKU1hfRVZFTlRTW3Byb3BdLCBwcm9wc1twcm9wXSk7IGVsc2UgaWYgKFwiaW5uZXJIVE1MXCIgPT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gcHJvcHNbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGZpeFNjcmlwdHMoZWwsIGRvYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBwcm9wc1twcm9wXSk7XG4gICAgICAgICAgICAgICAgaWYgKFwic3R5bGVcIiA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgY29udGVudCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFwiICsgbmFtZSArIFwiIHRhZyBjb250ZW50IHRvIGJlIHN0cmluZywgZ290IFwiICsgKHZvaWQgMCA9PT0gY29udGVudCA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnRlbnQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb25seSB0ZXh0IGNvbnRlbnQgZm9yIFwiICsgbmFtZSArIFwiIHRhZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGUoZWwsIGNvbnRlbnQsIGRvYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcImlmcmFtZVwiID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgb25seSBzaW5nbGUgY2hpbGQgbm9kZSBmb3IgaWZyYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aW4gPSBlbC5jb250ZW50V2luZG93O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGZyYW1lIHRvIGhhdmUgY29udGVudFdpbmRvd1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIGNvbnRlbnQgPyB3cml0ZVRvV2luZG93KHdpbiwgY29udGVudCkgOiB3cml0ZUVsZW1lbnRUb1dpbmRvdyh3aW4sIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwic2NyaXB0XCIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGNvbnRlbnQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcIiArIG5hbWUgKyBcIiB0YWcgY29udGVudCB0byBiZSBzdHJpbmcsIGdvdCBcIiArICh2b2lkIDAgPT09IGNvbnRlbnQgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb250ZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9ubHkgdGV4dCBjb250ZW50IGZvciBcIiArIG5hbWUgKyBcIiB0YWdcIik7XG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhcmd1bWVudHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZChlbCwgdGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBhcHBlbmRDaGlsZChlbCwgYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX3NyYzIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvemFsZ28tcHJvbWlzZS9zcmMvaW5kZXguanNcIiksIF9zcmMzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2Nyb3NzLWRvbWFpbi1zYWZlLXdlYWttYXAvc3JjL2luZGV4LmpzXCIpLCBfZXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvZXJyb3IuanNcIiksIF9mbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvZm4uanNcIiksIF91dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi91dGlsLmpzXCIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKGVsLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2FmZShpZCkge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQgfHwgbnVsbCAhPT0gZWxlbWVudCAmJiBcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBlbGVtZW50ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZWxlbWVudCkpICYmIDEgPT09IGVsZW1lbnQubm9kZVR5cGUgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihlbGVtZW50LnN0eWxlKSAmJiBcIm9iamVjdFwiID09PSBfdHlwZW9mKGVsZW1lbnQub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfShpZCkpIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvciAmJiAoZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEVsZW1lbnQoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGdldEVsZW1lbnRTYWZlKGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBmaW5kIGVsZW1lbnQ6IFwiICsgKDAsIF91dGlsLnN0cmluZ2lmeSkoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuZG9jdW1lbnRSZWFkeSA9IG5ldyBfc3JjMi5aYWxnb1Byb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChcImNvbXBsZXRlXCIgPT09IHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlKSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJjb21wbGV0ZVwiID09PSB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBpc0RvY3VtZW50UmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29tcGxldGVcIiA9PT0gd2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZVRvV2luZG93KHdpbiwgaHRtbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5kb2N1bWVudC53cml0ZShodG1sKTtcbiAgICAgICAgICAgICAgICAgICAgd2luLmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24gPSBcImphdmFzY3JpcHQ6IGRvY3VtZW50Lm9wZW4oKTsgZG9jdW1lbnQud3JpdGUoXCIgKyBKU09OLnN0cmluZ2lmeShodG1sKSArIFwiKTsgZG9jdW1lbnQuY2xvc2UoKTtcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyMikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB3cml0ZUVsZW1lbnRUb1dpbmRvdyh3aW4sIGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJodG1sXCIgIT09IHRhZykgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZWxlbWVudCB0byBiZSBodG1sLCBnb3QgXCIgKyB0YWcpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRvY3VtZW50RWxlbWVudCA9IHdpbi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IGRvY3VtZW50RWxlbWVudC5jaGlsZHJlbiAmJiBkb2N1bWVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyApIGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZChkb2N1bWVudEVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIGZvciAoO2VsLmNoaWxkcmVuLmxlbmd0aDsgKSBkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0U3R5bGUoZWwsIHN0eWxlVGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVNoZWV0ID8gZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gc3R5bGVUZXh0IDogZWwuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHN0eWxlVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMF0gPyBhcmd1bWVudHNbMF0gOiBcImRpdlwiLCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB7fSwgY29udGFpbmVyID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUgJiYgKDAsIF91dGlsLmV4dGVuZCkoZWxlbWVudC5zdHlsZSwgb3B0aW9ucy5zdHlsZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jbGFzcyAmJiAoZWxlbWVudC5jbGFzc05hbWUgPSBvcHRpb25zLmNsYXNzLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdHlsZVNoZWV0ICYmIHNldFN0eWxlKGVsZW1lbnQsIG9wdGlvbnMuc3R5bGVTaGVldCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyICYmIGFwcGVuZENoaWxkKGNvbnRhaW5lciwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHRtbCkgaWYgKFwiaWZyYW1lXCIgPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lciB8fCAhZWxlbWVudC5jb250ZW50V2luZG93KSB0aHJvdyBuZXcgRXJyb3IoXCJJZnJhbWUgaHRtbCBjYW4gbm90IGJlIHdyaXR0ZW4gdW5sZXNzIGNvbnRhaW5lciBwcm92aWRlZCBhbmQgaWZyYW1lIGluIERPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVUb1dpbmRvdyhlbGVtZW50LmNvbnRlbnRXaW5kb3csIG9wdGlvbnMuaHRtbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5odG1sO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMgPSBuZXcgX3NyYzMuV2Vha01hcCgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXdhaXRGcmFtZUxvYWQoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXdhaXRGcmFtZUxvYWRQcm9taXNlcy5oYXMoZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcHJvbWlzZSA9IGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuZ2V0KGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wcm9taXNlKSByZXR1cm4gX3Byb21pc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IF9zcmMyLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3NyYy5saW5rRnJhbWVXaW5kb3cpKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUuY29udGVudFdpbmRvdyA/IHJlc29sdmUoZnJhbWUpIDogcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0RnJhbWVMb2FkUHJvbWlzZXMuc2V0KGZyYW1lLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJzZVF1ZXJ5ID0gZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gKDAsIF9mbi5tZW1vaXplKShmdW5jdGlvbihxdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXF1ZXJ5U3RyaW5nKSByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmICgtMSA9PT0gcXVlcnlTdHJpbmcuaW5kZXhPZihcIj1cIikpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcGFyc2UgcXVlcnkgc3RyaW5nIHBhcmFtczogXCIgKyBxdWVyeVN0cmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBxdWVyeVN0cmluZy5zcGxpdChcIiZcIiksIF9pc0FycmF5MiA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yMiksIF9pMiA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyID0gX2lzQXJyYXkyID8gX2l0ZXJhdG9yMiA6IF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IyLmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IF9yZWYyO1xuICAgICAgICAgICAgICAgICAgICAocGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpKVswXSAmJiBwYWlyWzFdICYmIChwYXJhbXNbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdFF1ZXJ5KCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC51cmxFbmNvZGUpKGtleSkgKyBcIj1cIiArICgwLCBfdXRpbC51cmxFbmNvZGUpKG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiJlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZFF1ZXJ5KG9yaWdpbmFsUXVlcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcyAmJiBPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID8gZm9ybWF0UXVlcnkoX2V4dGVuZHMoe30sIHBhcnNlUXVlcnkob3JpZ2luYWxRdWVyeSksIHByb3BzKSkgOiBvcmlnaW5hbFF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogZWwub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHRyYWNrRGltZW5zaW9ucyhlbCwgX3JlZjUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjUkd2lkdGggPSBfcmVmNS53aWR0aCwgd2lkdGggPSB2b2lkIDAgPT09IF9yZWY1JHdpZHRoIHx8IF9yZWY1JHdpZHRoLCBfcmVmNSRoZWlnaHQgPSBfcmVmNS5oZWlnaHQsIGhlaWdodCA9IHZvaWQgMCA9PT0gX3JlZjUkaGVpZ2h0IHx8IF9yZWY1JGhlaWdodCwgX3JlZjUkdGhyZXNob2xkID0gX3JlZjUudGhyZXNob2xkLCB0aHJlc2hvbGQgPSB2b2lkIDAgPT09IF9yZWY1JHRocmVzaG9sZCA/IDAgOiBfcmVmNSR0aHJlc2hvbGQsIGN1cnJlbnREaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdEaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkOiBmdW5jdGlvbihvbmUsIHR3bywgX3JlZjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0JHdpZHRoID0gX3JlZjQud2lkdGgsIHdpZHRoID0gdm9pZCAwID09PSBfcmVmNCR3aWR0aCB8fCBfcmVmNCR3aWR0aCwgX3JlZjQkaGVpZ2h0ID0gX3JlZjQuaGVpZ2h0LCBoZWlnaHQgPSB2b2lkIDAgPT09IF9yZWY0JGhlaWdodCB8fCBfcmVmNCRoZWlnaHQsIF9yZWY0JHRocmVzaG9sZCA9IF9yZWY0LnRocmVzaG9sZCwgdGhyZXNob2xkID0gdm9pZCAwID09PSBfcmVmNCR0aHJlc2hvbGQgPyAwIDogX3JlZjQkdGhyZXNob2xkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISEod2lkdGggJiYgTWF0aC5hYnMob25lLndpZHRoIC0gdHdvLndpZHRoKSA+IHRocmVzaG9sZCkgfHwgISEoaGVpZ2h0ICYmIE1hdGguYWJzKG9uZS5oZWlnaHQgLSB0d28uaGVpZ2h0KSA+IHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfShjdXJyZW50RGltZW5zaW9ucywgbmV3RGltZW5zaW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IG5ld0RpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaW1lbnNpb25zID0gZ2V0Q3VycmVudERpbWVuc2lvbnMoZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoZWxlbWVudCwgZXZlbnROYW1lcywgaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSAoMCwgX2ZuLm9uY2UpKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gZXZlbnROYW1lcywgX2lzQXJyYXk0ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I0KSwgX2k0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgPyBfaXRlcmF0b3I0IDogX2l0ZXJhdG9yNFtTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k0ID49IF9pdGVyYXRvcjQubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2l0ZXJhdG9yNFtfaTQrK107XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9pNCA9IF9pdGVyYXRvcjQubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWY4ID0gX2k0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBfcmVmODtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbDogKDAsIF9mbi5vbmNlKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gZXZlbnROYW1lcywgX2lzQXJyYXk1ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I1KSwgX2k1ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/IF9pdGVyYXRvcjUgOiBfaXRlcmF0b3I1W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVmOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGgpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmOSA9IF9pNS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IF9yZWY5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgVkVORE9SX1BSRUZJWEVTID0gWyBcIndlYmtpdFwiLCBcIm1velwiLCBcIm1zXCIsIFwib1wiIF07XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRWZW5kb3JDU1MoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGNhcGl0YWxpemVkTmFtZSA9ICgwLCBfdXRpbC5jYXBpdGFsaXplRmlyc3RMZXR0ZXIpKG5hbWUpLCBfaXRlcmF0b3I2ID0gVkVORE9SX1BSRUZJWEVTLCBfaXNBcnJheTYgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvcjYpLCBfaTYgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNiA9IF9pc0FycmF5NiA/IF9pdGVyYXRvcjYgOiBfaXRlcmF0b3I2W1N5bWJvbC5pdGVyYXRvcl0oKTsgOykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjEwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2k2ID49IF9pdGVyYXRvcjYubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWYxMCA9IF9pdGVyYXRvcjZbX2k2KytdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTYgPSBfaXRlcmF0b3I2Lm5leHQoKSkuZG9uZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTAgPSBfaTYudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IF9yZWYxMDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtcIlwiICsgcHJlZml4ICsgY2FwaXRhbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBDU1NSdWxlID0gd2luZG93LkNTU1J1bGUsIEtFWUZSQU1FU19SVUxFID0gQ1NTUnVsZS5LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLldFQktJVF9LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLk1PWl9LRVlGUkFNRVNfUlVMRSB8fCBDU1NSdWxlLk9fS0VZRlJBTUVTX1JVTEUgfHwgQ1NTUnVsZS5NU19LRVlGUkFNRVNfUlVMRTtcbiAgICAgICAgICAgIHZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWyBcImFuaW1hdGlvbnN0YXJ0XCIsIFwid2Via2l0QW5pbWF0aW9uU3RhcnRcIiwgXCJvQW5pbWF0aW9uU3RhcnRcIiwgXCJNU0FuaW1hdGlvblN0YXJ0XCIgXSwgQU5JTUFUSU9OX0VORF9FVkVOVFMgPSBbIFwiYW5pbWF0aW9uZW5kXCIsIFwid2Via2l0QW5pbWF0aW9uRW5kXCIsIFwib0FuaW1hdGlvbkVuZFwiLCBcIk1TQW5pbWF0aW9uRW5kXCIgXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgbmFtZSwgY2xlYW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogMWUzO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVsIHx8ICFmdW5jdGlvbihlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzaGVldHMgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1J1bGVzID0gc3R5bGVzaGVldHNbaV0uY3NzUnVsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NSdWxlcykgZm9yICh2YXIgaiA9IDA7IGogPCBjc3NSdWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzc1J1bGUgPSBjc3NSdWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjc3NSdWxlICYmIGNzc1J1bGUudHlwZSA9PT0gS0VZRlJBTUVTX1JVTEUgJiYgY3NzUnVsZS5uYW1lID09PSBuYW1lKSByZXR1cm4gITA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgICAgICAgICAgIH0oZWwsIG5hbWUpKSByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3RhcnRlZCA9ICExLCBzdGFydFRpbWVvdXQgPSB2b2lkIDAsIGVuZFRpbWVvdXQgPSB2b2lkIDAsIHN0YXJ0RXZlbnQgPSB2b2lkIDAsIGVuZEV2ZW50ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmVuZG9yQ1NTKGVsLCBcImFuaW1hdGlvbk5hbWVcIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChlbmRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRFdmVudC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50ID0gYmluZEV2ZW50cyhlbCwgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGVsICYmIGV2ZW50LmFuaW1hdGlvbk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhcnRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N0YXJ0ZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbmRFdmVudCA9IGJpbmRFdmVudHMoZWwsIEFOSU1BVElPTl9FTkRfRVZFTlRTLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZWwgJiYgZXZlbnQuYW5pbWF0aW9uTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZXZlbnQuYW5pbWF0aW9uTmFtZSAmJiBldmVudC5hbmltYXRpb25OYW1lICE9PSBuYW1lID8gcmVqZWN0KFwiRXhwZWN0ZWQgYW5pbWF0aW9uIG5hbWUgdG8gYmUgXCIgKyBuYW1lICsgXCIsIGZvdW5kIFwiICsgZXZlbnQuYW5pbWF0aW9uTmFtZSkgOiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRWZW5kb3JDU1MoZWwsIFwiYW5pbWF0aW9uTmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiAmJiBjbGVhbihjbGVhblVwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBTVFlMRSA9IHtcbiAgICAgICAgICAgICAgICBESVNQTEFZOiB7XG4gICAgICAgICAgICAgICAgICAgIE5PTkU6IFwibm9uZVwiLFxuICAgICAgICAgICAgICAgICAgICBCTE9DSzogXCJibG9ja1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBWSVNJQklMSVRZOiB7XG4gICAgICAgICAgICAgICAgICAgIFZJU0lCTEU6IFwidmlzaWJsZVwiLFxuICAgICAgICAgICAgICAgICAgICBISURERU46IFwiaGlkZGVuXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIElNUE9SVEFOVDogXCJpbXBvcnRhbnRcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3dFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBTVFlMRS5ESVNQTEFZLk5PTkUsIFNUWUxFLklNUE9SVEFOVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpc0VsZW1lbnRDbG9zZWQoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWVsIHx8ICFlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SHR0cFR5cGUoY29udGVudFR5cGUsIHVybCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX3NyYzIuWmFsZ29Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXEub3BlbihcIkdFVFwiLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXEub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJwcmVmZXRjaCBmYWlsZWRcIikpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SFRNTCh1cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0SHR0cFR5cGUoXCJ0ZXh0L2h0bWxcIiwgdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBKU1hfRVZFTlRTID0ge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IFwiY2xpY2tcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpeFNjcmlwdHMoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMV0gPyBhcmd1bWVudHNbMV0gOiB3aW5kb3cuZG9jdW1lbnQsIF9pdGVyYXRvcjcgPSBxdWVyeVNlbGVjdG9yQWxsKGVsLCBcInNjcmlwdFwiKSwgX2lzQXJyYXk3ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3I3KSwgX2k3ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcgPSBfaXNBcnJheTcgPyBfaXRlcmF0b3I3IDogX2l0ZXJhdG9yN1tTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYxMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0FycmF5Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pNyA+PSBfaXRlcmF0b3I3Lmxlbmd0aCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmMTEgPSBfaXRlcmF0b3I3W19pNysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2k3ID0gX2l0ZXJhdG9yNy5uZXh0KCkpLmRvbmUpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjExID0gX2k3LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBfcmVmMTEsIG5ld1NjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQudGV4dCA9IHNjcmlwdC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1NjcmlwdCwgc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2ZuLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICBleHBvcnRzLm9uY2UgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGVkID0gITEsIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBjYWxsZWQgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5tZW1vaXplID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcInpvaWQ6bWVtb2l6ZVtcIiArICgwLCBfdXRpbC5nZXRPYmplY3RJRCkodmFsKSArIFwiXVwiIDogdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIG5vdCBzZXJpYWxpemFibGUgLS0gY2FuIG5vdCBiZSB1c2VkIHRvIG1lbW9pemVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkgfHwgKHJlc3VsdHNbY2FjaGVLZXldID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlYm91bmNlID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IDEwMCwgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMsIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3V0aWwucmVwbGFjZU9iamVjdCkob2JqLCB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX190eXBlX186IFwiX19mdW5jdGlvbl9fXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlc2VyaWFsaXplRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5yZXBsYWNlT2JqZWN0KShvYmosIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBmdW5jdGlvbih2YWx1ZSwga2V5LCBmdWxsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgXCJfX2Z1bmN0aW9uX19cIiA9PT0gdmFsdWUuX190eXBlX18pIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsS2V5OiBmdWxsS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL3V0aWwuanNcIik7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2dsb2JhbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLmdsb2JhbCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2xvYmFsRm9yID0gZ2xvYmFsRm9yO1xuICAgICAgICAgICAgZXhwb3J0cy5sb2NhbEdsb2JhbCA9IGxvY2FsR2xvYmFsO1xuICAgICAgICAgICAgdmFyIF9zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9ub2RlX21vZHVsZXMvY3Jvc3MtZG9tYWluLXV0aWxzL3NyYy9pbmRleC5qc1wiKSwgX2NvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9jb25zdGFudHMuanNcIik7XG4gICAgICAgICAgICBmdW5jdGlvbiBnbG9iYWxGb3Iod2luKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfc3JjLmlzU2FtZURvbWFpbikod2luKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5bX2NvbnN0YW50cy5fX1pPSURfX10gfHwgKHdpbltfY29uc3RhbnRzLl9fWk9JRF9fXSA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbltfY29uc3RhbnRzLl9fWk9JRF9fXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsb2NhbEdsb2JhbCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2xvYmFsID0gZ2xvYmFsRm9yKHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9iYWwpIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgbG9jYWwgZ2xvYmFsXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBvcnRzLmdsb2JhbCA9IGxvY2FsR2xvYmFsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2luZGV4LmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIHZhciBfZG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9kb20uanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZG9tKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kb21ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2ZuID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9mbi5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9mbikuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX3Byb21pc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL3Byb21pc2UuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfcHJvbWlzZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBcImRlZmF1bHRcIiAhPT0ga2V5ICYmIFwiX19lc01vZHVsZVwiICE9PSBrZXkgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcHJvbWlzZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvdXRpbC5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF91dGlsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF91dGlsW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9jc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2Nzcy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9jc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Nzc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfZGVjb3JhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9saWIvZGVjb3JhdG9ycy5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9kZWNvcmF0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9kZWNvcmF0b3JzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvbGliL2xvZ2dlci5qc1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKF9sb2dnZXIpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIgIT09IGtleSAmJiBcIl9fZXNNb2R1bGVcIiAhPT0ga2V5ICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2xvZ2dlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBfZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2xpYi9nbG9iYWwuanNcIik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhfZ2xvYmFsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiICE9PSBrZXkgJiYgXCJfX2VzTW9kdWxlXCIgIT09IGtleSAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nbG9iYWxba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiLi9zcmMvbGliL2xvZ2dlci5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICBleHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obG9nTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoLTEgPT09IF9jbGllbnQubG9nTGV2ZWxzLmluZGV4T2YobG9nTGV2ZWwpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxvZ0xldmVsOiBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgICAgICBfY2xpZW50LmNvbmZpZy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIF9zcmMuQ09ORklHLkxPR19MRVZFTCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5MT0dfTEVWRUwgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmluZm8gPSBmdW5jdGlvbihuYW1lLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgICAgICAgICAgICAoMCwgX2NsaWVudC5pbmZvKShcInhjX1wiICsgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMud2FybiA9IGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgICgwLCBfY2xpZW50Lndhcm4pKFwieGNfXCIgKyBuYW1lICsgXCJfXCIgKyBldmVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uKG5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICAgICAgICAgICgwLCBfY2xpZW50LmVycm9yKShcInhjX1wiICsgbmFtZSArIFwiX1wiICsgZXZlbnQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3Bvc3Qtcm9ib3Qvc3JjL2luZGV4LmpzXCIpLCBfY2xpZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL2JlYXZlci1sb2dnZXIvY2xpZW50L2luZGV4LmpzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL2xpYi9wcm9taXNlLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSAhMDtcbiAgICAgICAgICAgIGV4cG9ydHMuZGVub2RlaWZ5ID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPj0gbWV0aG9kLmxlbmd0aCA/IF9zcmMuWmFsZ29Qcm9taXNlLnJlc29sdmUobWV0aG9kLmFwcGx5KHNlbGYsIGFyZ3MpKSA6IG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHRocm93IG5ldyBFcnJvcihcIlBhc3NlZCBub24tRXJyb3Igb2JqZWN0IGluIGNhbGxiYWNrOiBbIFwiICsgZXJyICsgXCIgXSAtLSBjYWxsYmFja3Mgc2hvdWxkIGVpdGhlciBiZSBjYWxsZWQgd2l0aCBjYWxsYmFjayhuZXcgRXJyb3IoLi4uKSkgb3IgY2FsbGJhY2sobnVsbCwgcmVzdWx0KS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXMsIF9hcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRlbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1swXSA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfc3JjLlphbGdvUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jeWNsZSA9IGZ1bmN0aW9uIGN5Y2xlKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3JjLlphbGdvUHJvbWlzZS50cnkobWV0aG9kKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3ljbGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgX3NyYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy96YWxnby1wcm9taXNlL3NyYy9pbmRleC5qc1wiKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIuL3NyYy9saWIvdXRpbC5qc1wiOiBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcbiAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gITA7XG4gICAgICAgICAgICB2YXIgX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy51cmxFbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcPy9nLCBcIiUzRlwiKS5yZXBsYWNlKC8mL2csIFwiJTI2XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvXFwrL2csIFwiJTJCXCIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuY2FtZWxUb0Rhc2hlcml6ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi1cIiArIGcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmRhc2hlcml6ZVRvQ2FtZWwgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaiwgc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgc291cmNlLmhhc093blByb3BlcnR5KGtleSkgJiYgKG9ialtrZXldID0gc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHJlc3VsdHMucHVzaChvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy51bmlxdWVJRCA9IHVuaXF1ZUlEO1xuICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnlXaXRoRnVuY3Rpb25zID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdmFsID8gdmFsLnRvU3RyaW5nKCkgOiB2YWw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlR2V0ID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5nZXQgPSBmdW5jdGlvbihpdGVtLCBwYXRoLCBkZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBkZWY7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGF0aFBhcnRzID0gcGF0aC5zcGxpdChcIi5cIiksIGkgPSAwOyBpIDwgcGF0aFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpIHx8IG51bGwgPT09IGl0ZW0pIHJldHVybiBkZWY7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtW3BhdGhQYXJ0c1tpXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IGl0ZW0gPyBkZWYgOiBpdGVtO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuc2FmZUludGVydmFsID0gc2FmZUludGVydmFsO1xuICAgICAgICAgICAgZXhwb3J0cy5zYWZlVGltZW91dCA9IGZ1bmN0aW9uKG1ldGhvZCwgdGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNhZmVJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aW1lIC09IDEwMCkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkgZm9yICh2YXIgbGVuID0gaXRlbS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIGNhbGxiYWNrKGl0ZW1baV0sIGkpOyBlbHNlIGlmIChcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpKSBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSksIF9sZW4gPSBrZXlzLmxlbmd0aCwgX2kgPSAwOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMucmVwbGFjZU9iamVjdCA9IGZ1bmN0aW9uIHJlcGxhY2VPYmplY3QoaXRlbSwgcmVwbGFjZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bGxLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGxlbmd0aCA9IGl0ZW0ubGVuZ3RoLCByZXN1bHQgPSBbXSwgX2xvb3AgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtS2V5ID0gZnVsbEtleSA/IGZ1bGxLZXkgKyBcIi5cIiArIGkgOiBcIlwiICsgaSwgY2hpbGQgPSBpdGVtW2ldLCB0eXBlID0gdm9pZCAwID09PSBjaGlsZCA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNoaWxkKSwgcmVwbGFjZXIgPSByZXBsYWNlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZWQgPSByZXBsYWNlcihjaGlsZCwgaSwgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gcmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09ICh2b2lkIDAgPT09IGNoaWxkID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY2hpbGQpKSAmJiBudWxsICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHJlcGxhY2VPYmplY3QoY2hpbGQsIHJlcGxhY2VycywgaXRlbUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSBfbG9vcChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSAodm9pZCAwID09PSBfcmV0ID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoX3JldCkpKSByZXR1cm4gX3JldC52O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSBpdGVtID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaXRlbSkpIHx8IG51bGwgPT09IGl0ZW0pIHRocm93IG5ldyBFcnJvcihcIlBhc3MgYW4gb2JqZWN0IG9yIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3JldDMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fSwgX2xvb3AyID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KGtleSkpIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1LZXkgPSBmdWxsS2V5ID8gZnVsbEtleSArIFwiLlwiICsga2V5IDogXCJcIiArIGtleSwgY2hpbGQgPSBpdGVtW2tleV0sIHR5cGUgPSB2b2lkIDAgPT09IGNoaWxkID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY2hpbGQpLCByZXBsYWNlciA9IHJlcGxhY2Vyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlZCA9IHJlcGxhY2VyKGNoaWxkLCBrZXksIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVwbGFjZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gY2hpbGQgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjaGlsZCkpICYmIG51bGwgIT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXBsYWNlT2JqZWN0KGNoaWxkLCByZXBsYWNlcnMsIGl0ZW1LZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaXRlbSkgX2xvb3AyKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHY6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gKHZvaWQgMCA9PT0gX3JldDMgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihfcmV0MykpKSByZXR1cm4gX3JldDMudjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jb3B5UHJvcCA9IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0LCBuYW1lLCBkZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGFyZ2V0W25hbWVdID0gZGVmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZG90aWZ5ID0gZnVuY3Rpb24gZG90aWZ5KG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdmFyIG5ld29iaiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4ID8gcHJlZml4ICsgXCIuXCIgOiBwcmVmaXg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgdm9pZCAwICE9PSBvYmpba2V5XSAmJiBudWxsICE9PSBvYmpba2V5XSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9ialtrZXldICYmIChvYmpba2V5XSAmJiBBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiBvYmpba2V5XS5sZW5ndGggJiYgb2JqW2tleV0uZXZlcnkoZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiICE9PSAodm9pZCAwID09PSB2YWwgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih2YWwpKTtcbiAgICAgICAgICAgICAgICB9KSA/IG5ld29ialtcIlwiICsgcHJlZml4ICsga2V5XSA9IG9ialtrZXldLmpvaW4oXCIsXCIpIDogb2JqW2tleV0gJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihvYmpba2V5XSkgPyBuZXdvYmogPSBkb3RpZnkob2JqW2tleV0sIFwiXCIgKyBwcmVmaXggKyBrZXksIG5ld29iaikgOiBuZXdvYmpbXCJcIiArIHByZWZpeCArIGtleV0gPSBvYmpba2V5XS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3b2JqO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZ2V0T2JqZWN0SUQgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gb2JqIHx8IHZvaWQgMCA9PT0gb2JqIHx8IFwib2JqZWN0XCIgIT09ICh2b2lkIDAgPT09IG9iaiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2Ygb2JqKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gb2JqZWN0SURzLmdldChvYmopO1xuICAgICAgICAgICAgICAgIGlmICghdWlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVpZCA9ICh2b2lkIDAgPT09IG9iaiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaikpICsgXCI6XCIgKyB1bmlxdWVJRCgpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RJRHMuc2V0KG9iaiwgdWlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVpZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2V4ID0gcmVnZXg7XG4gICAgICAgICAgICBleHBvcnRzLnJlZ2V4QWxsID0gZnVuY3Rpb24ocGF0dGVybiwgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXSwgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXgocGF0dGVybiwgc3RyaW5nLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1hdGNoLmVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5jb3VudCA9IGZ1bmN0aW9uKHN0ciwgc3Vic3RyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSAwLCBpdGVtQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RyLmluZGV4T2Yoc3Vic3RyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC0xID09PSBpbmRleCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtQ291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4gICAgICAgICAgICBleHBvcnRzLnN0cmluZ2lmeUVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2ssIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHN0YWNrKSByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBtZXNzYWdlKSByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShlcnIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV4cG9ydHMuZXZlbnRFbWl0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJlZCA9IHt9LCBoYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9uOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTGlzdCA9IGhhbmRsZXJzW2V2ZW50TmFtZV0gPSBoYW5kbGVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9ICEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGhhbmRsZXJMaXN0LmluZGV4T2YoaGFuZGxlciksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyTGlzdCkgZm9yICh2YXIgX2l0ZXJhdG9yID0gaGFuZGxlckxpc3QsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaTIgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pMiA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaTIrK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfaTIgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9oYW5kbGVyID0gX3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyT25jZTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyaWdnZXJlZFtldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcmVkW2V2ZW50TmFtZV0gPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5pcXVlSUQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJzID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieHh4eHh4eHh4eFwiLnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzYWZlSW50ZXJ2YWwobWV0aG9kLCB0aW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gcnVuSW50ZXJ2YWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJ1bkludGVydmFsLCB0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvYmplY3RJRHMgPSBuZXcgKF9fd2VicGFja19yZXF1aXJlX18oXCIuL25vZGVfbW9kdWxlcy9jcm9zcy1kb21haW4tc2FmZS13ZWFrbWFwL3NyYy9pbmRleC5qc1wiKS5XZWFrTWFwKSgpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnZXgocGF0dGVybiwgc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAwO1xuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHBhdHRlcm4gJiYgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3RyaW5nLnNsaWNlKHN0YXJ0KS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5pbmRleCwgbWF0Y2ggPSByZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwczogcmVzdWx0LnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgaW5kZXggKyBtYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IG1hdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBcIlwiICsgbWF0Y2guc2xpY2UoMCwgc3RhcnQgKyBpbmRleCkgKyB0ZXh0ICsgbWF0Y2guc2xpY2UoaW5kZXggKyBtYXRjaC5sZW5ndGgpIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtID8gaXRlbSA6IGl0ZW0gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVtLnRvU3RyaW5nID8gaXRlbS50b1N0cmluZygpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi4vc3JjL3R5cGVzLmpzXCI6IGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9em9pZC5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXpvaWQuanMubWFwIiwiLyogQGZsb3cgKi9cbi8qIGVzbGludCBpbXBvcnQvbm8tY29tbW9uanM6IDAgKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG5pZiAocHJvY2Vzcy5lbnYuWk9JRF9GUkFNRV9PTkxZKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L3pvaWQuZnJhbWUnKTtcbiAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC96b2lkJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3pvaWQnO1xuXG5jb25zdCBDb21wb25lbnQgPSBjcmVhdGUoe1xuICB0YWc6ICdjaGVja291dC1jb21wb25lbnQnLFxuICBkZWZhdWx0RW52OiAnbG9jYWxlJyxcbiAgdXJsOiB7XG4gICAgbG9jYWxlOiAnaHR0cDovL2xvY2FsaG9zdDo1MDAwL2J1dHRvbidcbiAgfSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4iLCJpbXBvcnQgKiBhcyBDb21wb25lbnQgZnJvbSAnLi9Db21wb25lbnQnO1xuXG5jb25zdCBOYW5vID0ge1xuICBDb21wb25lbnRcbn07XG5cbndpbmRvdy5OYW5vID0gTmFubztcblxuZXhwb3J0IGRlZmF1bHQgTmFubztcbiJdLCJzb3VyY2VSb290IjoiIn0=